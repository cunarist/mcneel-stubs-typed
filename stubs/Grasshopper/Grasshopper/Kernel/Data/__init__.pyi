from typing import overload, Any, Iterable, Iterator, Sequence, MutableSequence, Callable
from enum import Enum

from GH_IO.Serialization import GH_IReader
from GH_IO.Serialization import GH_IWriter
from Grasshopper import DataTree
from Grasshopper.GUI.Canvas import GH_Viewport
from Grasshopper.Kernel import IGH_Param
from Grasshopper.Kernel.Expressions import GH_ExpressionParser
from System import AsyncCallback
from System import IAsyncResult
from System import IFormatProvider
from System import IntPtr
from System import TypeCode
from System.Collections import IDictionary
from System.Collections import IList
from System.Collections.Generic import IList
from System.Drawing import Graphics
from System.Drawing import PointF
from System.Drawing import RectangleF
from System.Reflection import MethodBase
from System.Reflection import MethodInfo
from System.Runtime.Serialization import SerializationInfo
from System.Runtime.Serialization import StreamingContext






class GH_BracketMismatchException:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def __init__(self, message: str, location: int): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @property
    def HResult(self) -> int: ...
    @property
    def Index(self) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...
    @overload
    def GetBaseException(self) -> Exception: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetType(self) -> type: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> None: ...
    @Source.setter
    def Source(self, value: str) -> None: ...
    @overload
    def ToString(self) -> str: ...


class GH_DirtyCaster:
    @overload
    @staticmethod
    def CastToList(in_: object) -> MutableSequence[T]: ...
    @overload
    @staticmethod
    def CastToTree(in_: object) -> DataTree: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class GH_ExpandMode(Enum):
    # None = 0
    SimpleReplace = 1
    SimpleAppend = 2
    Recursive = 3


class GH_GraftMode(Enum):
    # None = 0
    GraftNullItems = 1
    GraftEmptyLists = 2
    GraftAll = 3


class GH_GraphicBranch:
    @overload
    def __init__(self): ...
    DomainAngleFactor: float
    TwigLengthFactor: float
    TwigLengthMin: float
    @overload
    def Distribute_Phylogenetic(self, max_path_length_inverse: float) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Angle(self) -> float: ...
    @property
    def Data(self) -> IList: ...
    @property
    def DataCount(self) -> int: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def IsLeaf(self) -> bool: ...
    @property
    def IsRoot(self) -> bool: ...
    @property
    def IsTrunk(self) -> bool: ...
    @property
    def Length(self) -> float: ...
    @property
    def LongestPathLength(self) -> int: ...
    @property
    def Offset(self) -> float: ...
    @property
    def Parent(self) -> GH_GraphicBranch: ...
    @property
    def Path(self) -> GH_Path: ...
    @property
    def Selected(self) -> bool: ...
    @property
    def Twigs(self) -> MutableSequence[GH_GraphicBranch]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GrowTree(self, paths: MutableSequence[GH_Path]) -> None: ...
    @overload
    def RenderNodes(self, G: Graphics, e: GH_GraphicTreeDisplayArgs) -> None: ...
    @overload
    def RenderTags(self, G: Graphics, e: GH_GraphicTreeDisplayArgs) -> None: ...
    @overload
    def RenderWires_Organic(self, G: Graphics, e: GH_GraphicTreeDisplayArgs) -> None: ...
    @overload
    def RenderWires_Schematic(self, G: Graphics, e: GH_GraphicTreeDisplayArgs) -> None: ...
    @overload
    def SelectAll(self, b_path: GH_Path) -> None: ...
    @overload
    def SelectAll(self, bSelect: bool) -> None: ...
    @Angle.setter
    def Angle(self, Value: float) -> None: ...
    @Data.setter
    def Data(self, Value: IList) -> None: ...
    @Length.setter
    def Length(self, Value: float) -> None: ...
    @Offset.setter
    def Offset(self, Value: float) -> None: ...
    @Parent.setter
    def Parent(self, Value: GH_GraphicBranch) -> None: ...
    @Path.setter
    def Path(self, Value: GH_Path) -> None: ...
    @Selected.setter
    def Selected(self, Value: bool) -> None: ...
    @Twigs.setter
    def Twigs(self, Value: MutableSequence[GH_GraphicBranch]) -> None: ...
    @overload
    def SolveLeafAngles(self, angle: float, spread: float, angle_per_item: float, args: GH_GraphicTreeDisplayArgs) -> None: ...
    @overload
    def ToString(self) -> str: ...


class GH_GraphicTreeDisplayArgs:
    @overload
    def __init__(self): ...
    origin: PointF
    radius: float
    maxPathLength: int
    vp: GH_Viewport
    @overload
    def AdjustMaxPathLength(self, potential_new_length: int) -> None: ...
    @overload
    @staticmethod
    def Distance(A: PointF, B: PointF) -> float: ...
    @overload
    @staticmethod
    def Distance(A: PointF, B: PointF, P: PointF) -> float: ...
    @overload
    @staticmethod
    def DistanceSquared(A: PointF, B: PointF) -> float: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def RadialBox(self, box_edge: float) -> RectangleF: ...
    @overload
    def RadialCrd(self, angle: float, offset: float) -> PointF: ...
    @overload
    def RadialX(self, angle: float, offset: float) -> float: ...
    @overload
    def RadialY(self, angle: float, offset: float) -> float: ...
    @overload
    @staticmethod
    def RadToDeg(a: float) -> float: ...
    @overload
    @staticmethod
    def RemapDegrees(a: float) -> float: ...
    @overload
    def SetupViewport(self, vport: GH_Viewport) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Visible(self, rec: RectangleF) -> bool: ...
    @overload
    def Visible(self, pt: PointF) -> bool: ...
    @overload
    def Visible(self, rec: RectangleF, margin: float) -> bool: ...
    @overload
    def Visible(self, pt: PointF, radius: float) -> bool: ...
    @overload
    def Visible(self, ptA: PointF, ptB: PointF, fuzz: float) -> bool: ...
    @overload
    def Visible(self, P0: PointF, P1: PointF, P2: PointF, P3: PointF, fuzz: float) -> bool: ...


class GH_IndexRange:
    @overload
    def __init__(self, index: int): ...
    @overload
    def __init__(self, index0: int, index1: int): ...
    @overload
    def AdjacentTo(self, range: GH_IndexRange) -> bool: ...
    @overload
    def Contains(self, index: int) -> bool: ...
    @overload
    def Contains(self, range: GH_IndexRange) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Index0(self) -> int: ...
    @property
    def Index1(self) -> int: ...
    @property
    @classmethod
    def InvalidRange(cls) -> GH_IndexRange: ...
    @property
    def IsSingular(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    @classmethod
    def MaxValue(cls) -> GH_IndexRange: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Intersection(range0: GH_IndexRange, range1: GH_IndexRange) -> GH_IndexRange: ...
    @overload
    def IntersectsWith(self, range: GH_IndexRange) -> bool: ...
    @overload
    def Read(self, reader: GH_IReader) -> bool: ...
    @overload
    @staticmethod
    def Split(range: GH_IndexRange, splitter: GH_IndexRange) -> tuple[int, GH_IndexRange, GH_IndexRange]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    @staticmethod
    def Union(range0: GH_IndexRange, range1: GH_IndexRange) -> GH_IndexRange: ...
    @overload
    def Write(self, writer: GH_IWriter) -> bool: ...


class GH_IndexRanges:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Count(self) -> int: ...
    @property
    def Range(self) -> Sequence[GH_IndexRange]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def InsertRange(self, range: GH_IndexRange) -> bool: ...
    @overload
    def Read(self, reader: GH_IReader) -> bool: ...
    @overload
    def RemoveRange(self, range: GH_IndexRange) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Write(self, writer: GH_IWriter) -> bool: ...


class GH_IndexRuleSet:
    @overload
    def __init__(self): ...
    @overload
    def AddAnyDigitRule(self) -> None: ...
    @overload
    def AddAnyDigitsRule(self) -> None: ...
    @overload
    def AddDigitPatternRule(self, pattern: Iterable[int]) -> None: ...
    @overload
    def AddDigitPatternRule(self, firstDigit: int, nextDigit: int) -> None: ...
    @overload
    def AddDigitPatternRule(self, firstDigit: int, nextDigit: int, lastDigit: int) -> None: ...
    @overload
    def AddDigitRule(self, digit: int, invert: bool) -> None: ...
    @overload
    def AddRangePatternRule(self, pattern: Iterable[GH_IndexRange]) -> None: ...
    @overload
    def AddRangeRule(self, range: GH_IndexRange, invert: bool) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Evaluate(self, index: int) -> GH_RuleResult: ...
    @property
    def Count(self) -> int: ...
    @property
    def Rule(self) -> Sequence[IGH_IndexRule]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class GH_Lexer:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, mask: str): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def EvaluatePath(self, evaluator: GH_ExpressionParser, path: GH_Path, index: int) -> tuple[bool, GH_Path, int]: ...
    @property
    def IsItem(self) -> bool: ...
    @property
    def IsPath(self) -> bool: ...
    @property
    def Item(self) -> str: ...
    @property
    def Mask(self) -> str: ...
    @property
    def Path(self) -> MutableSequence[str]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def PerformLexicalReplace(source: GH_Lexer, target: GH_Lexer, structure_in: IGH_Structure, structure_out: GH_Structure) -> None: ...
    @overload
    @staticmethod
    def PerformLexicalReplace(source: GH_Lexer, target: GH_Lexer, tree_in: DataTree, tree_out: DataTree) -> None: ...
    @overload
    def ToString(self) -> str: ...


class GH_LexerCombo:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, n_source: GH_Lexer, n_target: GH_Lexer): ...
    @overload
    def __init__(self, n_source: str, n_target: str): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Source(self) -> GH_Lexer: ...
    @property
    def Target(self) -> GH_Lexer: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @Source.setter
    def Source(self, Value: GH_Lexer) -> None: ...
    @Target.setter
    def Target(self, Value: GH_Lexer) -> None: ...
    @overload
    def ToString(self) -> str: ...


class GH_Path:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, index: int): ...
    @overload
    def __init__(self, args: Iterable[int]): ...
    @overload
    def __init__(self, Other: GH_Path): ...
    @overload
    def AppendElement(self, index: int) -> GH_Path: ...
    @overload
    def Compare(self, x: GH_Path, y: GH_Path) -> int: ...
    @overload
    def CompareTo(self, other: GH_Path) -> int: ...
    @overload
    def CullElement(self) -> GH_Path: ...
    @overload
    def CullFirstElement(self) -> GH_Path: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Format(self, format_provider: str, separator: str) -> str: ...
    @overload
    def FromString(self, s: str) -> bool: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @property
    def Indices(self) -> Iterable[int]: ...
    @property
    def InternalPath(self) -> Iterable[int]: ...
    @property
    def Length(self) -> int: ...
    @property
    def Valid(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Increment(self, index: int) -> GH_Path: ...
    @overload
    def Increment(self, index: int, offset: int) -> GH_Path: ...
    @overload
    def IsAncestor(self, potential_ancestor: GH_Path, additional_generations: int) -> tuple[bool, int]: ...
    @overload
    def IsCoincident(self, index_list: Iterable[int]) -> bool: ...
    @overload
    def IsCoincident(self, other: GH_Path) -> bool: ...
    @overload
    def __eq__(A: GH_Path, B: GH_Path) -> bool: ...
    @overload
    def __gt__(A: GH_Path, B: GH_Path) -> bool: ...
    @overload
    def __ne__(A: GH_Path, B: GH_Path) -> bool: ...
    @overload
    def __lt__(A: GH_Path, B: GH_Path) -> bool: ...
    @overload
    def PrependElement(self, index: int) -> GH_Path: ...
    @overload
    def Read(self, reader: GH_IReader) -> bool: ...
    @property
    def Dimension(self) -> MutableSequence[int]: ...
    @Indices.setter
    def Indices(self, Value: Iterable[int]) -> None: ...
    @InternalPath.setter
    def InternalPath(self, Value: Iterable[int]) -> None: ...
    @overload
    @staticmethod
    def SplitPathLikeString(s: str) -> tuple[bool, Iterable[str], str]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, includeBrackets: bool) -> str: ...
    @overload
    def Write(self, writer: GH_IWriter) -> bool: ...


class GH_PathOffset:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, pathShift: Iterable[int]): ...
    @overload
    def __init__(self, pathShift: Iterable[int], itemShift: int): ...
    @overload
    def __init__(self, pathShift: Iterable[int], itemShift: int, pathWrap: bool, itemWrap: bool): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def ItemOffset(self) -> int: ...
    @property
    def ItemWrap(self) -> bool: ...
    @property
    def PathOffset(self) -> MutableSequence[int]: ...
    @property
    def PathWrap(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def OffsetPath(self, path: GH_Path, index: int, rel_path: GH_Path, rel_index: int) -> tuple[bool, GH_Path, int]: ...
    @overload
    def OffsetPath(self, path: GH_Path, index: int, tree: IGH_Structure) -> tuple[bool, GH_Path, int]: ...
    @overload
    @staticmethod
    def ParseString(mask: str) -> GH_PathOffset: ...
    @ItemOffset.setter
    def ItemOffset(self, Value: int) -> None: ...
    @ItemWrap.setter
    def ItemWrap(self, Value: bool) -> None: ...
    @PathWrap.setter
    def PathWrap(self, Value: bool) -> None: ...
    @overload
    def ToString(self) -> str: ...


class GH_RuleAnyNumber:
    @overload
    def __init__(self): ...
    @overload
    def Apply(self, number: int) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Kind(self) -> GH_RuleKind: ...
    @property
    def Notation(self) -> str: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class GH_RuleAnyNumbers:
    @overload
    def __init__(self): ...
    @overload
    def Apply(self, number: int) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Kind(self) -> GH_RuleKind: ...
    @property
    def Notation(self) -> str: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class GH_RuleComplex:
    @overload
    def __init__(self, fragments: Iterable[IGH_Rule], operators: Iterable[GH_RuleOperator]): ...
    @overload
    def Apply(self, number: int) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Kind(self) -> GH_RuleKind: ...
    @property
    def Notation(self) -> str: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class GH_RuleGroup:
    @overload
    def __init__(self, numbers: Iterable[int], negate: bool): ...
    @overload
    def Apply(self, number: int) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Kind(self) -> GH_RuleKind: ...
    @property
    def Notation(self) -> str: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class GH_RuleKind(Enum):
    # None = 0
    AnyNumber = 1
    AnyNumbers = 2
    Number = 3
    Group = 4
    Range = 5
    Sequence = 6
    Complex = 7


class GH_RuleNumber:
    @overload
    def __init__(self, number: int, negate: bool): ...
    @overload
    def Apply(self, number: int) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Kind(self) -> GH_RuleKind: ...
    @property
    def Notation(self) -> str: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class GH_RuleOperator(Enum):
    Conjunction = 0
    Disjunction = 1


class GH_RuleRange:
    @overload
    def __init__(self, min: int, max: int, negate: bool): ...
    @overload
    def Apply(self, number: int) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Kind(self) -> GH_RuleKind: ...
    @property
    def Notation(self) -> str: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class GH_RuleResult(Enum):
    NoOpinion = 0
    Include = 1
    Exclude = -1


class GH_RuleSequence:
    @overload
    def __init__(self, sequence: Iterable[int], limit: int, negate: bool): ...
    @overload
    def Apply(self, number: int) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Kind(self) -> GH_RuleKind: ...
    @property
    def Notation(self) -> str: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class GH_SimplificationMode(Enum):
    # None = 0
    CollapseLeadingOverlaps = 1
    CollapseAllOverlaps = 2


class GH_StringMismatchException:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @property
    def HResult(self) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...
    @overload
    def GetBaseException(self) -> Exception: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetType(self) -> type: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> None: ...
    @Source.setter
    def Source(self, value: str) -> None: ...
    @overload
    def ToString(self) -> str: ...




class GH_TreeBuilder:
    @overload
    def __init__(self): ...
    @overload
    def AddPath(self, p: GH_Path) -> None: ...
    @overload
    def AddPathRecursive(self, p: GH_Path) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def AllPaths(self) -> MutableSequence[GH_Path]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class GH_TreeFilter:
    @overload
    def __init__(self): ...
    PathOpen: str
    PathClose: str
    ItemOpen: str
    ItemClose: str
    PathSeparator: str
    SegmentSeparator: str
    StringDelimeter: str
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @staticmethod
    def FindItemBrackets(text: str) -> tuple[bool, int, int]: ...
    @overload
    @staticmethod
    def FindNextLevelChar(text: str, index: int, char: str) -> int: ...
    @overload
    @staticmethod
    def FindPathBrackets(text: str) -> tuple[bool, int, int]: ...
    @overload
    @staticmethod
    def FindPrevLevelChar(text: str, index: int, char: str) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def ParsePattern(filter: str) -> GH_TreeFilter: ...
    @overload
    @staticmethod
    def SplitStringWithExpressions(text: str, separator: str) -> MutableSequence[str]: ...
    @overload
    def ToString(self) -> str: ...


class GH_TreeIndex:
    @overload
    def __init__(self, path: GH_Path, item: int): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Item(self) -> int: ...
    @property
    def Path(self) -> GH_Path: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @Item.setter
    def Item(self, AutoPropertyValue: int) -> None: ...
    @Path.setter
    def Path(self, AutoPropertyValue: GH_Path) -> None: ...
    @overload
    def ToString(self) -> str: ...


class GH_TreeRules:
    @overload
    def __init__(self, pathRules: Iterable[IGH_Rule], indexRule: IGH_Rule): ...
    OrOperator: str
    AndOperator: str
    NotOperator: str
    RangeSymbol: str
    Separator: str
    SequenceSymbol: str
    SequenceCode: str
    PathSeparator: str
    AnyNumberSymbol: str
    AnyNumbersSymbol: str
    PathOpenBracket: str
    PathCloseBracket: str
    ItemOpenBracket: str
    ItemCloseBracket: str
    RuleOpenBracket: str
    RuleCloseBracket: str
    PathBrackets: str
    ItemBrackets: str
    RuleBrackets: str
    AllowedChars: str
    @overload
    def Apply(self, path: GH_Path) -> bool: ...
    @overload
    def Apply(self, path: GH_Path, index: int) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @staticmethod
    def FromString(text: str, message: str) -> tuple[GH_TreeRules, str]: ...
    @property
    def HasItemRule(self) -> bool: ...
    @property
    def HasPathRules(self) -> bool: ...
    @property
    def PathRuleCount(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class IGH_DataTree:
    @overload
    def MergeWithParameter(self, param: IGH_Param) -> bool: ...


class IGH_IndexRule:
    @overload
    def Evaluate(self, index: int) -> GH_RuleResult: ...


class IGH_Rule:
    @overload
    def Apply(self, number: int) -> bool: ...
    @property
    def Kind(self) -> GH_RuleKind: ...
    @property
    def Notation(self) -> str: ...


class IGH_Structure:
    @overload
    def AllData(self, skipNulls: bool) -> IGH_StructureEnumerator: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def ClearData(self) -> None: ...
    @overload
    def DataDescription(self, includeIndices: bool, includePaths: bool) -> str: ...
    @overload
    def EnsureCapacity(self, capacity: int) -> None: ...
    @overload
    def ExpandPath(self, path: GH_Path, element: int, mode: GH_ExpandMode) -> None: ...
    @overload
    def Flatten(self, path: GH_Path) -> None: ...
    @property
    def Branch(self) -> Sequence[IList]: ...
    @property
    def Branch(self, path: GH_Path) -> IList: ...
    @property
    def DataCount(self) -> int: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def Path(self) -> Sequence[GH_Path]: ...
    @property
    def PathCount(self) -> int: ...
    @property
    def Paths(self) -> Iterable[GH_Path]: ...
    @property
    def StructureProxy(self) -> Iterable[IList]: ...
    @property
    def TopologyDescription(self) -> str: ...
    @overload
    def Graft(self, mode: GH_GraftMode) -> None: ...
    @overload
    def Graft(self, mode: GH_GraftMode, path: GH_Path) -> None: ...
    @overload
    def LongestPathIndex(self) -> int: ...
    @overload
    def PathExists(self, path: GH_Path) -> bool: ...
    @overload
    def PathIndex(self, path: GH_Path, idx0: int, idx1: int) -> tuple[int, int]: ...
    @overload
    def RemovePath(self, path: GH_Path) -> None: ...
    @overload
    def ReplacePath(self, find: GH_Path, replace: GH_Path) -> None: ...
    @overload
    def ShortestPathIndex(self) -> int: ...
    @overload
    def Simplify(self, mode: GH_SimplificationMode) -> None: ...
    @overload
    def TrimExcess(self) -> None: ...


class IGH_StructureEnumerator:
    def __iter__(self) -> Iterator[IGH_Goo]: ...


class PathLengthComparer:
    @overload
    def __init__(self): ...
    @overload
    def Compare(self, x: GH_Path, y: GH_Path) -> int: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...
