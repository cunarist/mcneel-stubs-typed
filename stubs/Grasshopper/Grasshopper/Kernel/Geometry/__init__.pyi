from typing import overload, Any
from collections.abc import Iterable, Iterator, Sequence, MutableSequence, Callable
from enum import Enum

from Grasshopper.Kernel.Types import IGH_GeometricGoo
from Rhino.Geometry import BoundingBox
from Rhino.Geometry import Curve
from Rhino.Geometry import GeometryBase
from Rhino.Geometry import Plane
from Rhino.Geometry import Point3d
from Rhino.Geometry import Point3f
from Rhino.Geometry import Vector2d
from Rhino.Geometry import Vector2f
from Rhino.Geometry import Vector3d
from Rhino.Geometry import Vector3f
from System import AsyncCallback
from System import IAsyncResult
from System import IFormatProvider
from System import IntPtr
from System import TypeCode
from System.Collections.Generic import IList
from System.Reflection import MethodInfo
from System.Runtime.Serialization import SerializationInfo
from System.Runtime.Serialization import StreamingContext

from . import ConvexHull
from . import Delaunay
from . import SpatialTrees
from . import Voronoi

__all__ = ['ConvexHull', 'Delaunay', 'SpatialTrees', 'Voronoi']



class Circle2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Circle2): ...
    @overload
    def __init__(self, origin: Node2, radius: float): ...
    @overload
    def __init__(self, A: Node2, B: Node2, C: Node2): ...
    O: Node2
    R: float
    @overload
    @staticmethod
    def Circle3Pt(ax: float, ay: float, bx: float, by: float, cx: float, cy: float, ox: float, oy: float, r2: float) -> tuple[bool, float, float, float]: ...
    @overload
    def ClosestPointTo(self, pt: Node2) -> float: ...
    @overload
    def ClosestPointTo(self, x: float, y: float) -> float: ...
    @overload
    def ClosestPointTo(self, pt: Node2, t: float) -> tuple[Node2, float]: ...
    @overload
    def ClosestPointTo(self, x: float, y: float, t: float) -> tuple[Node2, float]: ...
    @overload
    def Contains(self, pt: Node2) -> Containment: ...
    @overload
    def Contains(self, x: float, y: float) -> Containment: ...
    @overload
    def Duplicate(self) -> Circle2: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Area(self) -> float: ...
    @property
    def Circumference(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Intersect(self, line: Line2, l0: float, l1: float) -> tuple[LineCircleX, float, float]: ...
    @overload
    def Intersect(self, line: Line2, l0: float, l1: float, a0: float, a1: float) -> tuple[LineCircleX, float, float, float, float]: ...
    @overload
    def PointAt(self, t: float) -> Node2: ...
    @overload
    def TangentAt(self, t: float) -> Vec2: ...
    @overload
    def ToString(self) -> str: ...


class Containment(Enum):
    none = 0
    inside = 1
    coincident = 2
    outside = 3


class GH_CurveOffset:
    @overload
    def __init__(self, curve: Curve, offsetPlane: Plane): ...
    @overload
    def __init__(self, curves: Iterable[Curve], offsetPlane: Plane): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def OffsetPlane(self) -> Plane: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Offset(self, distance: float, corner: GH_CurveOffsetCorner) -> MutableSequence[Curve]: ...
    @overload
    def OffsetSamples(self, distance: float) -> MutableSequence[Point3dList]: ...
    @overload
    def ToString(self) -> str: ...


class GH_CurveOffsetCorner(Enum):
    Chamfer = 0
    Sharp = 1
    Fillet = 2


class GH_SanityXForm:
    @overload
    def __init__(self): ...
    @overload
    def CreateSanityXForms(self, box: BoundingBox) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def MakeInsane(self, geometry: GeometryBase) -> None: ...
    @overload
    def MakeInsane(self, geometry: IGH_GeometricGoo) -> tuple[IGH_GeometricGoo]: ...
    @overload
    def MakeInsane(self, geometry: Point3d) -> tuple[Point3d]: ...
    @overload
    def MakeInsane(self, geometry: Plane) -> tuple[Plane]: ...
    @overload
    def MakeSane(self, geometry: GeometryBase) -> None: ...
    @overload
    def MakeSane(self, geometry: IGH_GeometricGoo) -> tuple[IGH_GeometricGoo]: ...
    @overload
    def MakeSane(self, geometry: Point3d) -> tuple[Point3d]: ...
    @overload
    def MakeSane(self, geometry: Plane) -> tuple[Plane]: ...
    @overload
    def ToString(self) -> str: ...


class ILeafAction:
    @overload
    def LeafAction(self, Leaf: Node2Leaf) -> VorLeafRecursionResult: ...


class ILeafAction:
    @overload
    def LeafAction(self, Leaf: Node3Leaf) -> VorLeafRecursionResult: ...


class LeafAction:
    @overload
    def __init__(self, TargetObject: object, TargetMethod: IntPtr): ...
    @overload
    def BeginInvoke(self, Leaf: Node3Leaf, DelegateCallback: AsyncCallback, DelegateAsyncState: object) -> IAsyncResult: ...
    @overload
    def Clone(self) -> object: ...
    @overload
    def DynamicInvoke(self, args: Iterable[object]) -> object: ...
    @overload
    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> VorLeafRecursionResult: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> object: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetInvocationList(self) -> Iterable[Delegate]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Invoke(self, Leaf: Node3Leaf) -> VorLeafRecursionResult: ...
    @overload
    def ToString(self) -> str: ...


class LeafAction:
    @overload
    def __init__(self, TargetObject: object, TargetMethod: IntPtr): ...
    @overload
    def BeginInvoke(self, Leaf: Node2Leaf, DelegateCallback: AsyncCallback, DelegateAsyncState: object) -> IAsyncResult: ...
    @overload
    def Clone(self) -> object: ...
    @overload
    def DynamicInvoke(self, args: Iterable[object]) -> object: ...
    @overload
    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> VorLeafRecursionResult: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> object: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetInvocationList(self) -> Iterable[Delegate]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Invoke(self, Leaf: Node2Leaf) -> VorLeafRecursionResult: ...
    @overload
    def ToString(self) -> str: ...


class Line2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Line2): ...
    @overload
    def __init__(self, nA: Node2, nB: Node2): ...
    @overload
    def __init__(self, nAx: float, nAy: float, nBx: float, nBy: float): ...
    Ax: float
    Ay: float
    Bx: float
    By: float
    @overload
    def ClosestPoint(self, pt: Node2) -> float: ...
    @overload
    def ClosestPoint(self, x: float, y: float) -> float: ...
    @overload
    def DistanceTo(self, pt: Node2) -> float: ...
    @overload
    def DistanceTo(self, x: float, y: float) -> float: ...
    @overload
    def DistanceToSquared(self, pt: Node2) -> float: ...
    @overload
    def DistanceToSquared(self, x: float, y: float) -> float: ...
    @overload
    def Duplicate(self) -> Line2: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Intersect(A: Line2, B: Line2, t: float) -> tuple[LineX, float]: ...
    @overload
    @staticmethod
    def Intersect(A: Line2, B: Line2, t0: float, t1: float) -> tuple[LineX, float, float]: ...
    @overload
    @staticmethod
    def Intersect(Ax: float, Ay: float, Bx: float, By: float, Cx: float, Cy: float, Dx: float, Dy: float, t: float) -> tuple[LineX, float]: ...
    @overload
    @staticmethod
    def Intersect(Ax: float, Ay: float, Bx: float, By: float, Cx: float, Cy: float, Dx: float, Dy: float, t0: float, t1: float) -> tuple[LineX, float, float]: ...
    @overload
    def Length(self) -> float: ...
    @overload
    def LengthSquared(self) -> float: ...
    @overload
    @staticmethod
    def MidLine(A: Node2, B: Node2) -> Line2: ...
    @overload
    @staticmethod
    def MidLine(A: Node2, B: Node2, Wa: float, Wb: float) -> Line2: ...
    @overload
    def PointAt(self, t: float) -> Node2: ...
    @overload
    def Set(self, other: Line2) -> None: ...
    @overload
    def Set(self, A: Node2, B: Node2) -> None: ...
    @overload
    @staticmethod
    def Side(edge: Line2, pt: Node2) -> Side2: ...
    @overload
    @staticmethod
    def Side(Ax: float, Ay: float, Bx: float, By: float, Px: float, Py: float) -> Side2: ...
    @overload
    def ToString(self) -> str: ...


class Line3:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Line3): ...
    @overload
    def __init__(self, nA: Node3, nB: Node3): ...
    @overload
    def __init__(self, nAx: float, nAy: float, nAz: float, nBx: float, nBy: float, nBz: float): ...
    Ax: float
    Ay: float
    Az: float
    Bx: float
    By: float
    Bz: float
    @overload
    def ClosestPoint(self, pt: Node3) -> float: ...
    @overload
    def ClosestPoint(self, x: float, y: float, z: float) -> float: ...
    @overload
    def DistanceTo(self, pt: Node3) -> float: ...
    @overload
    def DistanceTo(self, x: float, y: float, z: float) -> float: ...
    @overload
    def DistanceToSquared(self, pt: Node3) -> float: ...
    @overload
    def DistanceToSquared(self, x: float, y: float, z: float) -> float: ...
    @overload
    def Duplicate(self) -> Line3: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Intersect(A: Line3, B: Line3, t: float) -> tuple[LineX, float]: ...
    @overload
    @staticmethod
    def Intersect(A: Line3, B: Line3, t0: float, t1: float) -> tuple[LineX, float, float]: ...
    @overload
    @staticmethod
    def Intersect(Ax: float, Ay: float, Az: float, Bx: float, By: float, Bz: float, Cx: float, Cy: float, Cz: float, Dx: float, Dy: float, Dz: float, t: float) -> tuple[LineX, float]: ...
    @overload
    @staticmethod
    def Intersect(Ax: float, Ay: float, Az: float, Bx: float, By: float, Bz: float, Cx: float, Cy: float, Cz: float, Dx: float, Dy: float, Dz: float, t0: float, t1: float) -> tuple[LineX, float, float]: ...
    @overload
    def Length(self) -> float: ...
    @overload
    def LengthSquared(self) -> float: ...
    @overload
    def PointAt(self, t: float) -> Node3: ...
    @overload
    def Set(self, other: Line3) -> None: ...
    @overload
    def Set(self, A: Node3, B: Node3) -> None: ...
    @overload
    def ToString(self) -> str: ...


class LineCircleX(Enum):
    # None = 0
    Tangent = 1
    Secant = 2


class LineX(Enum):
    # None = 0
    Parallel = 1
    Coincident = 2
    Point = 3


class Node2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Node2): ...
    @overload
    def __init__(self, nx: float, ny: float): ...
    @overload
    def __init__(self, nx: float, ny: float, n_tag: int): ...
    @overload
    def __init__(self, other: Node2, dx: float, dy: float): ...
    @overload
    def __init__(self, A: Node2, B: Node2, f: float, n_tag: int): ...
    x: float
    y: float
    tag: int
    @overload
    def CompareTo(self, other: Node2) -> int: ...
    @overload
    def CompareTo(self, other: Node2, tolerance: float) -> int: ...
    @overload
    def Distance(self, other: Node2) -> float: ...
    @overload
    def Distance(self, nx: float, ny: float) -> float: ...
    @overload
    def DistanceSquared(self, other: Node2) -> float: ...
    @overload
    def DistanceSquared(self, nx: float, ny: float) -> float: ...
    @overload
    def Duplicate(self) -> Node2: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IsCoincident(self, other: Node2) -> bool: ...
    @overload
    def IsCoincident(self, ox: float, oy: float) -> bool: ...
    @overload
    def Offset(self, dx: float, dy: float) -> None: ...
    @overload
    def __add__(P: Node2, V: Vec2) -> Node2: ...
    @overload
    def __add__(A: Node2, B: Node2) -> Node2: ...
    @overload
    def __rmul__(N: Node2, f: float) -> Node2: ...
    @overload
    def __mul__(N: Node2, f: float) -> Node2: ...
    @overload
    def __sub__(P: Node2, V: Vec2) -> Node2: ...
    @overload
    def __sub__(A: Node2, B: Node2) -> Vec2: ...
    @overload
    def Set(self, other: Node2) -> None: ...
    @overload
    def Set(self, nX: float, nY: float) -> None: ...
    @overload
    def ToString(self) -> str: ...


class Node2Leaf:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Node2Leaf): ...
    @overload
    def __init__(self, x0: float, x1: float, y0: float, y1: float): ...
    @overload
    def Contains(self, x: float, y: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def A(self) -> Node2Leaf: ...
    @property
    def B(self) -> Node2Leaf: ...
    @property
    def C(self) -> Node2Leaf: ...
    @property
    def D(self) -> Node2Leaf: ...
    @property
    def Nodes(self) -> MutableSequence[int]: ...
    @property
    def SubLeafCount(self) -> int: ...
    @property
    def x_max(self) -> float: ...
    @property
    def x_mid(self) -> float: ...
    @property
    def x_min(self) -> float: ...
    @property
    def y_max(self) -> float: ...
    @property
    def y_mid(self) -> float: ...
    @property
    def y_min(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def MaximumDistance(self, x: float, y: float) -> float: ...
    @overload
    def MaximumDistanceSquared(self, x: float, y: float) -> float: ...
    @overload
    def MinimumDistance(self, x: float, y: float) -> float: ...
    @overload
    def MinimumDistanceSquared(self, x: float, y: float) -> float: ...
    @overload
    def PerformLeafAction(self, func: LeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def PerformLeafAction(self, func: ILeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def SolveProximity(self, nodes: Node2List, prox: Node2Proximity) -> None: ...
    @overload
    def SubDivide(self, nodes: Node2List, index_subset: MutableSequence[int], group_limit: int) -> None: ...
    @overload
    def ToString(self) -> str: ...


class Node2List:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, L: Iterable[Node2]): ...
    @overload
    def __init__(self, L: Node2List): ...
    @overload
    def __init__(self, pts: Iterable[GH_Point]): ...
    @overload
    def __init__(self, pts: Iterable[Point3d]): ...
    def __iter__(self) -> Iterator[Node2]: ...
    @overload
    def Append(self, node: Node2) -> None: ...
    @overload
    def AppendRange(self, nodes: Iterable[Node2]) -> None: ...
    @overload
    def BinarySearch_I(self, i: int) -> int: ...
    @overload
    def BinarySearch_X(self, x: float) -> int: ...
    @overload
    def BinarySearch_Y(self, y: float) -> int: ...
    @overload
    def BoundingBox(self, GrowthFactor: float, ForceSquareLeaves: bool, x0: float, x1: float, y0: float, y1: float) -> tuple[bool, float, float, float, float]: ...
    @overload
    def CreateTree(self, GrowthFactor: float, SquareLeaves: bool, GroupLimit: int) -> Node2Tree: ...
    @overload
    def CullDuplicates(self) -> int: ...
    @overload
    def CullNullRefs(self) -> int: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def ExpireSequence(self) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def InternalList(self) -> MutableSequence[Node2]: ...
    @overload
    def GetEnumerator(self) -> Iterator[Node2]: ...
    @overload
    def GetEnumerator1(self) -> Iterator[Any]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Insert(self, index: int, node: Node2) -> None: ...
    @overload
    def InsertRange(self, index: int, nodes: Iterable[Node2]) -> None: ...
    @overload
    def JitterNodes(self, amount: float) -> None: ...
    @overload
    def NearestNodes(self, x: float, y: float, N: int, min_dist_squared: float, max_dist_squared: float) -> MutableSequence[int]: ...
    @overload
    def NullifyDuplicates(self) -> int: ...
    @overload
    def Remove(self, node: Node2) -> bool: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RenumberNodes(self) -> None: ...
    @Capacity.setter
    def Capacity(self, Value: int) -> None: ...
    @InternalList.setter
    def InternalList(self, Value: MutableSequence[Node2]) -> None: ...
    @property
    def Node(self) -> MutableSequence[Node2]: ...
    @overload
    def Sort(self, type: NodeListSort) -> None: ...
    @overload
    def ToString(self) -> str: ...


class Node2Proximity:
    @overload
    def __init__(self, search_start: Node2, search_start_index: int): ...
    @overload
    def __init__(self, search_start: Node2, search_start_index: int, max_results: int): ...
    @overload
    def __init__(self, search_start: Node2, search_start_index: int, max_results: int, min_distance: float, max_distance: float): ...
    @overload
    def DistanceRange(self, d0: float, d1: float) -> tuple[float, float]: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def CurrentCount(self) -> int: ...
    @property
    def DistanceList(self) -> MutableSequence[float]: ...
    @property
    def FurthestDistance(self) -> float: ...
    @property
    def FurthestDistanceSquared(self) -> float: ...
    @property
    def FurthestPoint(self) -> int: ...
    @property
    def IndexList(self) -> MutableSequence[int]: ...
    @property
    def MaximumCount(self) -> int: ...
    @property
    def MaxSearchRadius(self) -> float: ...
    @property
    def MaxSearchRadiusSquared(self) -> float: ...
    @property
    def MinSearchRadius(self) -> float: ...
    @property
    def MinSearchRadiusSquared(self) -> float: ...
    @property
    def NearestDistance(self) -> float: ...
    @property
    def NearestDistanceSquared(self) -> float: ...
    @property
    def NearestPoint(self) -> int: ...
    @property
    def Start(self) -> Node2: ...
    @property
    def StartIndex(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def RegisterNode(self, node: Node2, index: int) -> bool: ...
    @overload
    def ResetLists(self) -> None: ...
    @overload
    def ToString(self) -> str: ...


class Node2Tree:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, owner: Node2List): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def PerformAction(self, func: LeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def PerformAction(self, func: ILeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def RecreateTree(self, GrowthFactor: float, ForceSquareLeaves: bool, GroupLimit: int) -> bool: ...
    @overload
    def SolveProximity(self, prox: Node2Proximity) -> None: ...
    @overload
    def ToString(self) -> str: ...


class Node3:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Node3): ...
    @overload
    def __init__(self, other: Point3d, nI: int): ...
    @overload
    def __init__(self, other: Point3f, nI: int): ...
    @overload
    def __init__(self, nX: float, nY: float, nZ: float, nI: int): ...
    x: float
    y: float
    z: float
    tag: int
    @overload
    def Coincident(self, other: Node3) -> bool: ...
    @overload
    def CoincidentFlat(self, other: Node3) -> bool: ...
    @overload
    def CompareTo(self, other: Node3) -> int: ...
    @overload
    def Distance(self, other: Node3) -> float: ...
    @overload
    def Distance(self, ox: float, oy: float, oz: float) -> float: ...
    @overload
    def DistanceSquared(self, other: Node3) -> float: ...
    @overload
    def DistanceSquared(self, ox: float, oy: float, oz: float) -> float: ...
    @overload
    def Duplicate(self) -> Node3: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Offset(self, dx: float, dy: float, dz: float) -> None: ...
    @overload
    def __add__(P: Node3, V: Vec3) -> Node3: ...
    @overload
    def __sub__(A: Node3, B: Node3) -> Vec3: ...
    @overload
    def Set(self, other: Node3) -> None: ...
    @overload
    def Set(self, nX: float, nY: float, nZ: float) -> None: ...
    @overload
    def ToString(self) -> str: ...


class Node3Leaf:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Node3Leaf): ...
    @overload
    def __init__(self, x0: float, x1: float, y0: float, y1: float, z0: float, z1: float): ...
    @overload
    def Contains(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def A(self) -> Node3Leaf: ...
    @property
    def B(self) -> Node3Leaf: ...
    @property
    def C(self) -> Node3Leaf: ...
    @property
    def D(self) -> Node3Leaf: ...
    @property
    def E(self) -> Node3Leaf: ...
    @property
    def F(self) -> Node3Leaf: ...
    @property
    def G(self) -> Node3Leaf: ...
    @property
    def H(self) -> Node3Leaf: ...
    @property
    def Nodes(self) -> MutableSequence[int]: ...
    @property
    def SubLeafCount(self) -> int: ...
    @property
    def x_max(self) -> float: ...
    @property
    def x_mid(self) -> float: ...
    @property
    def x_min(self) -> float: ...
    @property
    def y_max(self) -> float: ...
    @property
    def y_mid(self) -> float: ...
    @property
    def y_min(self) -> float: ...
    @property
    def z_max(self) -> float: ...
    @property
    def z_mid(self) -> float: ...
    @property
    def z_min(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def MaximumDistance(self, x: float, y: float, z: float) -> float: ...
    @overload
    def MaximumDistanceSquared(self, x: float, y: float, z: float) -> float: ...
    @overload
    def MinimumDistance(self, x: float, y: float, z: float) -> float: ...
    @overload
    def MinimumDistanceSquared(self, x: float, y: float, z: float) -> float: ...
    @overload
    def PerformLeafAction(self, func: LeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def PerformLeafAction(self, func: ILeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def RemoveNode(self, nodes: Node3List, nodeTag: int) -> bool: ...
    @overload
    def RemoveNode(self, nodes: Node3List, node: Node3) -> bool: ...
    @overload
    def SolveProximity(self, nodes: Node3List, prox: Node3Proximity) -> None: ...
    @overload
    def SubDivide(self, nodes: Node3List, index_subset: MutableSequence[int], group_limit: int) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def TrimExcess(self) -> None: ...


class Node3List:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, L: Iterable[Node3]): ...
    @overload
    def __init__(self, L: Node3List): ...
    @overload
    def __init__(self, pts: Iterable[GH_Point]): ...
    @overload
    def __init__(self, pts: Iterable[Point3d]): ...
    @overload
    def Append(self, node: Node3) -> None: ...
    @overload
    def AppendRange(self, nodes: Iterable[Node3]) -> None: ...
    @overload
    def BinarySearch_I(self, i: int) -> int: ...
    @overload
    def BinarySearch_X(self, x: float) -> int: ...
    @overload
    def BinarySearch_Y(self, y: float) -> int: ...
    @overload
    def BinarySearch_Z(self, z: float) -> int: ...
    @overload
    def BoundingBox(self, GrowthFactor: float, ForceSquareLeaves: bool, x0: float, x1: float, y0: float, y1: float, z0: float, z1: float) -> tuple[bool, float, float, float, float, float, float]: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def CreateTree(self, GrowthFactor: float, SquareLeaves: bool, GroupLimit: int) -> Node3Tree: ...
    @overload
    def CullDuplicates(self) -> int: ...
    @overload
    def CullNullRefs(self) -> int: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def ExpireSequence(self) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def InternalList(self) -> MutableSequence[Node3]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Insert(self, index: int, node: Node3) -> None: ...
    @overload
    def InsertRange(self, index: int, nodes: Iterable[Node3]) -> None: ...
    @overload
    def JitterNodes(self, amount: float) -> None: ...
    @overload
    def NearestNodes(self, x: float, y: float, z: float, N: int, min_dist_squared: float, max_dist_squared: float) -> MutableSequence[int]: ...
    @overload
    def NullifyDuplicates(self) -> int: ...
    @overload
    def Remove(self, node: Node3) -> bool: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RenumberNodes(self) -> None: ...
    @Capacity.setter
    def Capacity(self, Value: int) -> None: ...
    @InternalList.setter
    def InternalList(self, Value: MutableSequence[Node3]) -> None: ...
    @property
    def Node(self) -> MutableSequence[Node3]: ...
    @overload
    def Sort(self, type: NodeListSort) -> None: ...
    @overload
    def ToString(self) -> str: ...


class Node3Proximity:
    @overload
    def __init__(self, search_start: Node3, search_start_index: int): ...
    @overload
    def __init__(self, search_start: Node3, search_start_index: int, max_results: int): ...
    @overload
    def __init__(self, search_start: Node3, search_start_index: int, max_results: int, min_distance: float, max_distance: float): ...
    @overload
    def DistanceRange(self, d0: float, d1: float) -> tuple[float, float]: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def CurrentCount(self) -> int: ...
    @property
    def DistanceList(self) -> MutableSequence[float]: ...
    @property
    def FurthestDistance(self) -> float: ...
    @property
    def FurthestDistanceSquared(self) -> float: ...
    @property
    def FurthestPoint(self) -> int: ...
    @property
    def IndexList(self) -> MutableSequence[int]: ...
    @property
    def MaximumCount(self) -> int: ...
    @property
    def MaxSearchRadius(self) -> float: ...
    @property
    def MaxSearchRadiusSquared(self) -> float: ...
    @property
    def MinSearchRadius(self) -> float: ...
    @property
    def MinSearchRadiusSquared(self) -> float: ...
    @property
    def NearestDistance(self) -> float: ...
    @property
    def NearestDistanceSquared(self) -> float: ...
    @property
    def NearestPoint(self) -> int: ...
    @property
    def Start(self) -> Node3: ...
    @property
    def StartIndex(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def RegisterNode(self, node: Node3, index: int) -> bool: ...
    @overload
    def ResetLists(self) -> None: ...
    @overload
    def ToString(self) -> str: ...


class Node3Tree:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, owner: Node3List): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Root(self) -> Node3Leaf: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def PerformAction(self, func: LeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def PerformAction(self, func: ILeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def RecreateTree(self, growthFactor: float, squareLeaves: bool, groupLimit: int) -> bool: ...
    @overload
    def SolveProximity(self, prox: Node3Proximity) -> None: ...
    @overload
    def ToString(self) -> str: ...


class NodeListSort(Enum):
    none = 0
    X = 1
    Y = 2
    Z = 3
    Index = 4


class NodeListSort(Enum):
    none = 0
    X = 1
    Y = 2
    Index = 3


class Parallax(Enum):
    Divergent = 0
    Parallel = 1
    AntiParallel = -1


class Plane:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Plane): ...
    @overload
    def __init__(self, other: Plane): ...
    @overload
    def __init__(self, nOrigin: Node3, nNormal: Vec3): ...
    @overload
    def __init__(self, nOrigin: Node3, nXAxis: Vec3, nYAxis: Vec3): ...
    @overload
    def __init__(self, nOrigin: Node3, nXAxis: Vec3, nYAxis: Vec3, nZAxis: Vec3): ...
    origin: Node3
    x_axis: Vec3
    y_axis: Vec3
    z_axis: Vec3
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    @classmethod
    def World_XY(cls) -> Plane: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def PointAt(self, u: float, v: float) -> Node3: ...
    @overload
    def PointAt(self, u: float, v: float, w: float) -> Node3: ...
    @overload
    def Project(self, pt: Node3) -> None: ...
    @overload
    def Project(self, pts: Iterable[Node3]) -> None: ...
    @overload
    def Project(self, pt: Node3, s: float, t: float) -> tuple[float, float]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Unitize(self) -> None: ...


class PointCloud:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def InsertPoint(self, pt: Point3d) -> int: ...
    @overload
    def ToString(self) -> str: ...


class Rectangle2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, p0: Node2, p1: Node2): ...
    @overload
    def __init__(self, x0: float, y0: float, x1: float, y1: float): ...
    x_min: float
    y_min: float
    x_max: float
    y_max: float
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Grow(self, pt: Node2) -> None: ...
    @overload
    def Grow(self, rec: Rectangle2) -> None: ...
    @overload
    def Grow(self, x: float, y: float) -> None: ...
    @overload
    def Includes(self, pt: Node2) -> Containment: ...
    @overload
    def Includes(self, x: float, y: float) -> Containment: ...
    @overload
    def Intersect(self, line: Line2) -> Node2: ...
    @overload
    def MakeIncreasing(self) -> None: ...
    @overload
    def ParameterAt(self, pt: Node2) -> Node2: ...
    @overload
    def ParameterAt(self, x: float, y: float) -> Node2: ...
    @overload
    def PointAt(self, x: float, y: float) -> Node2: ...
    @overload
    def ToString(self) -> str: ...


class Region2:
    @overload
    def __init__(self, nodes: Iterable[Node2]): ...
    @overload
    def Contains(self, node: Node2) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class SamplingRegion:
    @overload
    def __init__(self, regions: Iterable[Curve]): ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class Side2(Enum):
    Coincident = 0
    Right = 1
    Left = -1


class Vec2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Vec2): ...
    @overload
    def __init__(self, other: Vector2d): ...
    @overload
    def __init__(self, other: Vector2f): ...
    @overload
    def __init__(self, nX: float, nY: float): ...
    x: float
    y: float
    @overload
    def CompareTo(self, other: Vec2) -> int: ...
    @overload
    def CreatePerpendicular(self) -> Vec2: ...
    @overload
    def Duplicate(self) -> Vec2: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    @classmethod
    def Unit_X(cls) -> Vec2: ...
    @property
    @classmethod
    def Unit_Y(cls) -> Vec2: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Length(self) -> float: ...
    @overload
    def LengthSquared(self) -> float: ...
    @overload
    def __add__(A: Vec2, B: Vec2) -> Vec2: ...
    @overload
    def __mul__(V: Vec2, F: float) -> Vec2: ...
    @overload
    def __sub__(A: Vec2, B: Vec2) -> Vec2: ...
    @overload
    def ParallelTo(self, v: Vec2) -> Parallax: ...
    @overload
    def ParallelTo(self, v: Vec2, angle_tol: float) -> Parallax: ...
    @overload
    def PerpendicularTo(self, v: Vec2) -> bool: ...
    @overload
    def PerpendicularTo(self, v: Vec2, angle_tol: float) -> bool: ...
    @overload
    def Set(self, other: Vec2) -> None: ...
    @overload
    def Set(self, nX: float, nY: float) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Unitize(self) -> None: ...


class Vec3:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Vec3): ...
    @overload
    def __init__(self, other: Vector3d): ...
    @overload
    def __init__(self, other: Vector3f): ...
    @overload
    def __init__(self, nX: float, nY: float, nZ: float): ...
    x: float
    y: float
    z: float
    @overload
    def CompareTo(self, other: Vec3) -> int: ...
    @overload
    def CreatePerpendicular(self) -> Vec3: ...
    @overload
    @staticmethod
    def CrossProduct(A: Vec3, B: Vec3) -> Vec3: ...
    @overload
    @staticmethod
    def CrossProduct(ax: float, ay: float, az: float, bx: float, by: float, bz: float) -> Vec3: ...
    @overload
    def Duplicate(self) -> Vec3: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    @classmethod
    def Unit_X(cls) -> Vec3: ...
    @property
    @classmethod
    def Unit_Y(cls) -> Vec3: ...
    @property
    @classmethod
    def Unit_Z(cls) -> Vec3: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Length(self) -> float: ...
    @overload
    def LengthFlat(self) -> float: ...
    @overload
    def LengthSquared(self) -> float: ...
    @overload
    def LengthSquaredFlat(self) -> float: ...
    @overload
    def __add__(A: Vec3, B: Vec3) -> Vec3: ...
    @overload
    def __mul__(V: Vec3, F: float) -> Vec3: ...
    @overload
    def __mul__(A: Vec3, B: Vec3) -> float: ...
    @overload
    def __sub__(A: Vec3, B: Vec3) -> Vec3: ...
    @overload
    def ParallelTo(self, v: Vec3) -> Parallax: ...
    @overload
    def ParallelTo(self, v: Vec3, angle_tol: float) -> Parallax: ...
    @overload
    def PerpendicularTo(self, v: Vec3) -> bool: ...
    @overload
    def PerpendicularTo(self, v: Vec3, angle_tol: float) -> bool: ...
    @overload
    def Set(self, other: Vec3) -> None: ...
    @overload
    def Set(self, nX: float, nY: float, nZ: float) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Unitize(self) -> None: ...


class VorLeafRecursionResult(Enum):
    Continue = 0
    Abort = -1


class VorLeafRecursionResult(Enum):
    Continue = 0
    Abort = -1
