from typing import overload, Any, Iterable, Iterator, Sequence, MutableSequence, Callable
from enum import Enum



from Grasshopper.Kernel.Geometry import Node2
from Grasshopper.Kernel.Geometry import Line2
from Grasshopper.Kernel.Geometry import Side2
from Rhino.Geometry import Polyline
from Rhino.Geometry import PolyCurve
from System.Drawing.Drawing2D import GraphicsPath
class Cell2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, pt: Node2, Radius: float): ...
    @overload
    def __init__(self, pt: Node2, Contour: Iterable[Node2]): ...
    M: Node2
    C: List
    @overload
    def Edges(self) -> MutableSequence[Line2]: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Radius(self) -> float: ...
    @overload
    def Slice(self, other: Node2) -> bool: ...
    @overload
    def Slice(self, line: Line2) -> bool: ...
    @overload
    @staticmethod
    def SliceConvexNGon(V: MutableSequence[Node2], line: Line2, side: Side2, changed: bool) -> tuple[MutableSequence[Node2], bool]: ...
    @overload
    def ToGraphicsPath(self) -> GraphicsPath: ...
    @overload
    def ToPolyCurve(self, radius: float) -> PolyCurve: ...
    @overload
    def ToPolyline(self) -> Polyline: ...
    @overload
    def ToString(self) -> str: ...


from Rhino.Geometry import Point3d
from Rhino.Geometry import Box
from Rhino.Geometry import Plane
from Rhino.Geometry import Brep
class Cell3:
    @overload
    def __init__(self, other: Cell3): ...
    @overload
    def __init__(self, center: Point3d, box: Box): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def AngleTolerance(self) -> float: ...
    @property
    def BoundaryCount(self) -> int: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Facets(self) -> MutableSequence[Cell3Facet]: ...
    @property
    def Tolerance(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def MidPlane(A: Point3d, B: Point3d) -> Plane: ...
    @Tolerance.setter
    def Tolerance(self, Value: float) -> None: ...
    @overload
    def Slice(self, pt: Point3d) -> None: ...
    @overload
    def Slice(self, pt: Iterable[Point3d]) -> None: ...
    @overload
    def Slice(self, pt: Iterable[Point3d]) -> None: ...
    @overload
    def Slice(self, section: Plane) -> None: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToString(self) -> str: ...


from Rhino.Geometry import Point3d
from Rhino.Geometry import Line
from Rhino.Geometry import Vector3d
from Rhino.Geometry import Interval
from Rhino.Geometry import Polyline
from Rhino.Geometry import NurbsCurve
from Rhino.Geometry import PolylineCurve
from Rhino.Geometry import BoundingBox
from Rhino.Collections import XAccess
from Rhino.Collections import YAccess
from Rhino.Collections import ZAccess
from Rhino.Geometry import Transform
from Rhino.Collections import Point3dList
from System import Predicate
from Rhino.Collections import RhinoList
from System.Collections.Generic import IComparer
from System import Action
from System import Comparison
from System.Collections.ObjectModel import ReadOnlyCollection
from System import Converter
class Cell3Facet:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, pts: Iterable[Point3d]): ...
    @overload
    def __init__(self, other: Cell3Facet): ...
    def __iter__(self) -> Iterator[Point3d]: ...
    def __getitem__(self, index: int) -> Point3d: ...
    def __setitem__(self, index: int, value: Point3d): ...
    @overload
    def Add(self, item: Point3d) -> None: ...
    @overload
    def Add(self, x: float, y: float, z: float) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[Point3d]) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[Any]) -> None: ...
    @overload
    def AsReadOnly(self) -> ReadOnlyCollection: ...
    @overload
    def BinarySearch(self, item: Point3d) -> int: ...
    @overload
    def BinarySearch(self, item: Point3d, comparer: IComparer) -> int: ...
    @overload
    def BinarySearch(self, index: int, count: int, item: Point3d, comparer: IComparer) -> int: ...
    @overload
    def BreakAtAngles(self, angle: float) -> Iterable[Polyline]: ...
    @overload
    def CenterPoint(self) -> Point3d: ...
    @overload
    def CleanUp(self, tolerance: float, minDistance: float) -> tuple[float]: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def ClosestIndex(self, testPoint: Point3d) -> int: ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def CollapseShortSegments(self, tolerance: float) -> int: ...
    @overload
    def Contains(self, item: Point3d) -> bool: ...
    @overload
    def ConvertAll(self, converter: Converter) -> RhinoList: ...
    @overload
    def CopyTo(self, array: Iterable[Point3d]) -> None: ...
    @overload
    def CopyTo(self, array: Iterable[Point3d], arrayIndex: int) -> None: ...
    @overload
    def CopyTo(self, index: int, array: Iterable[Point3d], arrayIndex: int, count: int) -> None: ...
    @overload
    def DeleteShortSegments(self, tolerance: float) -> int: ...
    @overload
    def DestroyCaches(self) -> None: ...
    @overload
    def Duplicate(self) -> Polyline: ...
    @overload
    def Duplicate(self) -> Point3dList: ...
    @overload
    def Duplicate(self) -> RhinoList: ...
    @overload
    def Equals(self, other: Point3dList) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Exists(self, match: Predicate) -> bool: ...
    @overload
    def Find(self, match: Predicate) -> Point3d: ...
    @overload
    def FindAll(self, match: Predicate) -> RhinoList: ...
    @overload
    def FindIndex(self, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def FindLast(self, match: Predicate) -> Point3d: ...
    @overload
    def FindLastIndex(self, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def ForEach(self, action: Action) -> None: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Capacity(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def First(self) -> Point3d: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Last(self) -> Point3d: ...
    @property
    def Length(self) -> float: ...
    @property
    def MidPoint(self) -> Point3d: ...
    @property
    def NullCount(self) -> int: ...
    @property
    def Original(self) -> bool: ...
    @property
    def Radius(self) -> float: ...
    @property
    def SegmentCount(self) -> int: ...
    @property
    def X(self) -> XAccess: ...
    @property
    def Y(self) -> YAccess: ...
    @property
    def Z(self) -> ZAccess: ...
    @overload
    def GetEnumerator(self) -> Iterator[Point3d]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetRange(self, index: int, count: int) -> RhinoList: ...
    @overload
    def GetSegments(self) -> Iterable[Line]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IndexOf(self, item: Point3d) -> int: ...
    @overload
    def IndexOf(self, item: Point3d, index: int) -> int: ...
    @overload
    def IndexOf(self, item: Point3d, index: int, count: int) -> int: ...
    @overload
    def Insert(self, index: int, item: Point3d) -> None: ...
    @overload
    def InsertRange(self, index: int, collection: Iterable[Point3d]) -> None: ...
    @overload
    def IsClosedWithinTolerance(self, tolerance: float) -> bool: ...
    @overload
    def LastIndexOf(self, item: Point3d) -> int: ...
    @overload
    def LastIndexOf(self, item: Point3d, index: int) -> int: ...
    @overload
    def LastIndexOf(self, item: Point3d, index: int, count: int) -> int: ...
    @overload
    def MergeColinearSegments(self, angleTolerance: float, includeSeam: bool) -> int: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def ReduceSegments(self, tolerance: float) -> int: ...
    @overload
    def RemapIndex(self, index: int) -> int: ...
    @overload
    def Remove(self, item: Point3d) -> bool: ...
    @overload
    def RemoveAll(self, match: Predicate) -> int: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RemoveNearlyEqualSubsequentPoints(self, tolerance: float) -> None: ...
    @overload
    def RemoveNulls(self) -> int: ...
    @overload
    def RemoveRange(self, index: int, count: int) -> None: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    def Reverse(self, index: int, count: int) -> None: ...
    @overload
    def SegmentAt(self, index: int) -> Line: ...
    @Capacity.setter
    def Capacity(self, value: int) -> None: ...
    @First.setter
    def First(self, value: Point3d) -> None: ...
    @property
    def Item(self) -> MutableSequence[Point3d]: ...
    @Last.setter
    def Last(self, value: Point3d) -> None: ...
    @Original.setter
    def Original(self, Value: bool) -> None: ...
    @overload
    def SetAllX(self, xValue: float) -> None: ...
    @overload
    def SetAllY(self, yValue: float) -> None: ...
    @overload
    def SetAllZ(self, zValue: float) -> None: ...
    @overload
    def Smooth(self, amount: float) -> bool: ...
    @overload
    def Sort(self) -> None: ...
    @overload
    def Sort(self, keys: Iterable[float]) -> None: ...
    @overload
    def Sort(self, keys: Iterable[int]) -> None: ...
    @overload
    def Sort(self, comparison: Comparison) -> None: ...
    @overload
    def Sort(self, comparer: IComparer) -> None: ...
    @overload
    def Sort(self, index: int, count: int, comparer: IComparer) -> None: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArray(self) -> Iterable[Point3d]: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToPolylineCurve(self) -> PolylineCurve: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...
    @overload
    def TriangulateClosedPolyline(self) -> Iterable[MeshFace]: ...
    @overload
    def Trim(self, domain: Interval) -> Polyline: ...
    @overload
    def TrimExcess(self) -> None: ...
    @overload
    def TrueForAll(self, match: Predicate) -> bool: ...


from Grasshopper.Kernel.Geometry import Node2List
from Grasshopper.Kernel.Geometry.Delaunay import Connectivity
class Solver:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Solve_BruteForce(nodes: Node2List, outline: Iterable[Node2]) -> MutableSequence[Cell2]: ...
    @overload
    @staticmethod
    def Solve_Connectivity(nodes: Node2List, diagram: Connectivity, outline: Iterable[Node2]) -> MutableSequence[Cell2]: ...
    @overload
    def ToString(self) -> str: ...
