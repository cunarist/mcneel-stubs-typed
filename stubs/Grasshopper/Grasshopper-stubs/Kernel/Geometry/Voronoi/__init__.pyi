from typing import overload, Tuple, Iterable, Iterator, Sequence, MutableSequence
from enum import Enum



class Cell2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, pt: Node2, Radius: float): ...
    @overload
    def __init__(self, pt: Node2, Contour: Iterable[Node2]): ...
    @overload
    def Edges(self) -> List: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def Radius(self) -> float: ...
    @overload
    def Slice(self, other: Node2) -> bool: ...
    @overload
    def Slice(self, line: Line2) -> bool: ...
    @overload
    @staticmethod
    def SliceConvexNGon(V: List, line: Line2, side: Side2, changed: bool) -> Tuple[List, bool]: ...
    @overload
    def ToGraphicsPath(self) -> GraphicsPath: ...
    @overload
    def ToPolyCurve(self, radius: float) -> PolyCurve: ...
    @overload
    def ToPolyline(self) -> Polyline: ...
    @overload
    def ToString(self) -> str: ...


class Cell3:
    @overload
    def __init__(self, other: Cell3): ...
    @overload
    def __init__(self, center: Point3d, box: Box): ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def AngleTolerance(self) -> float: ...
    @overload
    @property
    def BoundaryCount(self) -> int: ...
    @overload
    @property
    def Center(self) -> Point3d: ...
    @overload
    @property
    def Facets(self) -> List: ...
    @overload
    @property
    def Tolerance(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    @staticmethod
    def MidPlane(A: Point3d, B: Point3d) -> Plane: ...
    @overload
    @Tolerance.setter
    def Tolerance(self) -> MutableSequence[float]: ...
    @overload
    def Slice(self, pt: Point3d) -> None: ...
    @overload
    def Slice(self, pt: Iterable[Point3d]) -> None: ...
    @overload
    def Slice(self, pt: Iterable[Point3d]) -> None: ...
    @overload
    def Slice(self, section: Plane) -> None: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToString(self) -> str: ...


class Cell3Facet:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, pts: Iterable[Point3d]): ...
    @overload
    def __init__(self, other: Cell3Facet): ...
    def __iter__(self) -> Iterator[Point3d]: ...
    def __getitem__(self, index: int) -> Point3d: ...
    def __setitem__(self, index: int, value: Point3d): ...
    @overload
    def Add(self, item: Point3d) -> None: ...
    @overload
    def Add(self, x: float, y: float, z: float) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[Point3d]) -> None: ...
    @overload
    def AddRange(self, collection: IEnumerable) -> None: ...
    @overload
    def AsReadOnly(self) -> ReadOnlyCollection: ...
    @overload
    def BinarySearch(self, item: Point3d) -> int: ...
    @overload
    def BinarySearch(self, item: Point3d, comparer: IComparer) -> int: ...
    @overload
    def BinarySearch(self, index: int, count: int, item: Point3d, comparer: IComparer) -> int: ...
    @overload
    def BreakAtAngles(self, angle: float) -> Iterable[Polyline]: ...
    @overload
    def CenterPoint(self) -> Point3d: ...
    @overload
    def CleanUp(self, tolerance: float, minDistance: float) -> Tuple[float]: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def ClosestIndex(self, testPoint: Point3d) -> int: ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def CollapseShortSegments(self, tolerance: float) -> int: ...
    @overload
    def Contains(self, item: Point3d) -> bool: ...
    @overload
    def ConvertAll(self, converter: Converter) -> RhinoList: ...
    @overload
    def CopyTo(self, array: Iterable[Point3d]) -> None: ...
    @overload
    def CopyTo(self, array: Iterable[Point3d], arrayIndex: int) -> None: ...
    @overload
    def CopyTo(self, index: int, array: Iterable[Point3d], arrayIndex: int, count: int) -> None: ...
    @overload
    def DeleteShortSegments(self, tolerance: float) -> int: ...
    @overload
    def DestroyCaches(self) -> None: ...
    @overload
    def Duplicate(self) -> Polyline: ...
    @overload
    def Duplicate(self) -> Point3dList: ...
    @overload
    def Duplicate(self) -> RhinoList: ...
    @overload
    def Equals(self, other: Point3dList) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Exists(self, match: Predicate) -> bool: ...
    @overload
    def Find(self, match: Predicate) -> Point3d: ...
    @overload
    def FindAll(self, match: Predicate) -> RhinoList: ...
    @overload
    def FindIndex(self, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def FindLast(self, match: Predicate) -> Point3d: ...
    @overload
    def FindLastIndex(self, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def ForEach(self, action: Action) -> None: ...
    @overload
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def First(self) -> Point3d: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    @property
    def Last(self) -> Point3d: ...
    @overload
    @property
    def Length(self) -> float: ...
    @overload
    @property
    def MidPoint(self) -> Point3d: ...
    @overload
    @property
    def NullCount(self) -> int: ...
    @overload
    @property
    def Original(self) -> bool: ...
    @overload
    @property
    def Radius(self) -> float: ...
    @overload
    @property
    def SegmentCount(self) -> int: ...
    @overload
    @property
    def X(self) -> XAccess: ...
    @overload
    @property
    def Y(self) -> YAccess: ...
    @overload
    @property
    def Z(self) -> ZAccess: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetRange(self, index: int, count: int) -> RhinoList: ...
    @overload
    def GetSegments(self) -> Iterable[Line]: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def IndexOf(self, item: Point3d) -> int: ...
    @overload
    def IndexOf(self, item: Point3d, index: int) -> int: ...
    @overload
    def IndexOf(self, item: Point3d, index: int, count: int) -> int: ...
    @overload
    def Insert(self, index: int, item: Point3d) -> None: ...
    @overload
    def InsertRange(self, index: int, collection: Iterable[Point3d]) -> None: ...
    @overload
    def IsClosedWithinTolerance(self, tolerance: float) -> bool: ...
    @overload
    def LastIndexOf(self, item: Point3d) -> int: ...
    @overload
    def LastIndexOf(self, item: Point3d, index: int) -> int: ...
    @overload
    def LastIndexOf(self, item: Point3d, index: int, count: int) -> int: ...
    @overload
    def MergeColinearSegments(self, angleTolerance: float, includeSeam: bool) -> int: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def ReduceSegments(self, tolerance: float) -> int: ...
    @overload
    def RemapIndex(self, index: int) -> int: ...
    @overload
    def Remove(self, item: Point3d) -> bool: ...
    @overload
    def RemoveAll(self, match: Predicate) -> int: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RemoveNearlyEqualSubsequentPoints(self, tolerance: float) -> None: ...
    @overload
    def RemoveNulls(self) -> int: ...
    @overload
    def RemoveRange(self, index: int, count: int) -> None: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    def Reverse(self, index: int, count: int) -> None: ...
    @overload
    def SegmentAt(self, index: int) -> Line: ...
    @overload
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @overload
    @First.setter
    def First(self) -> MutableSequence[Point3d]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    @Last.setter
    def Last(self) -> MutableSequence[Point3d]: ...
    @overload
    @Original.setter
    def Original(self) -> MutableSequence[bool]: ...
    @overload
    def SetAllX(self, xValue: float) -> None: ...
    @overload
    def SetAllY(self, yValue: float) -> None: ...
    @overload
    def SetAllZ(self, zValue: float) -> None: ...
    @overload
    def Smooth(self, amount: float) -> bool: ...
    @overload
    def Sort(self) -> None: ...
    @overload
    def Sort(self, keys: Iterable[float]) -> None: ...
    @overload
    def Sort(self, keys: Iterable[int]) -> None: ...
    @overload
    def Sort(self, comparison: Comparison) -> None: ...
    @overload
    def Sort(self, comparer: IComparer) -> None: ...
    @overload
    def Sort(self, index: int, count: int, comparer: IComparer) -> None: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArray(self) -> Iterable[Point3d]: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToPolylineCurve(self) -> PolylineCurve: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...
    @overload
    def TriangulateClosedPolyline(self) -> Iterable[MeshFace]: ...
    @overload
    def Trim(self, domain: Interval) -> Polyline: ...
    @overload
    def TrimExcess(self) -> None: ...
    @overload
    def TrueForAll(self, match: Predicate) -> bool: ...


from ..Delaunay import Connectivity
class Solver:
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    @staticmethod
    def Solve_BruteForce(nodes: Node2List, outline: Iterable[Node2]) -> List: ...
    @overload
    @staticmethod
    def Solve_Connectivity(nodes: Node2List, diagram: Connectivity, outline: Iterable[Node2]) -> List: ...
    @overload
    def ToString(self) -> str: ...
