from typing import overload, Any, Tuple, Iterable, Iterator, Sequence, MutableSequence
from enum import Enum



class Connectivity:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Count(self) -> int: ...
    @overload
    def GetConnections(self, node_index: int) -> List: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def SolveConnectivity(self, nodes: Node2List, faces: List, include_convex_hull_edges: bool) -> None: ...
    @overload
    def ToString(self) -> str: ...


class Edge:
    @overload
    def __init__(self, nA: int, nB: int, nN: int): ...
    A: int
    B: int
    N: int
    @overload
    def CompareTo(self, other: Edge) -> int: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class EdgeList:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, F: List): ...
    @overload
    def __init__(self, F: List): ...
    @overload
    def AddEdge(self, E: Edge) -> None: ...
    @overload
    def AddEdge(self, A: int, B: int) -> None: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def ContainsEdge(self, E: Edge) -> int: ...
    @overload
    def ContainsEdge(self, A: int, B: int) -> int: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Capacity(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def Edge(self) -> Sequence[Edge]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def RemoveEdge(self, E: Edge) -> bool: ...
    @overload
    def RemoveEdge(self, A: int, B: int) -> bool: ...
    @Capacity.setter
    def Capacity(self, Value: int) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def TrimHighValenceEdges(self) -> int: ...


class Face:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Face): ...
    @overload
    def __init__(self, nA: int, nB: int, nC: int): ...
    A: int
    B: int
    C: int
    @overload
    def ContainsEdge(self, E0: int, E1: int) -> bool: ...
    @overload
    def ContainsVertex(self, index: int) -> bool: ...
    @overload
    def Duplicate(self) -> Face: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Set(self, other: Face) -> None: ...
    @overload
    def Set(self, nA: int, nB: int, nC: int) -> None: ...
    @overload
    def ToString(self) -> str: ...


class FaceEx(Face):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Face): ...
    @overload
    def __init__(self, nA: int, nB: int, nC: int): ...
    center: Node2
    radius: float
    radius_squared: float
    A: int
    B: int
    C: int
    @overload
    def ComputeBC(self, Nodes: Node2List) -> None: ...
    @overload
    def ComputeBC(self, D: Node2, E: Node2, F: Node2) -> None: ...
    @overload
    def ContainsEdge(self, E0: int, E1: int) -> bool: ...
    @overload
    def ContainsInBoundingCircle(self, N: Node2) -> bool: ...
    @overload
    def ContainsInBoundingCircle(self, x: float, y: float) -> bool: ...
    @overload
    def ContainsVertex(self, index: int) -> bool: ...
    @overload
    def Duplicate(self) -> Face: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @property
    def Front(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Set(self, other: Face) -> None: ...
    @overload
    def Set(self, nA: int, nB: int, nC: int) -> None: ...
    @overload
    def ToString(self) -> str: ...


class FaceExList:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initial_capacity: int): ...
    @overload
    def AddFace(self, F: FaceEx) -> None: ...
    @overload
    def AddFace(self, A: int, B: int, C: int, Nodes: Node2List) -> None: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def CullFaces(self, x: float, y: float, F: List) -> int: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Capacity(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def InsertFaces(self, nodes: Node2List) -> None: ...
    @overload
    def MigrateRemainingFaces(self, static_list: List) -> None: ...
    @overload
    def MigrateStaticFaces(self, static_list: List, wave_front: float) -> int: ...
    @Capacity.setter
    def Capacity(self, Value: int) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def TrimNulls(self) -> int: ...


from Rhino.Geometry import Mesh
class Solver:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Solve_Connectivity(nodes: Node2List, jitter_amount: float, include_convex_hull_edges: bool) -> Connectivity: ...
    @overload
    @staticmethod
    def Solve_Faces(nodes: Node2List, jitter_amount: float) -> List: ...
    @overload
    @staticmethod
    def Solve_Mesh(nodes: Node2List, jitter_amount: float, faces: List) -> Tuple[Mesh, List]: ...
    @overload
    def ToString(self) -> str: ...
