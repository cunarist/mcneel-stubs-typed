from typing import overload, Any, Iterable, Iterator, Sequence, MutableSequence
from enum import Enum



from System import IntPtr
from System import AsyncCallback
from System import IAsyncResult
from System.Runtime.Serialization import SerializationInfo
from System.Runtime.Serialization import StreamingContext
from System.Reflection import MethodInfo
class FieldSolver:
    @overload
    def __init__(self, object: object, method: IntPtr): ...
    @overload
    def BeginInvoke(self, context: GH_Context, x: float, y: float, callback: AsyncCallback, object: object) -> IAsyncResult: ...
    @overload
    def Clone(self) -> object: ...
    @overload
    def DynamicInvoke(self, args: Iterable[object]) -> object: ...
    @overload
    def EndInvoke(self, result: IAsyncResult) -> float: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> object: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetInvocationList(self) -> Iterable[Delegate]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Invoke(self, context: GH_Context, x: float, y: float) -> float: ...
    @overload
    def ToString(self) -> str: ...


class GH_CellInfo:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, nX: int, nY: int): ...
    @overload
    def __init__(self, nX: int, nY: int, na: float, nb: float, nc: float, nd: float): ...
    x: int
    y: int
    va: float
    vb: float
    vc: float
    vd: float
    mask: GH_Mask
    edge_l: float
    edge_r: float
    edge_t: float
    edge_b: float
    @overload
    def DetermineMask(self, threshold: float) -> None: ...
    @overload
    def DetermineRealBox(self, accuracy: float) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


from GH_Util import GH_2DSparseArray
class GH_Context:
    @overload
    def __init__(self): ...
    @overload
    def AddParticle(self, particle_x: float, particle_y: float) -> None: ...
    @overload
    def AddParticle(self, particle_x: float, particle_y: float, particle_charge: float, particle_radius: float) -> None: ...
    @overload
    def AddParticle(self, particle_x: float, particle_y: float, particle_z: float, particle_charge: float, particle_radius: float) -> None: ...
    @overload
    def ClosestParticle(self, sample_x: float, sample_y: float) -> tuple[int, float]: ...
    @overload
    def ClosestParticle(self, sample_x: float, sample_y: float, sample_z: float) -> tuple[int, float]: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Accuracy(self) -> float: ...
    @property
    def Affinity(self) -> float: ...
    @property
    def ParticleCount(self) -> int: ...
    @property
    def SolverDelegate(self) -> FieldSolver: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def InverseSquareSolver(context: GH_Context, x: float, y: float) -> float: ...
    @overload
    def Particle(self, index: int) -> GH_Particle: ...
    @overload
    def Potential(self, x: float, y: float) -> float: ...
    @overload
    def RemoveParticle(self, index: int) -> None: ...
    @Accuracy.setter
    def Accuracy(self, value: float) -> None: ...
    @Affinity.setter
    def Affinity(self, value: float) -> None: ...
    @SolverDelegate.setter
    def SolverDelegate(self, value: FieldSolver) -> None: ...
    @overload
    @staticmethod
    def SineFallOffSolver(context: GH_Context, x: float, y: float) -> float: ...
    @overload
    def SolveIsoSurfaces(self, threshold: float) -> MutableSequence[GH_IsoSurface]: ...
    @overload
    def SolveIsoSurfaces(self, threshold: float) -> tuple[MutableSequence[GH_IsoSurface], GH_2DSparseArray]: ...
    @overload
    def ToString(self) -> str: ...


class GH_Direction(Enum):
    invalid = 0
    left = 1
    right = 2
    down = 3
    up = 4


from System.Collections.ObjectModel import ReadOnlyCollection
from System.Collections.Generic import IComparer
from System import Predicate
from System import Action
from System.Collections.Generic import Enumerator
from System import Comparison
from System import Converter
class GH_IsoSurface:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initial_capacity: int): ...
    def __iter__(self) -> Iterator[GH_Vertex]: ...
    def __getitem__(self, index: int) -> GH_Vertex: ...
    def __setitem__(self, index: int, value: GH_Vertex): ...
    @overload
    def Add(self, item: GH_Vertex) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[GH_Vertex]) -> None: ...
    @overload
    def AsReadOnly(self) -> ReadOnlyCollection: ...
    @overload
    def BinarySearch(self, item: GH_Vertex) -> int: ...
    @overload
    def BinarySearch(self, item: GH_Vertex, comparer: IComparer) -> int: ...
    @overload
    def BinarySearch(self, index: int, count: int, item: GH_Vertex, comparer: IComparer) -> int: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def Contains(self, item: GH_Vertex) -> bool: ...
    @overload
    def ConvertAll(self, converter: Converter) -> MutableSequence[TOutput]: ...
    @overload
    def CopyTo(self, array: Iterable[GH_Vertex]) -> None: ...
    @overload
    def CopyTo(self, array: Iterable[GH_Vertex], arrayIndex: int) -> None: ...
    @overload
    def CopyTo(self, index: int, array: Iterable[GH_Vertex], arrayIndex: int, count: int) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Exists(self, match: Predicate) -> bool: ...
    @overload
    def Find(self, match: Predicate) -> GH_Vertex: ...
    @overload
    def FindAll(self, match: Predicate) -> MutableSequence[GH_Vertex]: ...
    @overload
    def FindIndex(self, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def FindLast(self, match: Predicate) -> GH_Vertex: ...
    @overload
    def FindLastIndex(self, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def ForEach(self, action: Action) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsClosed(self) -> bool: ...
    @overload
    def GetEnumerator(self) -> Enumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetRange(self, index: int, count: int) -> MutableSequence[GH_Vertex]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IndexOf(self, item: GH_Vertex) -> int: ...
    @overload
    def IndexOf(self, item: GH_Vertex, index: int) -> int: ...
    @overload
    def IndexOf(self, item: GH_Vertex, index: int, count: int) -> int: ...
    @overload
    def Insert(self, index: int, item: GH_Vertex) -> None: ...
    @overload
    def InsertRange(self, index: int, collection: Iterable[GH_Vertex]) -> None: ...
    @overload
    def LastIndexOf(self, item: GH_Vertex) -> int: ...
    @overload
    def LastIndexOf(self, item: GH_Vertex, index: int) -> int: ...
    @overload
    def LastIndexOf(self, item: GH_Vertex, index: int, count: int) -> int: ...
    @overload
    def Remove(self, item: GH_Vertex) -> bool: ...
    @overload
    def RemoveAll(self, match: Predicate) -> int: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RemoveRange(self, index: int, count: int) -> None: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    def Reverse(self, index: int, count: int) -> None: ...
    @Capacity.setter
    def Capacity(self, value: int) -> None: ...
    @property
    def Item(self) -> MutableSequence[GH_Vertex]: ...
    @overload
    def Smooth(self) -> None: ...
    @overload
    def Sort(self) -> None: ...
    @overload
    def Sort(self, comparer: IComparer) -> None: ...
    @overload
    def Sort(self, comparison: Comparison) -> None: ...
    @overload
    def Sort(self, index: int, count: int, comparer: IComparer) -> None: ...
    @overload
    def ToArray(self) -> Iterable[GH_Vertex]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def TrimExcess(self) -> None: ...
    @overload
    def TrueForAll(self, match: Predicate) -> bool: ...


class GH_Mask(Enum):
    _0000 = 0
    _0001 = 1
    _0010 = 2
    _0011 = 3
    _0100 = 4
    _0101 = 5
    _0110 = 6
    _0111 = 7
    _1000 = 8
    _1001 = 9
    _1010 = 10
    _1011 = 11
    _1100 = 12
    _1101 = 13
    _1110 = 14
    _1111 = 15


class GH_Particle:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, nx: float, ny: float, nz: float, nc: float, nr: float): ...
    x: float
    y: float
    z: float
    c: float
    r: float
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


from System.Drawing import PointF
class GH_Vertex:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, pt: PointF): ...
    @overload
    def __init__(self, other: GH_Vertex): ...
    @overload
    def __init__(self, vx: float, vy: float): ...
    X: float
    Y: float
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def __eq__(A: GH_Vertex, B: GH_Vertex) -> bool: ...
    @overload
    def __ne__(A: GH_Vertex, B: GH_Vertex) -> bool: ...
    @overload
    def ToString(self) -> str: ...
