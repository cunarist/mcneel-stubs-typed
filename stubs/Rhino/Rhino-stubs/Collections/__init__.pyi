from typing import overload, Tuple, Iterable, Iterator, Sequence, MutableSequence
from enum import Enum



from ..DocObjects.Custom import UserData
from ..Geometry import Point3f
from ..Geometry import Point3d
from ..Geometry import Vector3d
from ..Geometry import Plane
from ..Geometry import Interval
from ..Geometry import Point2d
from ..Geometry import Point4d
from ..Geometry import Vector2d
from ..Geometry import BoundingBox
from ..Geometry import Ray3d
from ..Geometry import Transform
from ..Geometry import Line
from ..Geometry import Vector3f
from ..Geometry import MeshingParameters
from ..Geometry import GeometryBase
from ..DocObjects import ObjRef
class ArchivableDictionary:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, parentUserData: UserData): ...
    @overload
    def __init__(self, version: int): ...
    @overload
    def __init__(self, version: int, name: str): ...
    def __iter__(self) -> Iterator[KeyValuePair]: ...
    @overload
    def AddContentsFrom(self, source: ArchivableDictionary) -> bool: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def Clone(self) -> ArchivableDictionary: ...
    @overload
    def ContainsKey(self, key: str) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def ChangeSerialNumber(self) -> UInt32: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[str]: ...
    @overload
    @property
    def Keys(self) -> Iterable[str]: ...
    @overload
    @property
    def Name(self) -> str: ...
    @overload
    @property
    def ParentUserData(self) -> UserData: ...
    @overload
    @property
    def Values(self) -> Iterable[Object]: ...
    @overload
    @property
    def Version(self) -> int: ...
    @overload
    def GetBool(self, key: str) -> bool: ...
    @overload
    def GetBool(self, key: str, defaultValue: bool) -> bool: ...
    @overload
    def GetBytes(self, key: str) -> Iterable[Byte]: ...
    @overload
    def GetBytes(self, key: str, defaultValue: Iterable[Byte]) -> Iterable[Byte]: ...
    @overload
    def GetDictionary(self, key: str) -> ArchivableDictionary: ...
    @overload
    def GetDictionary(self, key: str, defaultValue: ArchivableDictionary) -> ArchivableDictionary: ...
    @overload
    def GetDouble(self, key: str) -> float: ...
    @overload
    def GetDouble(self, key: str, defaultValue: float) -> float: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetEnumValue(self) -> T: ...
    @overload
    def GetEnumValue(self, key: str) -> T: ...
    @overload
    def GetFloat(self, key: str) -> Single: ...
    @overload
    def GetFloat(self, key: str, defaultValue: Single) -> Single: ...
    @overload
    def GetGuid(self, key: str) -> Guid: ...
    @overload
    def GetGuid(self, key: str, defaultValue: Guid) -> Guid: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def Getint(self, key: str, defaultValue: int) -> int: ...
    @overload
    def GetInteger(self, key: str) -> int: ...
    @overload
    def GetInteger(self, key: str, defaultValue: int) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPlane(self, key: str) -> Plane: ...
    @overload
    def GetPlane(self, key: str, defaultValue: Plane) -> Plane: ...
    @overload
    def GetPoint3d(self, key: str) -> Point3d: ...
    @overload
    def GetPoint3d(self, key: str, defaultValue: Point3d) -> Point3d: ...
    @overload
    def GetPoint3f(self, key: str) -> Point3f: ...
    @overload
    def GetPoint3f(self, key: str, defaultValue: Point3f) -> Point3f: ...
    @overload
    def GetString(self, key: str) -> str: ...
    @overload
    def GetString(self, key: str, defaultValue: str) -> str: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def GetVector3d(self, key: str) -> Vector3d: ...
    @overload
    def GetVector3d(self, key: str, defaultValue: Vector3d) -> Vector3d: ...
    @overload
    def Remove(self, key: str) -> bool: ...
    @overload
    def RemoveEnumValue(self) -> bool: ...
    @overload
    def ReplaceContentsWith(self, source: ArchivableDictionary) -> bool: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[str]: ...
    @overload
    @Name.setter
    def Name(self) -> MutableSequence[str]: ...
    @overload
    def Set(self, key: str, val: Point) -> bool: ...
    @overload
    def Set(self, key: str, val: Iterable[float]) -> bool: ...
    @overload
    def Set(self, key: str, val: Iterable[Guid]) -> bool: ...
    @overload
    def Set(self, key: str, val: Iterable[str]) -> bool: ...
    @overload
    def Set(self, key: str, val: Color) -> bool: ...
    @overload
    def Set(self, key: str, val: ArchivableDictionary) -> bool: ...
    @overload
    def Set(self, key: str, val: PointF) -> bool: ...
    @overload
    def Set(self, key: str, val: Rectangle) -> bool: ...
    @overload
    def Set(self, key: str, val: RectangleF) -> bool: ...
    @overload
    def Set(self, key: str, val: Size) -> bool: ...
    @overload
    def Set(self, key: str, val: SizeF) -> bool: ...
    @overload
    def Set(self, key: str, val: Font) -> bool: ...
    @overload
    def Set(self, key: str, val: Point2d) -> bool: ...
    @overload
    def Set(self, key: str, val: Iterable[Single]) -> bool: ...
    @overload
    def Set(self, key: str, val: Point3d) -> bool: ...
    @overload
    def Set(self, key: str, val: Point4d) -> bool: ...
    @overload
    def Set(self, key: str, val: Vector2d) -> bool: ...
    @overload
    def Set(self, key: str, val: Vector3d) -> bool: ...
    @overload
    def Set(self, key: str, val: BoundingBox) -> bool: ...
    @overload
    def Set(self, key: str, val: Ray3d) -> bool: ...
    @overload
    def Set(self, key: str, val: Transform) -> bool: ...
    @overload
    def Set(self, key: str, val: Plane) -> bool: ...
    @overload
    def Set(self, key: str, val: Line) -> bool: ...
    @overload
    def Set(self, key: str, val: Interval) -> bool: ...
    @overload
    def Set(self, key: str, val: Iterable[int]) -> bool: ...
    @overload
    def Set(self, key: str, val: Iterable[SByte]) -> bool: ...
    @overload
    def Set(self, key: str, val: Point3f) -> bool: ...
    @overload
    def Set(self, key: str, val: Iterable[GeometryBase]) -> bool: ...
    @overload
    def Set(self, key: str, val: Iterable[ObjRef]) -> bool: ...
    @overload
    def Set(self, key: str, val: ObjRef) -> bool: ...
    @overload
    def Set(self, key: str, val: GeometryBase) -> bool: ...
    @overload
    def Set(self, key: str, val: MeshingParameters) -> bool: ...
    @overload
    def Set(self, key: str, val: bool) -> bool: ...
    @overload
    def Set(self, key: str, val: Byte) -> bool: ...
    @overload
    def Set(self, key: str, val: Iterable[Int16]) -> bool: ...
    @overload
    def Set(self, key: str, val: Int16) -> bool: ...
    @overload
    def Set(self, key: str, val: SByte) -> bool: ...
    @overload
    def Set(self, key: str, val: int) -> bool: ...
    @overload
    def Set(self, key: str, val: UInt32) -> bool: ...
    @overload
    def Set(self, key: str, val: Int64) -> bool: ...
    @overload
    def Set(self, key: str, val: Single) -> bool: ...
    @overload
    def Set(self, key: str, val: float) -> bool: ...
    @overload
    def Set(self, key: str, val: Guid) -> bool: ...
    @overload
    def Set(self, key: str, val: str) -> bool: ...
    @overload
    def Set(self, key: str, val: Iterable[bool]) -> bool: ...
    @overload
    def Set(self, key: str, val: Iterable[Byte]) -> bool: ...
    @overload
    def Set(self, key: str, val: UInt16) -> bool: ...
    @overload
    def Set(self, key: str, val: Vector3f) -> bool: ...
    @overload
    @Version.setter
    def Version(self) -> MutableSequence[int]: ...
    @overload
    def SetEnumValue(self, enumValue: T) -> bool: ...
    @overload
    def SetEnumValue(self, key: str, enumValue: T) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def TryGetBool(self, key: str) -> Tuple[bool, bool]: ...
    @overload
    def TryGetBytes(self, key: str) -> Tuple[bool, Iterable[Byte]]: ...
    @overload
    def TryGetDictionary(self, key: str) -> Tuple[bool, ArchivableDictionary]: ...
    @overload
    def TryGetDouble(self, key: str) -> Tuple[bool, float]: ...
    @overload
    def TryGetEnumValue(self, key: str) -> Tuple[bool, T]: ...
    @overload
    def TryGetFloat(self, key: str) -> Tuple[bool, Single]: ...
    @overload
    def TryGetGuid(self, key: str) -> Tuple[bool, Guid]: ...
    @overload
    def TryGetInteger(self, key: str) -> Tuple[bool, int]: ...
    @overload
    def TryGetPlane(self, key: str) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPoint3d(self, key: str) -> Tuple[bool, Point3d]: ...
    @overload
    def TryGetPoint3f(self, key: str) -> Tuple[bool, Point3f]: ...
    @overload
    def TryGetString(self, key: str) -> Tuple[bool, str]: ...
    @overload
    def TryGetValue(self, key: str) -> Tuple[bool, Object]: ...
    @overload
    def TryGetVector3d(self, key: str) -> Tuple[bool, Vector3d]: ...


from ..Geometry import Line
from ..Geometry import Circle
from ..Geometry import Arc
from ..Geometry import Ellipse
from ..Geometry import Transform
from ..Geometry import Curve
class CurveList:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initialCapacity: int): ...
    @overload
    def __init__(self, collection: Iterable[Curve]): ...
    def __iter__(self) -> Iterator[Curve]: ...
    def __getitem__(self, index: int) -> Curve: ...
    def __setitem__(self, index: int, value: Curve): ...
    @overload
    def Add(self, line: Line) -> None: ...
    @overload
    def Add(self, circle: Circle) -> None: ...
    @overload
    def Add(self, arc: Arc) -> None: ...
    @overload
    def Add(self, polyline: Iterable[Point3d]) -> None: ...
    @overload
    def Add(self, ellipse: Ellipse) -> None: ...
    @overload
    def Add(self, item: Curve) -> None: ...
    @overload
    def AddRange(self, collection: IEnumerable) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[Curve]) -> None: ...
    @overload
    def AsReadOnly(self) -> ReadOnlyCollection: ...
    @overload
    def BinarySearch(self, item: Curve) -> int: ...
    @overload
    def BinarySearch(self, item: Curve, comparer: IComparer) -> int: ...
    @overload
    def BinarySearch(self, index: int, count: int, item: Curve, comparer: IComparer) -> int: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def Contains(self, item: Curve) -> bool: ...
    @overload
    def ConvertAll(self, converter: Converter) -> RhinoList: ...
    @overload
    def CopyTo(self, array: Iterable[Curve]) -> None: ...
    @overload
    def CopyTo(self, array: Iterable[Curve], arrayIndex: int) -> None: ...
    @overload
    def CopyTo(self, index: int, array: Iterable[Curve], arrayIndex: int, count: int) -> None: ...
    @overload
    def Duplicate(self) -> RhinoList: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Exists(self, match: Predicate) -> bool: ...
    @overload
    def Find(self, match: Predicate) -> Curve: ...
    @overload
    def FindAll(self, match: Predicate) -> RhinoList: ...
    @overload
    def FindIndex(self, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def FindLast(self, match: Predicate) -> Curve: ...
    @overload
    def FindLastIndex(self, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def ForEach(self, action: Action) -> None: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def First(self) -> Curve: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    @property
    def Last(self) -> Curve: ...
    @overload
    @property
    def NullCount(self) -> int: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetRange(self, index: int, count: int) -> RhinoList: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def IndexOf(self, item: Curve) -> int: ...
    @overload
    def IndexOf(self, item: Curve, index: int) -> int: ...
    @overload
    def IndexOf(self, item: Curve, index: int, count: int) -> int: ...
    @overload
    def Insert(self, index: int, arc: Arc) -> None: ...
    @overload
    def Insert(self, index: int, circle: Circle) -> None: ...
    @overload
    def Insert(self, index: int, polyline: Iterable[Point3d]) -> None: ...
    @overload
    def Insert(self, index: int, ellipse: Ellipse) -> None: ...
    @overload
    def Insert(self, index: int, item: Curve) -> None: ...
    @overload
    def Insert(self, index: int, line: Line) -> None: ...
    @overload
    def InsertRange(self, index: int, collection: Iterable[Curve]) -> None: ...
    @overload
    def LastIndexOf(self, item: Curve) -> int: ...
    @overload
    def LastIndexOf(self, item: Curve, index: int) -> int: ...
    @overload
    def LastIndexOf(self, item: Curve, index: int, count: int) -> int: ...
    @overload
    def RemapIndex(self, index: int) -> int: ...
    @overload
    def Remove(self, item: Curve) -> bool: ...
    @overload
    def RemoveAll(self, match: Predicate) -> int: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RemoveNulls(self) -> int: ...
    @overload
    def RemoveRange(self, index: int, count: int) -> None: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    def Reverse(self, index: int, count: int) -> None: ...
    @overload
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @overload
    @First.setter
    def First(self) -> MutableSequence[Curve]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    @Last.setter
    def Last(self) -> MutableSequence[Curve]: ...
    @overload
    def Sort(self) -> None: ...
    @overload
    def Sort(self, comparison: Comparison) -> None: ...
    @overload
    def Sort(self, keys: Iterable[int]) -> None: ...
    @overload
    def Sort(self, keys: Iterable[float]) -> None: ...
    @overload
    def Sort(self, comparer: IComparer) -> None: ...
    @overload
    def Sort(self, index: int, count: int, comparer: IComparer) -> None: ...
    @overload
    def ToArray(self) -> Iterable[Curve]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def TrimExcess(self) -> None: ...
    @overload
    def TrueForAll(self, match: Predicate) -> bool: ...




from ..Geometry import BoundingBox
from ..Geometry import Point3d
from ..Geometry import Transform
class Point3dList:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initialCapacity: int): ...
    @overload
    def __init__(self, collection: Iterable[Point3d]): ...
    @overload
    def __init__(self, initialPoints: Iterable[Point3d]): ...
    def __iter__(self) -> Iterator[Point3d]: ...
    def __getitem__(self, index: int) -> Point3d: ...
    def __setitem__(self, index: int, value: Point3d): ...
    @overload
    def Add(self, item: Point3d) -> None: ...
    @overload
    def Add(self, x: float, y: float, z: float) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[Point3d]) -> None: ...
    @overload
    def AddRange(self, collection: IEnumerable) -> None: ...
    @overload
    def AsReadOnly(self) -> ReadOnlyCollection: ...
    @overload
    def BinarySearch(self, item: Point3d) -> int: ...
    @overload
    def BinarySearch(self, item: Point3d, comparer: IComparer) -> int: ...
    @overload
    def BinarySearch(self, index: int, count: int, item: Point3d, comparer: IComparer) -> int: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def ClosestIndex(self, testPoint: Point3d) -> int: ...
    @overload
    @staticmethod
    def ClosestIndexInList(list: Iterable[Point3d], testPoint: Point3d) -> int: ...
    @overload
    @staticmethod
    def ClosestPointInList(list: Iterable[Point3d], testPoint: Point3d) -> Point3d: ...
    @overload
    def Contains(self, item: Point3d) -> bool: ...
    @overload
    def ConvertAll(self, converter: Converter) -> RhinoList: ...
    @overload
    def CopyTo(self, array: Iterable[Point3d]) -> None: ...
    @overload
    def CopyTo(self, array: Iterable[Point3d], arrayIndex: int) -> None: ...
    @overload
    def CopyTo(self, index: int, array: Iterable[Point3d], arrayIndex: int, count: int) -> None: ...
    @overload
    def Duplicate(self) -> Point3dList: ...
    @overload
    def Duplicate(self) -> RhinoList: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, other: Point3dList) -> bool: ...
    @overload
    def Exists(self, match: Predicate) -> bool: ...
    @overload
    def Find(self, match: Predicate) -> Point3d: ...
    @overload
    def FindAll(self, match: Predicate) -> RhinoList: ...
    @overload
    def FindIndex(self, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def FindLast(self, match: Predicate) -> Point3d: ...
    @overload
    def FindLastIndex(self, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def ForEach(self, action: Action) -> None: ...
    @overload
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def First(self) -> Point3d: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    @property
    def Last(self) -> Point3d: ...
    @overload
    @property
    def NullCount(self) -> int: ...
    @overload
    @property
    def X(self) -> XAccess: ...
    @overload
    @property
    def Y(self) -> YAccess: ...
    @overload
    @property
    def Z(self) -> ZAccess: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetRange(self, index: int, count: int) -> RhinoList: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def IndexOf(self, item: Point3d) -> int: ...
    @overload
    def IndexOf(self, item: Point3d, index: int) -> int: ...
    @overload
    def IndexOf(self, item: Point3d, index: int, count: int) -> int: ...
    @overload
    def Insert(self, index: int, item: Point3d) -> None: ...
    @overload
    def InsertRange(self, index: int, collection: Iterable[Point3d]) -> None: ...
    @overload
    def LastIndexOf(self, item: Point3d) -> int: ...
    @overload
    def LastIndexOf(self, item: Point3d, index: int) -> int: ...
    @overload
    def LastIndexOf(self, item: Point3d, index: int, count: int) -> int: ...
    @overload
    def RemapIndex(self, index: int) -> int: ...
    @overload
    def Remove(self, item: Point3d) -> bool: ...
    @overload
    def RemoveAll(self, match: Predicate) -> int: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RemoveNulls(self) -> int: ...
    @overload
    def RemoveRange(self, index: int, count: int) -> None: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    def Reverse(self, index: int, count: int) -> None: ...
    @overload
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @overload
    @First.setter
    def First(self) -> MutableSequence[Point3d]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    @Last.setter
    def Last(self) -> MutableSequence[Point3d]: ...
    @overload
    def SetAllX(self, xValue: float) -> None: ...
    @overload
    def SetAllY(self, yValue: float) -> None: ...
    @overload
    def SetAllZ(self, zValue: float) -> None: ...
    @overload
    def Sort(self) -> None: ...
    @overload
    def Sort(self, keys: Iterable[float]) -> None: ...
    @overload
    def Sort(self, keys: Iterable[int]) -> None: ...
    @overload
    def Sort(self, comparer: IComparer) -> None: ...
    @overload
    def Sort(self, comparison: Comparison) -> None: ...
    @overload
    def Sort(self, index: int, count: int, comparer: IComparer) -> None: ...
    @overload
    def ToArray(self) -> Iterable[Point3d]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...
    @overload
    def TrimExcess(self) -> None: ...
    @overload
    def TrueForAll(self, match: Predicate) -> bool: ...


from ..Geometry import PointCloud
class RhinoList:
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    @staticmethod
    def Point2dKNeighbors(hayPoints: Iterable[Point2d], needlePoints: Iterable[Point2d], amount: int) -> Iterable[Iterable[int]]: ...
    @overload
    @staticmethod
    def Point2fKNeighbors(hayPoints: Iterable[Point2f], needlePoints: Iterable[Point2f], amount: int) -> Iterable[Iterable[int]]: ...
    @overload
    @staticmethod
    def Point3dKNeighbors(hayPoints: Iterable[Point3d], needlePoints: Iterable[Point3d], amount: int) -> Iterable[Iterable[int]]: ...
    @overload
    @staticmethod
    def Point3fKNeighbors(hayPoints: Iterable[Point3f], needlePoints: Iterable[Point3f], amount: int) -> Iterable[Iterable[int]]: ...
    @overload
    @staticmethod
    def PointCloudKNeighbors(pointcloud: PointCloud, needlePoints: Iterable[Point3d], amount: int) -> Iterable[Iterable[int]]: ...
    @overload
    def ToString(self) -> str: ...




from ..Geometry import BoundingBox
from ..Geometry import Transform
from ..DocObjects import RhinoObject
from ..DocObjects import ObjRef
from ..Input.Custom import GetObject
class TransformObjectList:
    @overload
    def __init__(self): ...
    @overload
    def Add(self, rhinoObject: RhinoObject) -> None: ...
    @overload
    def Add(self, objref: ObjRef) -> None: ...
    @overload
    def AddObjects(self, go: GetObject, allowGrips: bool) -> int: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def DisplayFeedbackEnabled(self) -> bool: ...
    @overload
    @property
    def GripCount(self) -> int: ...
    @overload
    @property
    def GripOwnerCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, regularObjects: bool, grips: bool) -> BoundingBox: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def GripArray(self) -> Iterable[GripObject]: ...
    @overload
    def GripOwnerArray(self) -> Iterable[RhinoObject]: ...
    @overload
    def ObjectArray(self) -> Iterable[RhinoObject]: ...
    @overload
    @DisplayFeedbackEnabled.setter
    def DisplayFeedbackEnabled(self) -> MutableSequence[bool]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def UpdateDisplayFeedbackTransform(self, xform: Transform) -> bool: ...


class XAccess:
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def ToString(self) -> str: ...


class YAccess:
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def ToString(self) -> str: ...


class ZAccess:
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def ToString(self) -> str: ...
