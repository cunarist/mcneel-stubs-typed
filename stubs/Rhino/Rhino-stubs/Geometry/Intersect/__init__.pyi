from typing import overload, Tuple, Iterable, Iterator, Sequence, MutableSequence
from enum import Enum



class ArcArcIntersection(Enum):
    # None = 0
    Single = 1
    Multiple = 2
    Overlap = 3


class CircleCircleIntersection(Enum):
    # None = 0
    Single = 1
    Multiple = 2
    Overlap = 3


class CurveIntersections:
    def __iter__(self) -> Iterator[IntersectionEvent]: ...
    def __getitem__(self, index: int) -> IntersectionEvent: ...
    def __setitem__(self, index: int, value: IntersectionEvent): ...
    @overload
    def CopyTo(self, array: Iterable[IntersectionEvent], arrayIndex: int) -> None: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[IntersectionEvent]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


from ...FileIO import TextLog
class Intersection:
    @overload
    @staticmethod
    def ArcArc(arcA: Arc, arcB: Arc) -> Tuple[ArcArcIntersection, Point3d, Point3d]: ...
    @overload
    @staticmethod
    def BrepBrep(brepA: Brep, brepB: Brep, tolerance: float) -> Tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def BrepBrep(brepA: Brep, brepB: Brep, tolerance: float, joinCurves: bool) -> Tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def BrepPlane(brep: Brep, plane: Plane, tolerance: float) -> Tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def BrepSurface(brep: Brep, surface: Surface, tolerance: float) -> Tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def BrepSurface(brep: Brep, surface: Surface, tolerance: float, joinCurves: bool) -> Tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def CircleCircle(circleA: Circle, circleB: Circle) -> Tuple[CircleCircleIntersection, Point3d, Point3d]: ...
    @overload
    @staticmethod
    def CurveBrep(curve: Curve, brep: Brep, tolerance: float) -> Tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def CurveBrep(curve: Curve, brep: Brep, tolerance: float, angleTolerance: float) -> Tuple[bool, Iterable[float]]: ...
    @overload
    @staticmethod
    def CurveBrep(curve: Curve, brep: Brep, tolerance: float) -> Tuple[bool, Iterable[Curve], Iterable[Point3d], Iterable[float]]: ...
    @overload
    @staticmethod
    def CurveBrepFace(curve: Curve, face: BrepFace, tolerance: float) -> Tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def CurveCurve(curveA: Curve, curveB: Curve, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurveCurveValidate(curveA: Curve, curveB: Curve, tolerance: float, overlapTolerance: float) -> Tuple[CurveIntersections, Iterable[int], TextLog]: ...
    @overload
    @staticmethod
    def CurveLine(curve: Curve, line: Line, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurvePlane(curve: Curve, plane: Plane, tolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurveSelf(curve: Curve, tolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurveSurface(curve: Curve, surface: Surface, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurveSurface(curve: Curve, curveDomain: Interval, surface: Surface, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurveSurfaceValidate(curve: Curve, surface: Surface, tolerance: float, overlapTolerance: float) -> Tuple[CurveIntersections, Iterable[int], TextLog]: ...
    @overload
    @staticmethod
    def CurveSurfaceValidate(curve: Curve, curveDomain: Interval, surface: Surface, tolerance: float, overlapTolerance: float) -> Tuple[CurveIntersections, Iterable[int], TextLog]: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def MeshIntersectionsTolerancesCoefficient() -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def LineBox(line: Line, box: BoundingBox, tolerance: float) -> Tuple[bool, Interval]: ...
    @overload
    @staticmethod
    def LineBox(line: Line, box: Box, tolerance: float) -> Tuple[bool, Interval]: ...
    @overload
    @staticmethod
    def LineCircle(line: Line, circle: Circle) -> Tuple[LineCircleIntersection, float, Point3d, float, Point3d]: ...
    @overload
    @staticmethod
    def LineCylinder(line: Line, cylinder: Cylinder) -> Tuple[LineCylinderIntersection, Point3d, Point3d]: ...
    @overload
    @staticmethod
    def LineLine(lineA: Line, lineB: Line) -> Tuple[bool, float, float]: ...
    @overload
    @staticmethod
    def LineLine(lineA: Line, lineB: Line, tolerance: float, finiteSegments: bool) -> Tuple[bool, float, float]: ...
    @overload
    @staticmethod
    def LinePlane(line: Line, plane: Plane) -> Tuple[bool, float]: ...
    @overload
    @staticmethod
    def LineSphere(line: Line, sphere: Sphere) -> Tuple[LineSphereIntersection, Point3d, Point3d]: ...
    @overload
    @staticmethod
    def MeshLine(mesh: Mesh, line: Line) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def MeshLine(mesh: Mesh, line: Line) -> Tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def MeshLineSorted(mesh: Mesh, line: Line) -> Tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def MeshMesh(meshes: Iterable[Mesh], tolerance: float, overlapsPolylines: bool, overlapsMesh: bool, textLog: TextLog, cancel: CancellationToken, progress: IProgress) -> Tuple[bool, Iterable[Polyline], Iterable[Polyline], Mesh]: ...
    @overload
    @staticmethod
    def MeshMeshAccurate(meshA: Mesh, meshB: Mesh, tolerance: float) -> Iterable[Polyline]: ...
    @overload
    @staticmethod
    def MeshMeshFast(meshA: Mesh, meshB: Mesh) -> Iterable[Line]: ...
    @overload
    @staticmethod
    def MeshMeshPredicate(meshes: Iterable[Mesh], tolerance: float, textLog: TextLog) -> Tuple[bool, Iterable[int]]: ...
    @overload
    @staticmethod
    def MeshPlane(mesh: Mesh, planes: Iterable[Plane]) -> Iterable[Polyline]: ...
    @overload
    @staticmethod
    def MeshPlane(mesh: Mesh, plane: Plane) -> Iterable[Polyline]: ...
    @overload
    @staticmethod
    def MeshPlane(mesh: Mesh, cache: MeshIntersectionCache, plane: Plane, tolerance: float) -> Iterable[Polyline]: ...
    @overload
    @staticmethod
    def MeshPlane(mesh: Mesh, cache: MeshIntersectionCache, planes: Iterable[Plane], tolerance: float) -> Iterable[Polyline]: ...
    @overload
    @staticmethod
    def MeshPolyline(mesh: Mesh, curve: PolylineCurve) -> Tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def MeshPolylineSorted(mesh: Mesh, curve: PolylineCurve) -> Tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def MeshRay(mesh: Mesh, ray: Ray3d) -> float: ...
    @overload
    @staticmethod
    def MeshRay(mesh: Mesh, ray: Ray3d) -> Tuple[float, Iterable[int]]: ...
    @overload
    @staticmethod
    def PlaneBoundingBox(plane: Plane, boundingBox: BoundingBox) -> Tuple[bool, Polyline]: ...
    @overload
    @staticmethod
    def PlaneCircle(plane: Plane, circle: Circle) -> Tuple[PlaneCircleIntersection, float, float]: ...
    @overload
    @staticmethod
    def PlanePlane(planeA: Plane, planeB: Plane) -> Tuple[bool, Line]: ...
    @overload
    @staticmethod
    def PlanePlanePlane(planeA: Plane, planeB: Plane, planeC: Plane) -> Tuple[bool, Point3d]: ...
    @overload
    @staticmethod
    def PlaneSphere(plane: Plane, sphere: Sphere) -> Tuple[PlaneSphereIntersection, Circle]: ...
    @overload
    @staticmethod
    def ProjectPointsToBreps(breps: Iterable[Brep], points: Iterable[Point3d], direction: Vector3d, tolerance: float) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def ProjectPointsToBrepsEx(breps: Iterable[Brep], points: Iterable[Point3d], direction: Vector3d, tolerance: float) -> Tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def ProjectPointsToMeshes(meshes: Iterable[Mesh], points: Iterable[Point3d], direction: Vector3d, tolerance: float) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def ProjectPointsToMeshesEx(meshes: Iterable[Mesh], points: Iterable[Point3d], direction: Vector3d, tolerance: float) -> Tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def RayShoot(ray: Ray3d, geometry: Iterable[GeometryBase], maxReflections: int) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def RayShoot(geometry: Iterable[GeometryBase], ray: Ray3d, maxReflections: int) -> Iterable[RayShootEvent]: ...
    @overload
    @staticmethod
    def SphereSphere(sphereA: Sphere, sphereB: Sphere) -> Tuple[SphereSphereIntersection, Circle]: ...
    @overload
    @staticmethod
    def SurfaceSurface(surfaceA: Surface, surfaceB: Surface, tolerance: float) -> Tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    def ToString(self) -> str: ...


from ...FileIO import TextLog
class IntersectionEvent:
    @overload
    def __init__(self): ...
    @overload
    @staticmethod
    def CompareEquivalent(eventA: IntersectionEvent, eventB: IntersectionEvent, relativePointTolerance: float) -> bool: ...
    @overload
    @staticmethod
    def CompareEquivalent(eventA: IntersectionEvent, eventB: IntersectionEvent, relativePointTolerance: float, log: TextLog) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def IsOverlap(self) -> bool: ...
    @overload
    @property
    def IsPoint(self) -> bool: ...
    @overload
    @property
    def OverlapA(self) -> Interval: ...
    @overload
    @property
    def OverlapB(self) -> Interval: ...
    @overload
    @property
    def ParameterA(self) -> float: ...
    @overload
    @property
    def ParameterB(self) -> float: ...
    @overload
    @property
    def PointA(self) -> Point3d: ...
    @overload
    @property
    def PointA2(self) -> Point3d: ...
    @overload
    @property
    def PointB(self) -> Point3d: ...
    @overload
    @property
    def PointB2(self) -> Point3d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def SurfaceOverlapParameter(self) -> Tuple[Interval, Interval]: ...
    @overload
    def SurfacePointParameter(self) -> Tuple[float, float]: ...
    @overload
    def ToString(self) -> str: ...


class LineCircleIntersection(Enum):
    # None = 0
    Single = 1
    Multiple = 2


class LineCylinderIntersection(Enum):
    # None = 0
    Single = 1
    Multiple = 2
    Overlap = 3


class LineSphereIntersection(Enum):
    # None = 0
    Single = 1
    Multiple = 2


from ...DocObjects import RhinoObject
class MeshClash:
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @staticmethod
    def FindDetail(objA: RhinoObject, objB: RhinoObject, distance: float) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def FindDetail(objA: RhinoObject, objB: RhinoObject, distance: float, meshType: MeshType, meshingParameters: MeshingParameters) -> Iterable[Mesh]: ...
    @overload
    @property
    def ClashPoint(self) -> Point3d: ...
    @overload
    @property
    def ClashRadius(self) -> float: ...
    @overload
    @property
    def MeshA(self) -> Mesh: ...
    @overload
    @property
    def MeshB(self) -> Mesh: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Search(setA: Iterable[RhinoObject], setB: Iterable[RhinoObject], distance: float) -> Iterable[MeshInterference]: ...
    @overload
    @staticmethod
    def Search(setA: Iterable[Mesh], setB: Iterable[Mesh], distance: float, maxEventCount: int) -> Iterable[MeshClash]: ...
    @overload
    @staticmethod
    def Search(meshA: Mesh, setB: Iterable[Mesh], distance: float, maxEventCount: int) -> Iterable[MeshClash]: ...
    @overload
    @staticmethod
    def Search(meshA: Mesh, meshB: Mesh, distance: float, maxEventCount: int) -> Iterable[MeshClash]: ...
    @overload
    @staticmethod
    def Search(setA: Iterable[RhinoObject], setB: Iterable[RhinoObject], distance: float, meshType: MeshType, meshingParameters: MeshingParameters) -> Iterable[MeshInterference]: ...
    @overload
    def ToString(self) -> str: ...


class MeshInterference:
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def HitPoints(self) -> Iterable[Point3d]: ...
    @overload
    @property
    def IndexA(self) -> int: ...
    @overload
    @property
    def IndexB(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @HitPoints.setter
    def HitPoints(self, value: Iterable[Point3d]) -> None: ...
    @overload
    @IndexA.setter
    def IndexA(self, value: int) -> None: ...
    @overload
    @IndexB.setter
    def IndexB(self, value: int) -> None: ...
    @overload
    def ToString(self) -> str: ...


class MeshIntersectionCache:
    @overload
    def __init__(self): ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class PlaneCircleIntersection(Enum):
    # None = 0
    Tangent = 1
    Secant = 2
    Parallel = 3
    Coincident = 4


class PlaneSphereIntersection(Enum):
    # None = 0
    Point = 1
    Circle = 2


class RayShootEvent:
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def BrepFaceIndex(self) -> int: ...
    @overload
    @property
    def GeometryIndex(self) -> int: ...
    @overload
    @property
    def Point(self) -> Point3d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @BrepFaceIndex.setter
    def BrepFaceIndex(self, value: int) -> None: ...
    @overload
    @GeometryIndex.setter
    def GeometryIndex(self, value: int) -> None: ...
    @overload
    @Point.setter
    def Point(self, value: Point3d) -> None: ...
    @overload
    def ToString(self) -> str: ...


class SphereSphereIntersection(Enum):
    # None = 0
    Point = 1
    Circle = 2
    Overlap = 3
