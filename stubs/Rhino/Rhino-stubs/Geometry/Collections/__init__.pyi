from typing import overload, Tuple, Iterable, Iterator, Sequence, MutableSequence
from enum import Enum



class BrepCurveList:
    def __iter__(self) -> Iterator[Curve]: ...
    @overload
    def Add(self, curve: Curve) -> int: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def ToString(self) -> str: ...


class BrepEdgeList:
    def __iter__(self) -> Iterator[BrepEdge]: ...
    @overload
    def Add(self, curve3dIndex: int) -> BrepEdge: ...
    @overload
    def Add(self, startVertexIndex: int, endVertexIndex: int, curve3dIndex: int, edgeTolerance: float) -> BrepEdge: ...
    @overload
    def Add(self, startVertex: BrepVertex, endVertex: BrepVertex, curve3dIndex: int, edgeTolerance: float) -> BrepEdge: ...
    @overload
    def Add(self, startVertexIndex: int, endVertexIndex: int, curve3dIndex: int, subDomain: Interval, edgeTolerance: float) -> BrepEdge: ...
    @overload
    def Add(self, startVertex: BrepVertex, endVertex: BrepVertex, curve3dIndex: int, subDomain: Interval, edgeTolerance: float) -> BrepEdge: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def MergeAllEdges(self, angleTolerance: float) -> int: ...
    @overload
    def MergeEdge(self, edgeIndex: int, angleTolerance: float) -> int: ...
    @overload
    def RemoveNakedMicroEdges(self, tolerance: float) -> int: ...
    @overload
    def RemoveNakedMicroEdges(self, tolerance: float, cleanUp: bool) -> int: ...
    @overload
    def SplitEdgeAtParameters(self, edgeIndex: int, edgeParameters: Iterable[float]) -> int: ...
    @overload
    def SplitKinkyEdge(self, edgeIndex: int, kinkToleranceRadians: float) -> bool: ...
    @overload
    def ToString(self) -> str: ...


class BrepFaceList:
    def __iter__(self) -> Iterator[BrepFace]: ...
    @overload
    def Add(self, surface: Surface) -> BrepFace: ...
    @overload
    def Add(self, surfaceIndex: int) -> BrepFace: ...
    @overload
    def AddConeFace(self, vertex: BrepVertex, edge: BrepEdge, revEdge: bool) -> BrepFace: ...
    @overload
    def AddRuledFace(self, edgeA: BrepEdge, revEdgeA: bool, edgeB: BrepEdge, revEdgeB: bool) -> BrepFace: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def ExtractFace(self, faceIndex: int) -> Brep: ...
    @overload
    def Flip(self, onlyReversedFaces: bool) -> None: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def RemoveAt(self, faceIndex: int) -> None: ...
    @overload
    def RemoveSlits(self) -> bool: ...
    @overload
    def ShrinkFaces(self) -> bool: ...
    @overload
    def SplitBipolarFaces(self) -> bool: ...
    @overload
    def SplitClosedFaces(self, minimumDegree: int) -> bool: ...
    @overload
    def SplitFaceAtTangents(self, faceIndex: int) -> bool: ...
    @overload
    def SplitFacesAtTangents(self) -> bool: ...
    @overload
    def SplitKinkyFace(self, faceIndex: int, kinkTolerance: float) -> bool: ...
    @overload
    def SplitKinkyFaces(self) -> bool: ...
    @overload
    def SplitKinkyFaces(self, kinkTolerance: float) -> bool: ...
    @overload
    def SplitKinkyFaces(self, kinkTolerance: float, compact: bool) -> bool: ...
    @overload
    def StandardizeFaceSurface(self, faceIndex: int) -> bool: ...
    @overload
    def StandardizeFaceSurfaces(self) -> None: ...
    @overload
    def ToString(self) -> str: ...


class BrepLoopList:
    def __iter__(self) -> Iterator[BrepLoop]: ...
    @overload
    def Add(self, loopType: BrepLoopType) -> BrepLoop: ...
    @overload
    def Add(self, loopType: BrepLoopType, face: BrepFace) -> BrepLoop: ...
    @overload
    def AddOuterLoop(self, faceIndex: int) -> BrepLoop: ...
    @overload
    def AddPlanarFaceLoop(self, faceIndex: int, loopType: BrepLoopType, boundaryCurves: Iterable[Curve]) -> BrepLoop: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def ToString(self) -> str: ...


class BrepSurfaceList:
    def __iter__(self) -> Iterator[Surface]: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def ToString(self) -> str: ...


class BrepTrimList:
    def __iter__(self) -> Iterator[BrepTrim]: ...
    @overload
    def Add(self, curve2dIndex: int) -> BrepTrim: ...
    @overload
    def Add(self, rev3d: bool, loop: BrepLoop, curve2dIndex: int) -> BrepTrim: ...
    @overload
    def Add(self, rev3d: bool, edge: BrepEdge, curve2dIndex: int) -> BrepTrim: ...
    @overload
    def Add(self, edge: BrepEdge, rev3d: bool, loop: BrepLoop, curve2dIndex: int) -> BrepTrim: ...
    @overload
    def AddCurveOnFace(self, face: BrepFace, edge: BrepEdge, rev3d: bool, curve2dIndex: int) -> BrepTrim: ...
    @overload
    def AddSingularTrim(self, vertex: BrepVertex, loop: BrepLoop, iso: IsoStatus, curve2dIndex: int) -> BrepTrim: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def MatchEnds(self) -> bool: ...
    @overload
    def MatchEnds(self, trimIndex: int) -> bool: ...
    @overload
    def MatchEnds(self, loop: BrepLoop) -> bool: ...
    @overload
    def MatchEnds(self, trim0: BrepTrim, trim1: BrepTrim) -> bool: ...
    @overload
    def ToString(self) -> str: ...


class BrepVertexList:
    def __iter__(self) -> Iterator[BrepVertex]: ...
    @overload
    def Add(self) -> BrepVertex: ...
    @overload
    def Add(self, point: Point3d, vertexTolerance: float) -> BrepVertex: ...
    @overload
    def AddPointOnFace(self, face: BrepFace, s: float, t: float) -> BrepVertex: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def ToString(self) -> str: ...


class MeshFaceList:
    def __iter__(self) -> Iterator[MeshFace]: ...
    def __getitem__(self, index: int) -> MeshFace: ...
    def __setitem__(self, index: int, value: MeshFace): ...
    @overload
    def AddFace(self, face: MeshFace) -> int: ...
    @overload
    def AddFace(self, vertex1: int, vertex2: int, vertex3: int) -> int: ...
    @overload
    def AddFace(self, vertex1: int, vertex2: int, vertex3: int, vertex4: int) -> int: ...
    @overload
    def AddFaces(self, faces: Iterable[MeshFace]) -> Iterable[int]: ...
    @overload
    def AdjacentFaces(self, faceIndex: int) -> Iterable[int]: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def ConvertNonPlanarQuadsToTriangles(self, planarTolerance: float, angleToleranceRadians: float, splitMethod: int) -> int: ...
    @overload
    def ConvertQuadsToTriangles(self) -> bool: ...
    @overload
    def ConvertTrianglesToQuads(self, angleToleranceRadians: float, minimumDiagonalLengthRatio: float) -> bool: ...
    @overload
    def CullDegenerateFaces(self) -> int: ...
    @overload
    def DeleteFaces(self, faceIndexes: Iterable[int]) -> int: ...
    @overload
    def DeleteFaces(self, faceIndexes: Iterable[int], compact: bool) -> int: ...
    @overload
    def Destroy(self) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def ExtractDuplicateFaces(self) -> Mesh: ...
    @overload
    def ExtractFaces(self, faceIndices: Iterable[int]) -> Mesh: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    @property
    def QuadCount(self) -> int: ...
    @overload
    @property
    def TriangleCount(self) -> int: ...
    @overload
    def GetClashingFacePairs(self, maxPairCount: int) -> Iterable[IndexPair]: ...
    @overload
    def GetConnectedFaces(self, faceIndex: int) -> Iterable[int]: ...
    @overload
    def GetConnectedFaces(self, faceIndex: int, angleRadians: float, greaterThanAngle: bool) -> Iterable[int]: ...
    @overload
    def GetConnectedFacesToEdges(self, startFaceIndex: int, treatNonmanifoldLikeUnwelded: bool) -> Iterable[int]: ...
    @overload
    def GetDuplicateFaces(self) -> Iterable[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetFace(self, index: int) -> MeshFace: ...
    @overload
    def GetFaceAspectRatio(self, index: int) -> float: ...
    @overload
    def GetFaceBoundingBox(self, faceIndex: int) -> BoundingBox: ...
    @overload
    def GetFaceCenter(self, faceIndex: int) -> Point3d: ...
    @overload
    def GetFaceVertices(self, faceIndex: int) -> Tuple[bool, Point3f, Point3f, Point3f, Point3f]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetTopologicalVertices(self, faceIndex: int) -> Iterable[int]: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def GetZeroAreaFaces(self) -> Tuple[bool, Iterable[int], Iterable[int]]: ...
    @overload
    def HasNakedEdges(self, faceIndex: int) -> bool: ...
    @overload
    def Insert(self, index: int, face: MeshFace) -> None: ...
    @overload
    def IsHidden(self, faceIndex: int) -> bool: ...
    @overload
    def MergeAdjacentFaces(self, edgeIndex: int) -> bool: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RemoveAt(self, index: int, compact: bool) -> None: ...
    @overload
    def RemoveZeroAreaFaces(self, fixedFaceCount: int) -> Tuple[int, int]: ...
    @overload
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @overload
    @Count.setter
    def Count(self) -> MutableSequence[int]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def SetFace(self, index: int, face: MeshFace) -> bool: ...
    @overload
    def SetFace(self, index: int, vertex1: int, vertex2: int, vertex3: int) -> bool: ...
    @overload
    def SetFace(self, index: int, vertex1: int, vertex2: int, vertex3: int, vertex4: int) -> bool: ...
    @overload
    def ToIntArray(self, asTriangles: bool) -> Iterable[int]: ...
    @overload
    def ToIntArray(self, asTriangles: bool, replacedIndices: List) -> Tuple[Iterable[int], List]: ...
    @overload
    def ToString(self) -> str: ...


class MeshFaceNormalList:
    def __iter__(self) -> Iterator[Vector3f]: ...
    def __getitem__(self, index: int) -> Vector3f: ...
    def __setitem__(self, index: int, value: Vector3f): ...
    @overload
    def AddFaceNormal(self, normal: Vector3f) -> int: ...
    @overload
    def AddFaceNormal(self, normal: Vector3d) -> int: ...
    @overload
    def AddFaceNormal(self, x: float, y: float, z: float) -> int: ...
    @overload
    def AddFaceNormal(self, x: Single, y: Single, z: Single) -> int: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def ComputeFaceNormals(self) -> bool: ...
    @overload
    def Destroy(self) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @overload
    @Count.setter
    def Count(self) -> MutableSequence[int]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def SetFaceNormal(self, index: int, normal: Vector3d) -> bool: ...
    @overload
    def SetFaceNormal(self, index: int, normal: Vector3f) -> bool: ...
    @overload
    def SetFaceNormal(self, index: int, x: Single, y: Single, z: Single) -> bool: ...
    @overload
    def SetFaceNormal(self, index: int, x: float, y: float, z: float) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def UnitizeFaceNormals(self) -> bool: ...


from ...FileIO import TextLog
class MeshNgonList:
    def __iter__(self) -> Iterator[MeshNgon]: ...
    def __getitem__(self, index: int) -> MeshNgon: ...
    def __setitem__(self, index: int, value: MeshNgon): ...
    @overload
    def AddNgon(self, ngon: MeshNgon) -> int: ...
    @overload
    def AddNgons(self, ngons: Iterable[MeshNgon]) -> Iterable[int]: ...
    @overload
    def AddPlanarNgons(self, planarTolerance: float) -> int: ...
    @overload
    def AddPlanarNgons(self, planarTolerance: float, minimumNgonVertexCount: int, minimumNgonFaceCount: int, allowHoles: bool) -> int: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    @property
    def UnsignedCount(self) -> UInt32: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetNgon(self, index: int) -> MeshNgon: ...
    @overload
    def GetNgonBoundary(self, ngonFaceIndexList: Iterable[int]) -> Iterable[int]: ...
    @overload
    def GetNgonBoundingBox(self, index: int) -> BoundingBox: ...
    @overload
    def GetNgonBoundingBox(self, ngon: MeshNgon) -> BoundingBox: ...
    @overload
    def GetNgonCenter(self, ngon: MeshNgon) -> Point3d: ...
    @overload
    def GetNgonCenter(self, index: int) -> Point3d: ...
    @overload
    def GetNgonEdgeCount(self, index: int) -> int: ...
    @overload
    def GetNgonOuterEdgeCount(self, index: int) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def Insert(self, index: int, ngon: MeshNgon) -> None: ...
    @overload
    def IsValid(self, index: int) -> UInt32: ...
    @overload
    def IsValid(self, index: int, textLog: TextLog) -> UInt32: ...
    @overload
    def NgonBoundaryVertexList(self, ngon: MeshNgon, bAppendStartPoint: bool) -> Iterable[Point3d]: ...
    @overload
    def NgonHasHoles(self, index: int) -> bool: ...
    @overload
    def NgonIndexFromFaceIndex(self, meshFaceIndex: int) -> int: ...
    @overload
    def Orientation(self, index: int, permitHoles: bool) -> int: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RemoveNgons(self, indices: Iterable[int]) -> int: ...
    @overload
    def ReverseOuterBoundary(self, index: int) -> None: ...
    @overload
    @Count.setter
    def Count(self) -> MutableSequence[int]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    @UnsignedCount.setter
    def UnsignedCount(self) -> MutableSequence[UInt32]: ...
    @overload
    def SetNgon(self, index: int, ngon: MeshNgon) -> None: ...
    @overload
    def ToString(self) -> str: ...


from ...Render import TextureMapping
class MeshTextureCoordinateList:
    def __iter__(self) -> Iterator[Point2f]: ...
    def __getitem__(self, index: int) -> Point2f: ...
    def __setitem__(self, index: int, value: Point2f): ...
    @overload
    def Add(self, tc: Point3d) -> int: ...
    @overload
    def Add(self, tc: Point2f) -> int: ...
    @overload
    def Add(self, s: Single, t: Single) -> int: ...
    @overload
    def Add(self, s: float, t: float) -> int: ...
    @overload
    def AddRange(self, textureCoordinates: Iterable[Point2f]) -> bool: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def Destroy(self) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def NormalizeTextureCoordinates(self) -> bool: ...
    @overload
    def ReverseTextureCoordinates(self, direction: int) -> bool: ...
    @overload
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @overload
    @Count.setter
    def Count(self) -> MutableSequence[int]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def SetTextureCoordinate(self, index: int, tc: Point2f) -> bool: ...
    @overload
    def SetTextureCoordinate(self, index: int, tc: Point3f) -> bool: ...
    @overload
    def SetTextureCoordinate(self, index: int, s: float, t: float) -> bool: ...
    @overload
    def SetTextureCoordinate(self, index: int, s: Single, t: Single) -> bool: ...
    @overload
    def SetTextureCoordinates(self, mapping: TextureMapping) -> bool: ...
    @overload
    def SetTextureCoordinates(self, textureCoordinates: Iterable[Point2f]) -> bool: ...
    @overload
    def ToFloatArray(self) -> Iterable[Single]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def TransposeTextureCoordinates(self) -> bool: ...


from .. import IndexPair
class MeshTopologyEdgeList:
    @overload
    def CollapseEdge(self, topologyEdgeIndex: int) -> bool: ...
    @overload
    def EdgeLine(self, topologyEdgeIndex: int) -> Line: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    def GetConnectedFaces(self, topologyEdgeIndex: int) -> Iterable[int]: ...
    @overload
    def GetConnectedFaces(self, topologyEdgeIndex: int) -> Tuple[Iterable[int], Iterable[bool]]: ...
    @overload
    def GetEdgeIndex(self, topologyVertex1: int, topologyVertex2: int) -> int: ...
    @overload
    def GetEdgesForFace(self, faceIndex: int) -> Iterable[int]: ...
    @overload
    def GetEdgesForFace(self, faceIndex: int) -> Tuple[Iterable[int], Iterable[bool]]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetTopologyVertices(self, topologyEdgeIndex: int) -> IndexPair: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def IsEdgeUnwelded(self, topologyEdgeIndex: int) -> bool: ...
    @overload
    def IsHidden(self, topologyEdgeIndex: int) -> bool: ...
    @overload
    def IsNgonInterior(self, topologyEdgeIndex: int) -> bool: ...
    @overload
    def IsSwappableEdge(self, topologyEdgeIndex: int) -> bool: ...
    @overload
    def SplitEdge(self, topologyEdgeIndex: int, t: float) -> bool: ...
    @overload
    def SplitEdge(self, topologyEdgeIndex: int, point: Point3d) -> bool: ...
    @overload
    def SwapEdge(self, topologyEdgeIndex: int) -> bool: ...
    @overload
    def ToString(self) -> str: ...


class MeshTopologyVertexList:
    def __iter__(self) -> Iterator[Point3f]: ...
    def __getitem__(self, index: int) -> Point3f: ...
    def __setitem__(self, index: int, value: Point3f): ...
    @overload
    def ConnectedEdge(self, topologyVertexIndex: int, edgeAtVertexIndex: int) -> int: ...
    @overload
    def ConnectedEdges(self, topologyVertexIndex: int) -> Iterable[int]: ...
    @overload
    def ConnectedEdgesCount(self, topologyVertexIndex: int) -> int: ...
    @overload
    def ConnectedFaces(self, topologyVertexIndex: int) -> Iterable[int]: ...
    @overload
    def ConnectedTopologyVertices(self, topologyVertexIndex: int) -> Iterable[int]: ...
    @overload
    def ConnectedTopologyVertices(self, topologyVertexIndex: int, sorted: bool) -> Iterable[int]: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def IndicesFromFace(self, faceIndex: int) -> Iterable[int]: ...
    @overload
    def IsHidden(self, topologyVertexIndex: int) -> bool: ...
    @overload
    def MeshVertexIndices(self, topologyVertexIndex: int) -> Iterable[int]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def SortEdges(self) -> bool: ...
    @overload
    def SortEdges(self, topologyVertexIndex: int) -> bool: ...
    @overload
    def TopologyVertexIndex(self, vertexIndex: int) -> int: ...
    @overload
    def ToString(self) -> str: ...


from ...Render import MappingTag
class MeshVertexColorList:
    def __iter__(self) -> Iterator[Color]: ...
    def __getitem__(self, index: int) -> Color: ...
    def __setitem__(self, index: int, value: Color): ...
    @overload
    def Add(self, color: Color) -> int: ...
    @overload
    def Add(self, red: int, green: int, blue: int) -> int: ...
    @overload
    def AppendColors(self, colors: Iterable[Color]) -> bool: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def CreateMonotoneMesh(self, baseColor: Color) -> bool: ...
    @overload
    def Destroy(self) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    @property
    def Tag(self) -> MappingTag: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @overload
    @Count.setter
    def Count(self) -> MutableSequence[int]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    @Tag.setter
    def Tag(self) -> MutableSequence[MappingTag]: ...
    @overload
    def SetColor(self, index: int, color: Color) -> bool: ...
    @overload
    def SetColor(self, face: MeshFace, color: Color) -> bool: ...
    @overload
    def SetColor(self, index: int, red: int, green: int, blue: int) -> bool: ...
    @overload
    def SetColors(self, colors: Iterable[Color]) -> bool: ...
    @overload
    def ToARGBArray(self) -> Iterable[int]: ...
    @overload
    def ToString(self) -> str: ...


class MeshVertexList:
    def __iter__(self) -> Iterator[Point3f]: ...
    def __getitem__(self, index: int) -> Point3f: ...
    def __setitem__(self, index: int, value: Point3f): ...
    @overload
    def Add(self, vertex: Point3f) -> int: ...
    @overload
    def Add(self, vertex: Point3d) -> int: ...
    @overload
    def Add(self, x: Single, y: Single, z: Single) -> int: ...
    @overload
    def Add(self, x: float, y: float, z: float) -> int: ...
    @overload
    def AddVertices(self, vertices: Iterable[Point3f]) -> None: ...
    @overload
    def AddVertices(self, vertices: Iterable[Point3d]) -> None: ...
    @overload
    def Align(self, distance: float, whichVertices: Iterable[bool]) -> int: ...
    @overload
    @staticmethod
    def Align(meshes: Iterable[Mesh], distance: float, whichVertices: Iterable[Iterable[bool]]) -> int: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def CombineIdentical(self, ignoreNormals: bool, ignoreAdditional: bool) -> bool: ...
    @overload
    def CullUnused(self) -> int: ...
    @overload
    def Destroy(self) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    @property
    def UseDoublePrecisionVertices(self) -> bool: ...
    @overload
    def GetConnectedVertices(self, vertexIndex: int) -> Iterable[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetTopologicalIndenticalVertices(self, vertexIndex: int) -> Iterable[int]: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def GetVertexFaces(self, vertexIndex: int) -> Iterable[int]: ...
    @overload
    def Hide(self, vertexIndex: int) -> None: ...
    @overload
    def HideAll(self) -> None: ...
    @overload
    def IsHidden(self, vertexIndex: int) -> bool: ...
    @overload
    def Point3dAt(self, index: int) -> Point3d: ...
    @overload
    def Remove(self, index: int, shrinkFaces: bool) -> bool: ...
    @overload
    def Remove(self, indices: Iterable[int], shrinkFaces: bool) -> bool: ...
    @overload
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @overload
    @Count.setter
    def Count(self) -> MutableSequence[int]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    @UseDoublePrecisionVertices.setter
    def UseDoublePrecisionVertices(self) -> MutableSequence[bool]: ...
    @overload
    def SetVertex(self, index: int, vertex: Point3d) -> bool: ...
    @overload
    def SetVertex(self, index: int, vertex: Point3f) -> bool: ...
    @overload
    def SetVertex(self, index: int, x: float, y: float, z: float) -> bool: ...
    @overload
    def SetVertex(self, index: int, x: Single, y: Single, z: Single) -> bool: ...
    @overload
    def SetVertex(self, index: int, x: float, y: float, z: float, updateNormals: bool) -> bool: ...
    @overload
    def Show(self, vertexIndex: int) -> None: ...
    @overload
    def ShowAll(self) -> None: ...
    @overload
    def ToFloatArray(self) -> Iterable[Single]: ...
    @overload
    def ToPoint3dArray(self) -> Iterable[Point3d]: ...
    @overload
    def ToPoint3fArray(self) -> Iterable[Point3f]: ...
    @overload
    def ToString(self) -> str: ...


class MeshVertexNormalList:
    def __iter__(self) -> Iterator[Vector3f]: ...
    def __getitem__(self, index: int) -> Vector3f: ...
    def __setitem__(self, index: int, value: Vector3f): ...
    @overload
    def Add(self, normal: Vector3f) -> int: ...
    @overload
    def Add(self, normal: Vector3d) -> int: ...
    @overload
    def Add(self, x: float, y: float, z: float) -> int: ...
    @overload
    def Add(self, x: Single, y: Single, z: Single) -> int: ...
    @overload
    def AddRange(self, normals: Iterable[Vector3f]) -> bool: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def ComputeNormals(self) -> bool: ...
    @overload
    def Destroy(self) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Flip(self) -> None: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @overload
    @Count.setter
    def Count(self) -> MutableSequence[int]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def SetNormal(self, index: int, normal: Vector3f) -> bool: ...
    @overload
    def SetNormal(self, index: int, normal: Vector3d) -> bool: ...
    @overload
    def SetNormal(self, index: int, x: Single, y: Single, z: Single) -> bool: ...
    @overload
    def SetNormal(self, index: int, x: float, y: float, z: float) -> bool: ...
    @overload
    def SetNormals(self, normals: Iterable[Vector3f]) -> bool: ...
    @overload
    def ToFloatArray(self) -> Iterable[Single]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def UnitizeNormals(self) -> bool: ...


class MeshVertexStatusList:
    def __iter__(self) -> Iterator[bool]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: bool): ...
    @overload
    def Add(self, hidden: bool) -> None: ...
    @overload
    def AddRange(self, values: Iterable[bool]) -> None: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def Contains(self, hidden: bool) -> bool: ...
    @overload
    def CopyTo(self, array: Iterable[bool], arrayIndex: int) -> None: ...
    @overload
    def Destroy(self) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def HiddenCount(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @overload
    @Count.setter
    def Count(self) -> MutableSequence[int]: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def ToString(self) -> str: ...


class NurbsCurveKnotList:
    def __iter__(self) -> Iterator[float]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float): ...
    @overload
    def ClampEnd(self, end: CurveEnd) -> bool: ...
    @overload
    def Contains(self, item: float) -> bool: ...
    @overload
    def CopyTo(self, array: Iterable[float], arrayIndex: int) -> None: ...
    @overload
    def CreatePeriodicKnots(self, knotSpacing: float) -> bool: ...
    @overload
    def CreateUniformKnots(self, knotSpacing: float) -> bool: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def EpsilonEquals(self, other: NurbsCurveKnotList, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def IsClampedEnd(self) -> bool: ...
    @overload
    @property
    def IsClampedStart(self) -> bool: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    @property
    def KnotStyle(self) -> KnotStyle: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def IndexOf(self, item: float) -> int: ...
    @overload
    def InsertKnot(self, value: float) -> bool: ...
    @overload
    def InsertKnot(self, value: float, multiplicity: int) -> bool: ...
    @overload
    def KnotMultiplicity(self, index: int) -> int: ...
    @overload
    def RemoveKnotAt(self, t: float) -> bool: ...
    @overload
    def RemoveKnots(self, index0: int, index1: int) -> bool: ...
    @overload
    def RemoveMultipleKnots(self, minimumMultiplicity: int, maximumMultiplicity: int, tolerance: float) -> int: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def SuperfluousKnot(self, start: bool) -> float: ...
    @overload
    def ToString(self) -> str: ...


class NurbsCurvePointList:
    def __iter__(self) -> Iterator[ControlPoint]: ...
    def __getitem__(self, index: int) -> ControlPoint: ...
    def __setitem__(self, index: int, value: ControlPoint): ...
    @overload
    def ChangeEndWeights(self, w0: float, w1: float) -> bool: ...
    @overload
    def Contains(self, item: ControlPoint) -> bool: ...
    @overload
    def ControlPolygon(self) -> Polyline: ...
    @overload
    def CopyTo(self, array: Iterable[ControlPoint], arrayIndex: int) -> None: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def EpsilonEquals(self, other: NurbsCurvePointList, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def ControlPolygonLength(self) -> float: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    @property
    def PointSize(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetPoint(self, index: int) -> Tuple[bool, Point4d]: ...
    @overload
    def GetPoint(self, index: int) -> Tuple[bool, Point3d]: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def GetWeight(self, index: int) -> float: ...
    @overload
    def IndexOf(self, item: ControlPoint) -> int: ...
    @overload
    def MakeNonRational(self) -> bool: ...
    @overload
    def MakeRational(self) -> bool: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def SetPoint(self, index: int, point: Point4d) -> bool: ...
    @overload
    def SetPoint(self, index: int, point: Point3d) -> bool: ...
    @overload
    def SetPoint(self, index: int, point: Point3d, weight: float) -> bool: ...
    @overload
    def SetPoint(self, index: int, x: float, y: float, z: float) -> bool: ...
    @overload
    def SetPoint(self, index: int, x: float, y: float, z: float, weight: float) -> bool: ...
    @overload
    def SetWeight(self, index: int, weight: float) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def UVNDirectionsAt(self, index: int) -> Tuple[bool, Vector3d, Vector3d, Vector3d]: ...
    @overload
    def ValidateSpacing(self, closeTolerance: float, stackTolerance: float) -> Tuple[bool, Iterable[int], Iterable[int]]: ...


class NurbsSurfaceKnotList:
    def __iter__(self) -> Iterator[float]: ...
    @overload
    def CreatePeriodicKnots(self, knotSpacing: float) -> bool: ...
    @overload
    def CreateUniformKnots(self, knotSpacing: float) -> bool: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def EpsilonEquals(self, other: NurbsSurfaceKnotList, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def ClampedAtEnd(self) -> bool: ...
    @overload
    @property
    def ClampedAtStart(self) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    @property
    def KnotStyle(self) -> KnotStyle: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def InsertKnot(self, value: float) -> bool: ...
    @overload
    def InsertKnot(self, value: float, multiplicity: int) -> bool: ...
    @overload
    def KnotMultiplicity(self, index: int) -> int: ...
    @overload
    def RemoveKnots(self, index0: int, index1: int) -> bool: ...
    @overload
    def RemoveKnotsAt(self, u: float, v: float) -> bool: ...
    @overload
    def RemoveMultipleKnots(self, minimumMultiplicity: int, maximumMultiplicity: int, tolerance: float) -> int: ...
    @overload
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def SuperfluousKnot(self, start: bool) -> float: ...
    @overload
    def ToString(self) -> str: ...


class NurbsSurfacePointList:
    def __iter__(self) -> Iterator[ControlPoint]: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def EpsilonEquals(self, other: NurbsSurfacePointList, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    @property
    def CountU(self) -> int: ...
    @overload
    @property
    def CountV(self) -> int: ...
    @overload
    @property
    def PointSize(self) -> int: ...
    @overload
    def GetControlPoint(self, u: int, v: int) -> ControlPoint: ...
    @overload
    def GetGrevillePoint(self, u: int, v: int) -> Point2d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetPoint(self, u: int, v: int) -> Tuple[bool, Point3d]: ...
    @overload
    def GetPoint(self, u: int, v: int) -> Tuple[bool, Point4d]: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def GetWeight(self, u: int, v: int) -> float: ...
    @overload
    def SetControlPoint(self, u: int, v: int, cp: ControlPoint) -> bool: ...
    @overload
    def SetPoint(self, u: int, v: int, point: Point3d) -> bool: ...
    @overload
    def SetPoint(self, u: int, v: int, point: Point4d) -> bool: ...
    @overload
    def SetPoint(self, u: int, v: int, point: Point3d, weight: float) -> bool: ...
    @overload
    def SetPoint(self, u: int, v: int, x: float, y: float, z: float) -> bool: ...
    @overload
    def SetPoint(self, u: int, v: int, x: float, y: float, z: float, weight: float) -> bool: ...
    @overload
    def SetWeight(self, u: int, v: int, weight: float) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def UVNDirectionsAt(self, u: int, v: int) -> Tuple[bool, Vector3d, Vector3d, Vector3d]: ...
    @overload
    def ValidateSpacing(self, closeTolerance: float, stackTolerance: float) -> Tuple[bool, Iterable[IndexPair], Iterable[IndexPair]]: ...


class SubDEdgeList:
    def __iter__(self) -> Iterator[SubDEdge]: ...
    @overload
    def Add(self, tag: SubDEdgeTag, v0: SubDVertex, v1: SubDVertex) -> SubDEdge: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Find(self, id: UInt32) -> SubDEdge: ...
    @overload
    def Find(self, id: int) -> SubDEdge: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def SetEdgeTags(self, edgeIndices: Iterable[int], tag: SubDEdgeTag) -> None: ...
    @overload
    def SetEdgeTags(self, edges: Iterable[SubDEdge], tag: SubDEdgeTag) -> None: ...
    @overload
    def ToString(self) -> str: ...


class SubDFaceList:
    def __iter__(self) -> Iterator[SubDFace]: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Find(self, id: UInt32) -> SubDFace: ...
    @overload
    def Find(self, id: int) -> SubDFace: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    def GetEnumerator(self) -> IEnumerator: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def ToString(self) -> str: ...


class SubDVertexList:
    @overload
    def Add(self, tag: SubDVertexTag, vertex: Point3d) -> SubDVertex: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Find(self, id: UInt32) -> SubDVertex: ...
    @overload
    def Find(self, id: int) -> SubDVertex: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def First(self) -> SubDVertex: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def ToString(self) -> str: ...
