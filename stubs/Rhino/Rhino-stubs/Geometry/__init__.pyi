from typing import overload, Tuple, Iterable, Iterator, Sequence, MutableSequence
from enum import Enum

import Collections
import Intersect
import MeshRefinements
import Morphs

__all__ = ['Collections', 'Intersect', 'MeshRefinements', 'Morphs']


from ..DocObjects import DimensionStyle
from ..DocObjects import AngleDisplayFormat
from ..DocObjects import ZeroSuppression
from ..DocObjects import ViewportInfo
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ArrowType
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class AngularDimension(Dimension):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, arc: Arc, offset: float): ...
    @overload
    def AdjustFromPoints(self, plane: Plane, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d) -> bool: ...
    @overload
    def AdjustFromPoints(self, plane: Plane, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d) -> bool: ...
    def ClearPropertyOverrides(self) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(dimStyle: DimensionStyle, plane: Plane, horizontal: Vector3d, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d) -> AngularDimension: ...
    @overload
    @staticmethod
    def Create(styleId: Guid, plane: Plane, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d) -> AngularDimension: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AlternateBelowLine(self) -> bool: ...
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def AltLengthFactor(self) -> float: ...
    @property
    def AltLengthResolution(self) -> int: ...
    @property
    def AltLengthRoundoff(self) -> float: ...
    @property
    def AltPrefix(self) -> str: ...
    @property
    def AltSuffix(self) -> str: ...
    @property
    def AltToleranceResolution(self) -> int: ...
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @property
    def AngleFormat(self) -> AngleDisplayFormat: ...
    @property
    def AngleResolution(self) -> int: ...
    @property
    def AngleRoundoff(self) -> float: ...
    @property
    def AngleZeroSuppression(self) -> ZeroSuppression: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @property
    def ArrowPoint1(self) -> Point2d: ...
    @property
    def ArrowPoint2(self) -> Point2d: ...
    @property
    def ArrowSize(self) -> float: ...
    @property
    def BaselineSpacing(self) -> float: ...
    @property
    def CentermarkSize(self) -> float: ...
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @property
    def CenterPoint(self) -> Point2d: ...
    @property
    def DecimalSeparator(self) -> Char: ...
    @property
    def DefPoint1(self) -> Point2d: ...
    @property
    def DefPoint2(self) -> Point2d: ...
    @property
    def DetailMeasured(self) -> Guid: ...
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def DimensionLineExtension(self) -> float: ...
    @property
    def DimensionScale(self) -> float: ...
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @property
    def DimensionStyleId(self) -> Guid: ...
    @property
    def DimlinePoint(self) -> Point2d: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def DistanceScale(self) -> float: ...
    @property
    def DrawForward(self) -> bool: ...
    @property
    def DrawTextFrame(self) -> bool: ...
    @property
    def ExtensionLineExtension(self) -> float: ...
    @property
    def ExtensionLineOffset(self) -> float: ...
    @property
    def FirstCharFont(self) -> Font: ...
    @property
    def FixedExtensionLength(self) -> float: ...
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @property
    def Font(self) -> Font: ...
    @property
    def FontIndex(self) -> int: ...
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @property
    def ForceDimLine(self) -> bool: ...
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @property
    def FormatWidth(self) -> float: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def LengthFactor(self) -> float: ...
    @property
    def LengthResolution(self) -> int: ...
    @property
    def LengthRoundoff(self) -> float: ...
    @property
    def MaskColor(self) -> Color: ...
    @property
    def MaskColorSource(self) -> MaskType: ...
    @property
    def MaskEnabled(self) -> bool: ...
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @property
    def MaskOffset(self) -> float: ...
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @property
    def NumericValue(self) -> float: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @property
    def PlainText(self) -> str: ...
    @property
    def PlainTextWithFields(self) -> str: ...
    @property
    def PlainUserText(self) -> str: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Prefix(self) -> str: ...
    @property
    def RichText(self) -> str: ...
    @property
    def Suffix(self) -> str: ...
    @property
    def SuppressExtension1(self) -> bool: ...
    @property
    def SuppressExtension2(self) -> bool: ...
    @property
    def Text(self) -> str: ...
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @property
    def TextFit(self) -> TextFit: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @property
    def TextHeight(self) -> float: ...
    @property
    def TextIsWrapped(self) -> bool: ...
    @property
    def TextLocation(self) -> TextLocation: ...
    @property
    def TextModelWidth(self) -> float: ...
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @property
    def TextPosition(self) -> Point2d: ...
    @property
    def TextRotation(self) -> float: ...
    @property
    def TextRotationDegrees(self) -> float: ...
    @property
    def TextRotationRadians(self) -> float: ...
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @property
    def ToleranceHeightScale(self) -> float: ...
    @property
    def ToleranceLowerValue(self) -> float: ...
    @property
    def ToleranceResolution(self) -> int: ...
    @property
    def ToleranceUpperValue(self) -> float: ...
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d]: ...
    def GetAngleDisplayText(self, style: DimensionStyle) -> str: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Iterable[Line], Iterable[Arc]]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    def GetTextRectangle(self) -> Tuple[bool, Iterable[Point3d]]: ...
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsAllBold(self) -> bool: ...
    def IsAllItalic(self) -> bool: ...
    def IsAllUnderlined(self) -> bool: ...
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @AlternateBelowLine.setter
    def AlternateBelowLine(self) -> MutableSequence[bool]: ...
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @AltLengthFactor.setter
    def AltLengthFactor(self) -> MutableSequence[float]: ...
    @AltLengthResolution.setter
    def AltLengthResolution(self) -> MutableSequence[int]: ...
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self) -> MutableSequence[float]: ...
    @AltPrefix.setter
    def AltPrefix(self) -> MutableSequence[str]: ...
    @AltSuffix.setter
    def AltSuffix(self) -> MutableSequence[str]: ...
    @AltToleranceResolution.setter
    def AltToleranceResolution(self) -> MutableSequence[int]: ...
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self) -> MutableSequence[bool]: ...
    @AltZeroSuppression.setter
    def AltZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    @AngleFormat.setter
    def AngleFormat(self) -> MutableSequence[AngleDisplayFormat]: ...
    @AngleResolution.setter
    def AngleResolution(self) -> MutableSequence[int]: ...
    @AngleRoundoff.setter
    def AngleRoundoff(self) -> MutableSequence[float]: ...
    @AngleZeroSuppression.setter
    def AngleZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    @ArrowBlockId1.setter
    def ArrowBlockId1(self) -> MutableSequence[Guid]: ...
    @ArrowBlockId2.setter
    def ArrowBlockId2(self) -> MutableSequence[Guid]: ...
    @ArrowFit.setter
    def ArrowFit(self) -> MutableSequence[ArrowFit]: ...
    @ArrowheadType1.setter
    def ArrowheadType1(self) -> MutableSequence[ArrowType]: ...
    @ArrowheadType2.setter
    def ArrowheadType2(self) -> MutableSequence[ArrowType]: ...
    @ArrowSize.setter
    def ArrowSize(self) -> MutableSequence[float]: ...
    @BaselineSpacing.setter
    def BaselineSpacing(self) -> MutableSequence[float]: ...
    @CentermarkSize.setter
    def CentermarkSize(self) -> MutableSequence[float]: ...
    @CentermarkStyle.setter
    def CentermarkStyle(self) -> MutableSequence[CenterMarkStyle]: ...
    @CenterPoint.setter
    def CenterPoint(self) -> MutableSequence[Point2d]: ...
    @DecimalSeparator.setter
    def DecimalSeparator(self) -> MutableSequence[Char]: ...
    @DefPoint1.setter
    def DefPoint1(self) -> MutableSequence[Point2d]: ...
    @DefPoint2.setter
    def DefPoint2(self) -> MutableSequence[Point2d]: ...
    @DetailMeasured.setter
    def DetailMeasured(self) -> MutableSequence[Guid]: ...
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DimensionLineExtension.setter
    def DimensionLineExtension(self) -> MutableSequence[float]: ...
    @DimensionScale.setter
    def DimensionScale(self) -> MutableSequence[float]: ...
    @DimensionStyleId.setter
    def DimensionStyleId(self) -> MutableSequence[Guid]: ...
    @DimlinePoint.setter
    def DimlinePoint(self) -> MutableSequence[Point2d]: ...
    @DistanceScale.setter
    def DistanceScale(self) -> MutableSequence[float]: ...
    @DrawForward.setter
    def DrawForward(self) -> MutableSequence[bool]: ...
    @DrawTextFrame.setter
    def DrawTextFrame(self) -> MutableSequence[bool]: ...
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self) -> MutableSequence[float]: ...
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self) -> MutableSequence[float]: ...
    @FixedExtensionLength.setter
    def FixedExtensionLength(self) -> MutableSequence[float]: ...
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self) -> MutableSequence[bool]: ...
    @Font.setter
    def Font(self) -> MutableSequence[Font]: ...
    @FontIndex.setter
    def FontIndex(self) -> MutableSequence[int]: ...
    @ForceArrowPosition.setter
    def ForceArrowPosition(self) -> MutableSequence[ForceArrow]: ...
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self) -> MutableSequence[bool]: ...
    @ForceDimLine.setter
    def ForceDimLine(self) -> MutableSequence[bool]: ...
    @ForceTextPosition.setter
    def ForceTextPosition(self) -> MutableSequence[ForceText]: ...
    @FormatWidth.setter
    def FormatWidth(self) -> MutableSequence[float]: ...
    @LengthFactor.setter
    def LengthFactor(self) -> MutableSequence[float]: ...
    @LengthResolution.setter
    def LengthResolution(self) -> MutableSequence[int]: ...
    @LengthRoundoff.setter
    def LengthRoundoff(self) -> MutableSequence[float]: ...
    @MaskColor.setter
    def MaskColor(self) -> MutableSequence[Color]: ...
    @MaskColorSource.setter
    def MaskColorSource(self) -> MutableSequence[MaskType]: ...
    @MaskEnabled.setter
    def MaskEnabled(self) -> MutableSequence[bool]: ...
    @MaskFrame.setter
    def MaskFrame(self) -> MutableSequence[MaskFrame]: ...
    @MaskOffset.setter
    def MaskOffset(self) -> MutableSequence[float]: ...
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self) -> MutableSequence[bool]: ...
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self) -> MutableSequence[DimensionStyle]: ...
    @PlainText.setter
    def PlainText(self) -> MutableSequence[str]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @Prefix.setter
    def Prefix(self) -> MutableSequence[str]: ...
    @RichText.setter
    def RichText(self) -> MutableSequence[str]: ...
    @Suffix.setter
    def Suffix(self) -> MutableSequence[str]: ...
    @SuppressExtension1.setter
    def SuppressExtension1(self) -> MutableSequence[bool]: ...
    @SuppressExtension2.setter
    def SuppressExtension2(self) -> MutableSequence[bool]: ...
    @Text.setter
    def Text(self) -> MutableSequence[str]: ...
    @TextAngleType.setter
    def TextAngleType(self) -> MutableSequence[LeaderContentAngleStyle]: ...
    @TextFit.setter
    def TextFit(self) -> MutableSequence[TextFit]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextHeight.setter
    def TextHeight(self) -> MutableSequence[float]: ...
    @TextIsWrapped.setter
    def TextIsWrapped(self) -> MutableSequence[bool]: ...
    @TextLocation.setter
    def TextLocation(self) -> MutableSequence[TextLocation]: ...
    @TextOrientation.setter
    def TextOrientation(self) -> MutableSequence[TextOrientation]: ...
    @TextPosition.setter
    def TextPosition(self) -> MutableSequence[Point2d]: ...
    @TextRotation.setter
    def TextRotation(self) -> MutableSequence[float]: ...
    @TextRotationDegrees.setter
    def TextRotationDegrees(self) -> MutableSequence[float]: ...
    @TextRotationRadians.setter
    def TextRotationRadians(self) -> MutableSequence[float]: ...
    @ToleranceFormat.setter
    def ToleranceFormat(self) -> MutableSequence[ToleranceDisplayFormat]: ...
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self) -> MutableSequence[float]: ...
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self) -> MutableSequence[float]: ...
    @ToleranceResolution.setter
    def ToleranceResolution(self) -> MutableSequence[int]: ...
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self) -> MutableSequence[float]: ...
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self) -> MutableSequence[bool]: ...
    @ZeroSuppression.setter
    def ZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetBold(self, set_on: bool) -> bool: ...
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    def SetItalic(self, set_on: bool) -> bool: ...
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    def SetUnderline(self, set_on: bool) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    def WrapText(self) -> None: ...


from ..DocObjects import Field
from ..DocObjects import DimensionStyle
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..Display import RhinoViewport
from ..DocObjects import Font
from ..DocObjects import LengthDisplay
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class AnnotationBase(GeometryBase):
    def ClearPropertyOverrides(self) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @staticmethod
    def FirstCharProperties(rtf_str: str, bold: bool, italic: bool, underline: bool, facename: str) -> Tuple[bool, bool, bool, bool, str]: ...
    @staticmethod
    def FormatRtfString(rtf_in: str, clear_bold: bool, set_bold: bool, clear_italic: bool, set_italic: bool, clear_underline: bool, set_underline: bool, clear_facename: bool, set_facename: bool, facename: str) -> str: ...
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def DecimalSeparator(self) -> Char: ...
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def DimensionScale(self) -> float: ...
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @property
    def DimensionStyleId(self) -> Guid: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def DrawForward(self) -> bool: ...
    @property
    def DrawTextFrame(self) -> bool: ...
    @property
    def FirstCharFont(self) -> Font: ...
    @property
    def Font(self) -> Font: ...
    @property
    def FontIndex(self) -> int: ...
    @property
    def FormatWidth(self) -> float: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def MaskColor(self) -> Color: ...
    @property
    def MaskColorSource(self) -> MaskType: ...
    @property
    def MaskEnabled(self) -> bool: ...
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @property
    def MaskOffset(self) -> float: ...
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @property
    def PlainText(self) -> str: ...
    @property
    def PlainTextWithFields(self) -> str: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def RichText(self) -> str: ...
    @property
    def Text(self) -> str: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @property
    def TextHeight(self) -> float: ...
    @property
    def TextIsWrapped(self) -> bool: ...
    @property
    def TextModelWidth(self) -> float: ...
    @property
    def TextRotationDegrees(self) -> float: ...
    @property
    def TextRotationRadians(self) -> float: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @staticmethod
    def GetDimensionScale(doc: RhinoDoc, dimstyle: DimensionStyle, vport: RhinoViewport) -> float: ...
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsAllBold(self) -> bool: ...
    def IsAllItalic(self) -> bool: ...
    def IsAllUnderlined(self) -> bool: ...
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    @staticmethod
    def PlainTextToRtf(str: str) -> str: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DecimalSeparator.setter
    def DecimalSeparator(self) -> MutableSequence[Char]: ...
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DimensionScale.setter
    def DimensionScale(self) -> MutableSequence[float]: ...
    @DimensionStyleId.setter
    def DimensionStyleId(self) -> MutableSequence[Guid]: ...
    @DrawForward.setter
    def DrawForward(self) -> MutableSequence[bool]: ...
    @DrawTextFrame.setter
    def DrawTextFrame(self) -> MutableSequence[bool]: ...
    @Font.setter
    def Font(self) -> MutableSequence[Font]: ...
    @FontIndex.setter
    def FontIndex(self) -> MutableSequence[int]: ...
    @FormatWidth.setter
    def FormatWidth(self) -> MutableSequence[float]: ...
    @MaskColor.setter
    def MaskColor(self) -> MutableSequence[Color]: ...
    @MaskColorSource.setter
    def MaskColorSource(self) -> MutableSequence[MaskType]: ...
    @MaskEnabled.setter
    def MaskEnabled(self) -> MutableSequence[bool]: ...
    @MaskFrame.setter
    def MaskFrame(self) -> MutableSequence[MaskFrame]: ...
    @MaskOffset.setter
    def MaskOffset(self) -> MutableSequence[float]: ...
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self) -> MutableSequence[bool]: ...
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self) -> MutableSequence[DimensionStyle]: ...
    @PlainText.setter
    def PlainText(self) -> MutableSequence[str]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @RichText.setter
    def RichText(self) -> MutableSequence[str]: ...
    @Text.setter
    def Text(self) -> MutableSequence[str]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextHeight.setter
    def TextHeight(self) -> MutableSequence[float]: ...
    @TextIsWrapped.setter
    def TextIsWrapped(self) -> MutableSequence[bool]: ...
    @TextRotationDegrees.setter
    def TextRotationDegrees(self) -> MutableSequence[float]: ...
    @TextRotationRadians.setter
    def TextRotationRadians(self) -> MutableSequence[float]: ...
    def SetBold(self, set_on: bool) -> bool: ...
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    def SetItalic(self, set_on: bool) -> bool: ...
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    def SetUnderline(self, set_on: bool) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    def WrapText(self) -> None: ...


class AnnotationType(Enum):
    Unset = 0
    Aligned = 1
    Angular = 2
    Diameter = 3
    Radius = 4
    Rotated = 5
    Ordinate = 6
    ArcLen = 7
    CenterMark = 8
    Text = 9
    Leader = 10
    Angular3pt = 11


class Arc:
    @overload
    def __init__(self, circle: Circle, angleRadians: float): ...
    @overload
    def __init__(self, circle: Circle, angleIntervalRadians: Interval): ...
    @overload
    def __init__(self, plane: Plane, radius: float, angleRadians: float): ...
    @overload
    def __init__(self, center: Point3d, radius: float, angleRadians: float): ...
    @overload
    def __init__(self, startPoint: Point3d, pointOnInterior: Point3d, endPoint: Point3d): ...
    @overload
    def __init__(self, pointA: Point3d, tangentA: Vector3d, pointB: Point3d): ...
    @overload
    def __init__(self, plane: Plane, center: Point3d, radius: float, angleRadians: float): ...
    def BoundingBox(self) -> BoundingBox: ...
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    def EpsilonEquals(self, other: Arc, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: Arc) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Angle(self) -> float: ...
    @property
    def AngleDegrees(self) -> float: ...
    @property
    def AngleDomain(self) -> Interval: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Circumference(self) -> float: ...
    @property
    def Diameter(self) -> float: ...
    @property
    def EndAngle(self) -> float: ...
    @property
    def EndAngleDegrees(self) -> float: ...
    @property
    def EndPoint(self) -> Point3d: ...
    @property
    def IsCircle(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Length(self) -> float: ...
    @property
    def MidPoint(self) -> Point3d: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Radius(self) -> float: ...
    @property
    def StartAngle(self) -> float: ...
    @property
    def StartAngleDegrees(self) -> float: ...
    @property
    def StartPoint(self) -> Point3d: ...
    @property
    def Unset() -> Arc: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def __eq__(a: Arc, b: Arc) -> bool: ...
    def __ne__(a: Arc, b: Arc) -> bool: ...
    def PointAt(self, t: float) -> Point3d: ...
    def Reverse(self) -> None: ...
    @Angle.setter
    def Angle(self) -> MutableSequence[float]: ...
    @AngleDegrees.setter
    def AngleDegrees(self) -> MutableSequence[float]: ...
    @AngleDomain.setter
    def AngleDomain(self) -> MutableSequence[Interval]: ...
    @Center.setter
    def Center(self) -> MutableSequence[Point3d]: ...
    @Diameter.setter
    def Diameter(self) -> MutableSequence[float]: ...
    @EndAngle.setter
    def EndAngle(self) -> MutableSequence[float]: ...
    @EndAngleDegrees.setter
    def EndAngleDegrees(self) -> MutableSequence[float]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @Radius.setter
    def Radius(self) -> MutableSequence[float]: ...
    @StartAngle.setter
    def StartAngle(self) -> MutableSequence[float]: ...
    @StartAngleDegrees.setter
    def StartAngleDegrees(self) -> MutableSequence[float]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    def Trim(self, domain: Interval) -> bool: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class ArcCurve(Curve):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: ArcCurve): ...
    @overload
    def __init__(self, arc: Arc): ...
    @overload
    def __init__(self, circle: Circle): ...
    @overload
    def __init__(self, arc: Arc, t0: float, t1: float): ...
    @overload
    def __init__(self, circle: Circle, t0: float, t1: float): ...
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    def Dispose(self) -> None: ...
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateCurve(self) -> Curve: ...
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @property
    def AngleDegrees(self) -> float: ...
    @property
    def AngleRadians(self) -> float: ...
    @property
    def Arc(self) -> Arc: ...
    @property
    def Degree(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Domain(self) -> Interval: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsCompleteCircle(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsPeriodic(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PointAtEnd(self) -> Point3d: ...
    @property
    def PointAtStart(self) -> Point3d: ...
    @property
    def Radius(self) -> float: ...
    @property
    def SpanCount(self) -> int: ...
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    def MakeClosed(self, tolerance: float) -> bool: ...
    def MakeDeformable(self) -> bool: ...
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    def PointAt(self, t: float) -> Point3d: ...
    def PointAtLength(self, length: float) -> Point3d: ...
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Domain.setter
    def Domain(self) -> MutableSequence[Interval]: ...
    def SetEndPoint(self, point: Point3d) -> bool: ...
    def SetStartPoint(self, point: Point3d) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    def TorsionAt(self, t: float) -> float: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class AreaMassProperties:
    def CentroidCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    def CentroidCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    @staticmethod
    def Compute(closedPlanarCurve: Curve) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(hatch: Hatch) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Iterable[GeometryBase]) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(closedPlanarCurve: Curve, planarTolerance: float) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Iterable[GeometryBase], area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool, relativeTolerance: float, absoluteTolerance: float) -> AreaMassProperties: ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Area(self) -> float: ...
    @property
    def AreaError(self) -> float: ...
    @property
    def Centroid(self) -> Point3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @property
    def CentroidError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...
    def WorldCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    def WorldCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...


from ..DocObjects import ArrowType
class Arrowhead:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, arrowType: ArrowType, blockId: Guid): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ArrowType(self) -> ArrowType: ...
    @property
    def BlockId(self) -> Guid: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


class Attenuation(Enum):
    Constant = 0
    Linear = 1
    InverseSquared = 2


class BezierCurve:
    @overload
    def __init__(self, controlPoints: Iterable[Point2d]): ...
    @overload
    def __init__(self, controlPoints: Iterable[Point3d]): ...
    @overload
    def __init__(self, controlPoints: Iterable[Point4d]): ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @staticmethod
    def CreateBeziers(sourceCurve: Curve) -> Iterable[BezierCurve]: ...
    @staticmethod
    def CreateCubicBeziers(sourceCurve: Curve, distanceTolerance: float, kinkTolerance: float) -> Iterable[BezierCurve]: ...
    @overload
    @staticmethod
    def CreateLoftedBezier(points: Iterable[Point3d]) -> BezierCurve: ...
    @overload
    @staticmethod
    def CreateLoftedBezier(points: Iterable[Point2d]) -> BezierCurve: ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ControlVertexCount(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def IsRational(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    def GetControlVertex2d(self, index: int) -> Point2d: ...
    def GetControlVertex3d(self, index: int) -> Point3d: ...
    def GetControlVertex4d(self, index: int) -> Point4d: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def IncreaseDegree(self, desiredDegree: int) -> bool: ...
    def MakeNonRational(self) -> bool: ...
    def MakeRational(self) -> bool: ...
    def PointAt(self, t: float) -> Point3d: ...
    def Split(self, t: float) -> Tuple[bool, BezierCurve, BezierCurve]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ToNurbsCurve(self) -> NurbsCurve: ...
    def ToString(self) -> str: ...


class BezierSurface:
    def ControlVertexCount(self, direction: int) -> int: ...
    @staticmethod
    def CreateLoftedBezier(curves: Iterable[BezierCurve]) -> BezierSurface: ...
    def Dispose(self) -> None: ...
    def Domain(self, direction: int) -> Interval: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def IsRational(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    def GetControlVertex2d(self, i: int, j: int) -> Point2d: ...
    def GetControlVertex3d(self, i: int, j: int) -> Point3d: ...
    def GetControlVertex4d(self, i: int, j: int) -> Point4d: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def MakeNonRational(self) -> bool: ...
    def MakeRational(self) -> bool: ...
    def PointAt(self, u: float, v: float) -> Point3d: ...
    def Reverse(self, direction: int) -> BezierSurface: ...
    def Split(self, direction: int, t: float) -> Tuple[bool, BezierSurface, BezierSurface]: ...
    def ToNurbsSurface(self) -> NurbsSurface: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    def Transpose(self) -> BezierSurface: ...


class BlendContinuity(Enum):
    Position = 0
    Tangency = 1
    Curvature = 2


class BlendType(Enum):
    Chamfer = 0
    Fillet = 1
    Blend = 2


class BoundingBox:
    @overload
    def __init__(self, points: Iterable[Point3d]): ...
    @overload
    def __init__(self, min: Point3d, max: Point3d): ...
    @overload
    def __init__(self, points: Iterable[Point3d], xform: Transform): ...
    @overload
    def __init__(self, minX: float, minY: float, minZ: float, maxX: float, maxY: float, maxZ: float): ...
    @overload
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, point: Point3d, includeInterior: bool) -> Point3d: ...
    @overload
    def Contains(self, point: Point3d) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox, strict: bool) -> bool: ...
    @overload
    def Contains(self, point: Point3d, strict: bool) -> bool: ...
    def Corner(self, minX: bool, minY: bool, minZ: bool) -> Point3d: ...
    def Equals(self, obj: Object) -> bool: ...
    def FurthestPoint(self, point: Point3d) -> Point3d: ...
    @property
    def Area(self) -> float: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Diagonal(self) -> Vector3d: ...
    @property
    def Empty() -> BoundingBox: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Max(self) -> Point3d: ...
    @property
    def Min(self) -> Point3d: ...
    @property
    def Unset() -> BoundingBox: ...
    @property
    def Volume(self) -> float: ...
    def GetCorners(self) -> Iterable[Point3d]: ...
    def GetEdges(self) -> Iterable[Line]: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    def Inflate(self, amount: float) -> None: ...
    @overload
    def Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None: ...
    @staticmethod
    def Intersection(a: BoundingBox, b: BoundingBox) -> BoundingBox: ...
    def IsDegenerate(self, tolerance: float) -> int: ...
    def MakeValid(self) -> bool: ...
    def PointAt(self, tx: float, ty: float, tz: float) -> Point3d: ...
    @Max.setter
    def Max(self) -> MutableSequence[Point3d]: ...
    @Min.setter
    def Min(self) -> MutableSequence[Point3d]: ...
    def ToBrep(self) -> Brep: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Union(self, other: BoundingBox) -> None: ...
    @overload
    def Union(self, point: Point3d) -> None: ...
    @overload
    @staticmethod
    def Union(a: BoundingBox, b: BoundingBox) -> BoundingBox: ...
    @overload
    @staticmethod
    def Union(box: BoundingBox, point: Point3d) -> BoundingBox: ...


class Box:
    @overload
    def __init__(self, other: Box): ...
    @overload
    def __init__(self, bbox: BoundingBox): ...
    @overload
    def __init__(self, basePlane: Plane, points: Iterable[Point3d]): ...
    @overload
    def __init__(self, basePlane: Plane, geometry: GeometryBase): ...
    @overload
    def __init__(self, basePlane: Plane, boundingbox: BoundingBox): ...
    @overload
    def __init__(self, basePlane: Plane, xSize: Interval, ySize: Interval, zSize: Interval): ...
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def Contains(self, box: BoundingBox) -> bool: ...
    @overload
    def Contains(self, point: Point3d) -> bool: ...
    @overload
    def Contains(self, box: Box) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox, strict: bool) -> bool: ...
    @overload
    def Contains(self, box: Box, strict: bool) -> bool: ...
    @overload
    def Contains(self, point: Point3d, strict: bool) -> bool: ...
    def EpsilonEquals(self, other: Box, epsilon: float) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    def FurthestPoint(self, point: Point3d) -> Point3d: ...
    @property
    def Area(self) -> float: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Empty() -> Box: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Unset() -> Box: ...
    @property
    def Volume(self) -> float: ...
    @property
    def X(self) -> Interval: ...
    @property
    def Y(self) -> Interval: ...
    @property
    def Z(self) -> Interval: ...
    def GetCorners(self) -> Iterable[Point3d]: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    def Inflate(self, amount: float) -> None: ...
    @overload
    def Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None: ...
    def MakeValid(self) -> bool: ...
    def PointAt(self, x: float, y: float, z: float) -> Point3d: ...
    def RepositionBasePlane(self, origin: Point3d) -> None: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @X.setter
    def X(self) -> MutableSequence[Interval]: ...
    @Y.setter
    def Y(self) -> MutableSequence[Interval]: ...
    @Z.setter
    def Z(self) -> MutableSequence[Interval]: ...
    def ToBrep(self) -> Brep: ...
    def ToExtrusion(self) -> Extrusion: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    def Union(self, point: Point3d) -> None: ...


from ..Collections import CurveList
from ..ApplicationSettings import CurvatureAnalysisSettingsState
from .Collections import BrepVertexList
from .Collections import BrepSurfaceList
from .Collections import BrepEdgeList
from .Collections import BrepTrimList
from .Collections import BrepLoopList
from .Collections import BrepFaceList
from .Collections import BrepCurveList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Brep(GeometryBase):
    def __init__(self): ...
    def AddEdgeCurve(self, curve: Curve) -> int: ...
    def AddSurface(self, surface: Surface) -> int: ...
    def AddTrimCurve(self, curve: Curve) -> int: ...
    def Append(self, other: Brep) -> None: ...
    def CapPlanarHoles(self, tolerance: float) -> Brep: ...
    @staticmethod
    def ChangeSeam(face: BrepFace, direction: int, parameter: float, tolerance: float) -> Brep: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, Point3d, ComponentIndex, float, float, Vector3d]: ...
    def Compact(self) -> None: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @staticmethod
    def CopyTrimCurves(trimSource: BrepFace, surfaceSource: Surface, tolerance: float) -> Brep: ...
    @staticmethod
    def CreateBaseballSphere(center: Point3d, radius: float, tolerance: float) -> Brep: ...
    @staticmethod
    def CreateBlendShape(face0: BrepFace, edge0: BrepEdge, t0: float, rev0: bool, continuity0: BlendContinuity, face1: BrepFace, edge1: BrepEdge, t1: float, rev1: bool, continuity1: BlendContinuity) -> Curve: ...
    @staticmethod
    def CreateBlendSurface(face0: BrepFace, edge0: BrepEdge, domain0: Interval, rev0: bool, continuity0: BlendContinuity, face1: BrepFace, edge1: BrepEdge, domain1: Interval, rev1: bool, continuity1: BlendContinuity) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float, manifoldOnly: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstBrep: Brep, secondBrep: Brep, tolerance: float, manifoldOnly: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float, manifoldOnly: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstBrep: Brep, secondBrep: Brep, tolerance: float, manifoldOnly: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanSplit(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanSplit(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(breps: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(breps: Iterable[Brep], tolerance: float, manifoldOnly: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateChamferSurface(face0: BrepFace, uv0: Point2d, radius0: float, face1: BrepFace, uv1: Point2d, radius1: float, extend: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateChamferSurface(face0: BrepFace, uv0: Point2d, radius0: float, face1: BrepFace, uv1: Point2d, radius1: float, trim: bool, extend: bool, tolerance: float) -> Tuple[Iterable[Brep], Iterable[Brep], Iterable[Brep]]: ...
    @overload
    @staticmethod
    def CreateContourCurves(brepToContour: Brep, sectionPlane: Plane) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateContourCurves(brepToContour: Brep, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Curve]: ...
    @staticmethod
    def CreateCurvatureAnalysisMesh(brep: Brep, state: CurvatureAnalysisSettingsState) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def CreateDevelopableLoft(rail0: NurbsCurve, rail1: NurbsCurve, fixedRulings: Iterable[Point2d]) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateDevelopableLoft(crv0: Curve, crv1: Curve, reverse0: bool, reverse1: bool, density: int) -> Iterable[Brep]: ...
    @staticmethod
    def CreateEdgeSurface(curves: Iterable[Curve]) -> Brep: ...
    @staticmethod
    def CreateFilletEdges(brep: Brep, edgeIndices: Iterable[int], startRadii: Iterable[float], endRadii: Iterable[float], blendType: BlendType, railType: RailType, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFilletSurface(face0: BrepFace, uv0: Point2d, face1: BrepFace, uv1: Point2d, radius: float, extend: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFilletSurface(face0: BrepFace, uv0: Point2d, face1: BrepFace, uv1: Point2d, radius: float, trim: bool, extend: bool, tolerance: float) -> Tuple[Iterable[Brep], Iterable[Brep], Iterable[Brep]]: ...
    @overload
    @staticmethod
    def CreateFromBox(corners: Iterable[Point3d]) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromBox(box: Box) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromBox(box: BoundingBox) -> Brep: ...
    @staticmethod
    def CreateFromCone(cone: Cone, capBottom: bool) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromCornerPoints(corner1: Point3d, corner2: Point3d, corner3: Point3d, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromCornerPoints(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d, tolerance: float) -> Brep: ...
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, capBottom: bool, capTop: bool) -> Brep: ...
    @staticmethod
    def CreateFromJoinedEdges(brep0: Brep, edgeIndex0: int, brep1: Brep, edgeIndex1: int, joinTolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromLoft(curves: Iterable[Curve], start: Point3d, end: Point3d, loftType: LoftType, closed: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromLoft(curves: Iterable[Curve], start: Point3d, end: Point3d, StartTangent: bool, EndTangent: bool, StartTrim: BrepTrim, EndTrim: BrepTrim, loftType: LoftType, closed: bool) -> Iterable[Brep]: ...
    @staticmethod
    def CreateFromLoftRebuild(curves: Iterable[Curve], start: Point3d, end: Point3d, loftType: LoftType, closed: bool, rebuildPointCount: int) -> Iterable[Brep]: ...
    @staticmethod
    def CreateFromLoftRefit(curves: Iterable[Curve], start: Point3d, end: Point3d, loftType: LoftType, closed: bool, refitTolerance: float) -> Iterable[Brep]: ...
    @staticmethod
    def CreateFromMesh(mesh: Mesh, trimmedTriangles: bool) -> Brep: ...
    @staticmethod
    def CreateFromOffsetFace(face: BrepFace, offsetDistance: float, offsetTolerance: float, bothSides: bool, createSolid: bool) -> Brep: ...
    @staticmethod
    def CreateFromRevSurface(surface: RevSurface, capStart: bool, capEnd: bool) -> Brep: ...
    @staticmethod
    def CreateFromSphere(sphere: Sphere) -> Brep: ...
    @staticmethod
    def CreateFromSurface(surface: Surface) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail: Curve, shapes: Iterable[Curve], closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail: Curve, shape: Curve, closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shape: Curve, closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Iterable[Curve], closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Iterable[Curve], start: Point3d, end: Point3d, closed: bool, tolerance: float, rebuild: SweepRebuild, rebuildPointCount: int, refitTolerance: float, preserveHeight: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Iterable[Curve], start: Point3d, end: Point3d, closed: bool, tolerance: float, rebuild: SweepRebuild, rebuildPointCount: int, refitTolerance: float, preserveHeight: bool, autoAdjust: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail: Curve, shapes: Iterable[Curve], startPoint: Point3d, endPoint: Point3d, frameType: SweepFrame, roadlikeNormal: Vector3d, closed: bool, blendType: SweepBlend, miterType: SweepMiter, tolerance: float, rebuildType: SweepRebuild, rebuildPointCount: int, refitTolerance: float) -> Iterable[Brep]: ...
    @staticmethod
    def CreateFromSweepInParts(rail1: Curve, rail2: Curve, shapes: Iterable[Curve], rail_params: Iterable[Point2d], closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweepSegmented(rail: Curve, shape: Curve, closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweepSegmented(rail: Curve, shapes: Iterable[Curve], closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweepSegmented(rail: Curve, shapes: Iterable[Curve], startPoint: Point3d, endPoint: Point3d, frameType: SweepFrame, roadlikeNormal: Vector3d, closed: bool, blendType: SweepBlend, miterType: SweepMiter, tolerance: float, rebuildType: SweepRebuild, rebuildPointCount: int, refitTolerance: float) -> Iterable[Brep]: ...
    @staticmethod
    def CreateFromTaperedExtrude(curveToExtrude: Curve, distance: float, direction: Vector3d, basePoint: Point3d, draftAngleRadians: float, cornerType: ExtrudeCornerType, tolerance: float, angleToleranceRadians: float) -> Iterable[Brep]: ...
    @staticmethod
    def CreateFromTaperedExtrudeWithRef(curve: Curve, direction: Vector3d, distance: float, draftAngle: float, plane: Plane, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateOffsetBrep(brep: Brep, distance: float, solid: bool, extend: bool, tolerance: float) -> Tuple[Iterable[Brep], Iterable[Brep], Iterable[Brep]]: ...
    @overload
    @staticmethod
    def CreateOffsetBrep(brep: Brep, distance: float, solid: bool, extend: bool, shrink: bool, tolerance: float) -> Tuple[Iterable[Brep], Iterable[Brep], Iterable[Brep]]: ...
    @overload
    @staticmethod
    def CreatePatch(geometry: Iterable[GeometryBase], startingSurface: Surface, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreatePatch(geometry: Iterable[GeometryBase], uSpans: int, vSpans: int, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreatePatch(geometry: Iterable[GeometryBase], startingSurface: Surface, uSpans: int, vSpans: int, trim: bool, tangency: bool, pointSpacing: float, flexibility: float, surfacePull: float, fixEdges: Iterable[bool], tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreatePipe(rail: Curve, radius: float, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePipe(rail: Curve, railRadiiParameters: Iterable[float], radii: Iterable[float], localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarBreps(inputLoops: CurveList, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarBreps(inputLoop: Curve, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarBreps(inputLoops: Iterable[Curve], tolerance: float) -> Iterable[Brep]: ...
    @staticmethod
    def CreatePlanarDifference(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> Iterable[Brep]: ...
    @staticmethod
    def CreatePlanarIntersection(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarUnion(breps: Iterable[Brep], plane: Plane, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarUnion(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> Iterable[Brep]: ...
    @staticmethod
    def CreateQuadSphere(sphere: Sphere) -> Brep: ...
    @staticmethod
    def CreateShell(brep: Brep, facesToRemove: Iterable[int], distance: float, tolerance: float) -> Iterable[Brep]: ...
    @staticmethod
    def CreateSolid(breps: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateThickPipe(rail: Curve, radius0: float, radius1: float, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateThickPipe(rail: Curve, railRadiiParameters: Iterable[float], radii0: Iterable[float], radii1: Iterable[float], localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateTrimmedPlane(plane: Plane, curve: Curve) -> Brep: ...
    @overload
    @staticmethod
    def CreateTrimmedPlane(plane: Plane, curves: Iterable[Curve]) -> Brep: ...
    @staticmethod
    def CreateTrimmedSurface(trimSource: BrepFace, surfaceSource: Surface, tolerance: float) -> Brep: ...
    def CullUnused2dCurves(self) -> bool: ...
    def CullUnused3dCurves(self) -> bool: ...
    def CullUnusedEdges(self) -> bool: ...
    def CullUnusedFaces(self) -> bool: ...
    def CullUnusedLoops(self) -> bool: ...
    def CullUnusedSurfaces(self) -> bool: ...
    def CullUnusedTrims(self) -> bool: ...
    def CullUnusedVertices(self) -> bool: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def DestroyRegionTopology(self) -> None: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateBrep(self) -> Brep: ...
    @overload
    def DuplicateEdgeCurves(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateEdgeCurves(self, nakedOnly: bool) -> Iterable[Curve]: ...
    def DuplicateNakedEdgeCurves(self, nakedOuter: bool, nakedInner: bool) -> Iterable[Curve]: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def DuplicateSubBrep(self, faceIndices: Iterable[int]) -> Brep: ...
    def DuplicateVertices(self) -> Iterable[Point3d]: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def FindCoincidentBrepComponents(self, point: Point3d, tolerance: float) -> Tuple[Iterable[int], Iterable[int], Iterable[int]]: ...
    def Flip(self) -> None: ...
    @property
    def Curves2D(self) -> BrepCurveList: ...
    @property
    def Curves3D(self) -> BrepCurveList: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Edges(self) -> BrepEdgeList: ...
    @property
    def Faces(self) -> BrepFaceList: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasRegionTopology(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsManifold(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSurface(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Loops(self) -> BrepLoopList: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def SolidOrientation(self) -> BrepSolidOrientation: ...
    @property
    def Surfaces(self) -> BrepSurfaceList: ...
    @property
    def Trims(self) -> BrepTrimList: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def Vertices(self) -> BrepVertexList: ...
    @overload
    def GetArea(self) -> float: ...
    @overload
    def GetArea(self, relativeTolerance: float, absoluteTolerance: float) -> float: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetConnectedComponents(self) -> Iterable[Brep]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPointInside(self, tolerance: float) -> Tuple[bool, Point3d]: ...
    def GetRegions(self) -> Iterable[BrepRegion]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def GetVolume(self) -> float: ...
    @overload
    def GetVolume(self, relativeTolerance: float, absoluteTolerance: float) -> float: ...
    def GetWireframe(self, density: int) -> Iterable[Curve]: ...
    @overload
    def IsBox(self) -> bool: ...
    @overload
    def IsBox(self, tolerance: float) -> bool: ...
    def IsDuplicate(self, other: Brep, tolerance: float) -> bool: ...
    def IsPointInside(self, point: Point3d, tolerance: float, strictlyIn: bool) -> bool: ...
    def IsValidGeometry(self) -> Tuple[bool, str]: ...
    def IsValidTolerancesAndFlags(self) -> Tuple[bool, str]: ...
    def IsValidTopology(self) -> Tuple[bool, str]: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def Join(self, otherBrep: Brep, tolerance: float, compact: bool) -> bool: ...
    @staticmethod
    def JoinBreps(brepsToJoin: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    def JoinEdges(self, edgeIndex0: int, edgeIndex1: int, joinTolerance: float, compact: bool) -> bool: ...
    def JoinNakedEdges(self, tolerance: float) -> int: ...
    def MakeDeformable(self) -> bool: ...
    def MakeValidForV2(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    @staticmethod
    def MergeBreps(brepsToMerge: Iterable[Brep], tolerance: float) -> Brep: ...
    @overload
    def MergeCoplanarFaces(self, tolerance: float) -> bool: ...
    @overload
    def MergeCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def MergeCoplanarFaces(self, faceIndex: int, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def MergeCoplanarFaces(self, faceIndex0: int, faceIndex1: int, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    @staticmethod
    def MergeSurfaces(brep0: Brep, brep1: Brep, tolerance: float, angleToleranceRadians: float) -> Brep: ...
    @overload
    @staticmethod
    def MergeSurfaces(surface0: Surface, surface1: Surface, tolerance: float, angleToleranceRadians: float) -> Brep: ...
    @overload
    @staticmethod
    def MergeSurfaces(brep0: Brep, brep1: Brep, tolerance: float, angleToleranceRadians: float, point0: Point2d, point1: Point2d, roundness: float, smooth: bool) -> Brep: ...
    def RebuildTrimsForV2(self, face: BrepFace, nurbsSurface: NurbsSurface) -> None: ...
    def RemoveFins(self) -> bool: ...
    @overload
    def RemoveHoles(self, tolerance: float) -> Brep: ...
    @overload
    def RemoveHoles(self, loops: Iterable[ComponentIndex], tolerance: float) -> Brep: ...
    def Repair(self, tolerance: float) -> bool: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetTolerancesBoxesAndFlags(self) -> None: ...
    @overload
    def SetTolerancesBoxesAndFlags(self, bLazy: bool, bSetVertexTolerances: bool, bSetEdgeTolerances: bool, bSetTrimTolerances: bool, bSetTrimIsoFlags: bool, bSetTrimTypeFlags: bool, bSetLoopTypeFlags: bool, bSetTrimBoxes: bool) -> None: ...
    def SetTrimIsoFlags(self) -> None: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def SetVertices(self) -> None: ...
    @overload
    def Split(self, cutters: Iterable[Curve], intersectionTolerance: float) -> Iterable[Brep]: ...
    @overload
    def Split(self, cutters: Iterable[Brep], intersectionTolerance: float) -> Iterable[Brep]: ...
    @overload
    def Split(self, cutter: Brep, intersectionTolerance: float) -> Iterable[Brep]: ...
    @overload
    def Split(self, cutter: Brep, intersectionTolerance: float) -> Tuple[Iterable[Brep], bool]: ...
    @overload
    def Split(self, cutters: Iterable[GeometryBase], normal: Vector3d, planView: bool, intersectionTolerance: float) -> Iterable[Brep]: ...
    def Standardize(self) -> None: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    def TransformComponent(self, components: Iterable[ComponentIndex], xform: Transform, tolerance: float, timeLimit: float, useMultipleThreads: bool) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, cutter: Brep, intersectionTolerance: float) -> Iterable[Brep]: ...
    @overload
    def Trim(self, cutter: Plane, intersectionTolerance: float) -> Iterable[Brep]: ...
    @staticmethod
    def TryConvertBrep(geometry: GeometryBase) -> Brep: ...
    def UnjoinEdges(self, edgesToUnjoin: Iterable[int]) -> Iterable[Brep]: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class BrepEdge(CurveProxy):
    def AdjacentFaces(self) -> Iterable[int]: ...
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def ConcavityAt(self, t: float, tolerance: float) -> Concavity: ...
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    def Dispose(self) -> None: ...
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateCurve(self) -> Curve: ...
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def Degree(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Domain(self) -> Interval: ...
    @property
    def EdgeCurve(self) -> Curve: ...
    @property
    def EdgeCurveIndex(self) -> int: ...
    @property
    def EdgeIndex(self) -> int: ...
    @property
    def EndVertex(self) -> BrepVertex: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsPeriodic(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PointAtEnd(self) -> Point3d: ...
    @property
    def PointAtStart(self) -> Point3d: ...
    @property
    def ProxyBrepSubDEdgeId(self) -> UInt32: ...
    @property
    def ProxyCurveIsReversed(self) -> bool: ...
    @property
    def SpanCount(self) -> int: ...
    @property
    def StartVertex(self) -> BrepVertex: ...
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @property
    def Tolerance(self) -> float: ...
    @property
    def TrimCount(self) -> int: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def Valence(self) -> EdgeAdjacency: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    def GetEdgeParameter(self, trimIndex: int, trimParameter: float) -> Tuple[bool, float]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    def IsSmoothManifoldEdge(self, angleToleranceRadians: float) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    def MakeClosed(self, tolerance: float) -> bool: ...
    def MakeDeformable(self) -> bool: ...
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    def PointAt(self, t: float) -> Point3d: ...
    def PointAtLength(self, length: float) -> Point3d: ...
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Domain.setter
    def Domain(self) -> MutableSequence[Interval]: ...
    @Tolerance.setter
    def Tolerance(self) -> MutableSequence[float]: ...
    @overload
    def SetEdgeCurve(self, curve3dIndex: int) -> bool: ...
    @overload
    def SetEdgeCurve(self, curve3dIndex: int, subDomain: Interval) -> bool: ...
    def SetEndPoint(self, point: Point3d) -> bool: ...
    def SetStartPoint(self, point: Point3d) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    def TorsionAt(self, t: float) -> float: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    def TrimIndices(self) -> Iterable[int]: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


from .Collections import BrepLoopList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class BrepFace(SurfaceProxy):
    def AdjacentEdges(self) -> Iterable[int]: ...
    def AdjacentFaces(self) -> Iterable[int]: ...
    def ChangeSurface(self, surfaceIndex: int) -> bool: ...
    def ClearMaterialChannelIndex(self) -> None: ...
    def ClearPackId(self) -> None: ...
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def CreateExtrusion(self, pathCurve: Curve, cap: bool) -> Brep: ...
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Degree(self, direction: int) -> int: ...
    def Dispose(self) -> None: ...
    def Domain(self, direction: int) -> Interval: ...
    def DraftAnglePoint(self, testPoint: Point2d, testAngle: float, pullDirection: Vector3d, edge: bool) -> Tuple[bool, Point3d, float]: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateFace(self, duplicateMeshes: bool) -> Brep: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def DuplicateSurface(self) -> Surface: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def FaceIndex(self) -> int: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def Id(self) -> Guid: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsSurface(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Loops(self) -> BrepLoopList: ...
    @property
    def MaterialChannelIndex(self) -> int: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def OrientationIsReversed(self) -> bool: ...
    @property
    def OuterLoop(self) -> BrepLoop: ...
    @property
    def PackId(self) -> UInt32: ...
    @property
    def PerFaceColor(self) -> Color: ...
    @property
    def ProxyBrepSubDFaceId(self) -> UInt32: ...
    @property
    def SurfaceIndex(self) -> int: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetMesh(self, meshType: MeshType) -> Mesh: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    def IsAtSeam(self, u: float, v: float) -> int: ...
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPointOnFace(self, u: float, v: float) -> PointFaceRelation: ...
    @overload
    def IsPointOnFace(self, u: float, v: float, tolerance: float) -> PointFaceRelation: ...
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    def PullPointsToFace(self, points: Iterable[Point3d], tolerance: float) -> Iterable[Point3d]: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    def RebuildEdges(self, tolerance: float, rebuildSharedEdges: bool, rebuildVertices: bool) -> bool: ...
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    def RefitTrim(self, edge: BrepEdge, knots: Iterable[float], tolerance: float, bSections: bool, fitQuality: float) -> Tuple[Iterable[Surface], float]: ...
    def RemoveHoles(self, tolerance: float) -> Brep: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Id.setter
    def Id(self) -> MutableSequence[Guid]: ...
    @MaterialChannelIndex.setter
    def MaterialChannelIndex(self) -> MutableSequence[int]: ...
    @OrientationIsReversed.setter
    def OrientationIsReversed(self) -> MutableSequence[bool]: ...
    @PerFaceColor.setter
    def PerFaceColor(self) -> MutableSequence[Color]: ...
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    def SetMesh(self, meshType: MeshType, mesh: Mesh) -> bool: ...
    def SetPackId(self, packId: UInt32) -> None: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    def ShrinkFace(self, disableSide: ShrinkDisableSide) -> bool: ...
    def ShrinkSurfaceToEdge(self) -> bool: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    def SpanCount(self, direction: int) -> int: ...
    @overload
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    @overload
    def Split(self, curves: Iterable[Curve], tolerance: float) -> Brep: ...
    def ToBrep(self) -> Brep: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    def TrimAwareIsoCurve(self, direction: int, constantParameter: float) -> Iterable[Curve]: ...
    def TrimAwareIsoIntervals(self, direction: int, constantParameter: float) -> Iterable[Interval]: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    def UnderlyingSurface(self) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


from .Collections import BrepTrimList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class BrepLoop(GeometryBase):
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Face(self) -> BrepFace: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def LoopIndex(self) -> int: ...
    @property
    def LoopType(self) -> BrepLoopType: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def Trims(self) -> BrepTrimList: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def To2dCurve(self) -> Curve: ...
    def To3dCurve(self) -> Curve: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class BrepLoopType(Enum):
    Unknown = 0
    Outer = 1
    Inner = 2
    Slit = 3
    CurveOnSurface = 4
    PointOnSurface = 5


from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
from ..Runtime import CommonObject
class BrepRegion(CommonObject):
    def BoundaryBrep(self) -> Brep: ...
    def Dispose(self) -> None: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def Index(self) -> int: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsFinite(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    def GetFaceSides(self) -> Iterable[BrepRegionFaceSide]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...


from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
from ..Runtime import CommonObject
class BrepRegionFaceSide(CommonObject):
    def Dispose(self) -> None: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Face(self) -> BrepFace: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Region(self) -> BrepRegion: ...
    @property
    def SurfaceNormalPointsIntoRegion(self) -> bool: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...


class BrepSolidOrientation(Enum):
    # None = 0
    Outward = 1
    Unknown = 2
    Inward = -1


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class BrepTrim(CurveProxy):
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    def Dispose(self) -> None: ...
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateCurve(self) -> Curve: ...
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def Degree(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Domain(self) -> Interval: ...
    @property
    def Edge(self) -> BrepEdge: ...
    @property
    def EndVertex(self) -> BrepVertex: ...
    @property
    def Face(self) -> BrepFace: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsoStatus(self) -> IsoStatus: ...
    @property
    def IsPeriodic(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Loop(self) -> BrepLoop: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PointAtEnd(self) -> Point3d: ...
    @property
    def PointAtStart(self) -> Point3d: ...
    @property
    def ProxyCurveIsReversed(self) -> bool: ...
    @property
    def SpanCount(self) -> int: ...
    @property
    def StartVertex(self) -> BrepVertex: ...
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @property
    def TrimCurve(self) -> Curve: ...
    @property
    def TrimCurveIndex(self) -> int: ...
    @property
    def TrimIndex(self) -> int: ...
    @property
    def TrimType(self) -> BrepTrimType: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    def GetTolerances(self) -> Tuple[float, float]: ...
    def GetTrimParameter(self, edgeParameter: float) -> Tuple[bool, float]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsPolyline(self) -> bool: ...
    def IsReversed(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    def MakeClosed(self, tolerance: float) -> bool: ...
    def MakeDeformable(self) -> bool: ...
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    def PointAt(self, t: float) -> Point3d: ...
    def PointAtLength(self, length: float) -> Point3d: ...
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Domain.setter
    def Domain(self) -> MutableSequence[Interval]: ...
    @IsoStatus.setter
    def IsoStatus(self) -> MutableSequence[IsoStatus]: ...
    @TrimType.setter
    def TrimType(self) -> MutableSequence[BrepTrimType]: ...
    def SetEndPoint(self, point: Point3d) -> bool: ...
    def SetStartPoint(self, point: Point3d) -> bool: ...
    def SetTolerances(self, toleranceU: float, toleranceV: float) -> None: ...
    @overload
    def SetTrimCurve(self, curve2dIndex: int) -> bool: ...
    @overload
    def SetTrimCurve(self, curve2dIndex: int, subDomain: Interval) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    def TorsionAt(self, t: float) -> float: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class BrepTrimType(Enum):
    Unknown = 0
    Boundary = 1
    Mated = 2
    Seam = 3
    Singular = 4
    CurveOnSurface = 5
    PointOnSurface = 6
    Slit = 7


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class BrepVertex(Point):
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EdgeIndices(self) -> Iterable[int]: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def ProxyBrepSubDVertexId(self) -> UInt32: ...
    @property
    def Tolerance(self) -> float: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def VertexIndex(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Location.setter
    def Location(self) -> MutableSequence[Point3d]: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


from ..DocObjects import DimensionStyle
from ..DocObjects import ViewportInfo
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ArrowType
from ..DocObjects import ZeroSuppression
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Centermark(Dimension):
    def __init__(self): ...
    def ClearPropertyOverrides(self) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @staticmethod
    def Create(dimStyle: DimensionStyle, plane: Plane, centerpoint: Point3d, radius: float) -> Centermark: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AlternateBelowLine(self) -> bool: ...
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def AltLengthFactor(self) -> float: ...
    @property
    def AltLengthResolution(self) -> int: ...
    @property
    def AltLengthRoundoff(self) -> float: ...
    @property
    def AltPrefix(self) -> str: ...
    @property
    def AltSuffix(self) -> str: ...
    @property
    def AltToleranceResolution(self) -> int: ...
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @property
    def ArrowSize(self) -> float: ...
    @property
    def BaselineSpacing(self) -> float: ...
    @property
    def CentermarkSize(self) -> float: ...
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @property
    def DecimalSeparator(self) -> Char: ...
    @property
    def DetailMeasured(self) -> Guid: ...
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def DimensionLineExtension(self) -> float: ...
    @property
    def DimensionScale(self) -> float: ...
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @property
    def DimensionStyleId(self) -> Guid: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def DistanceScale(self) -> float: ...
    @property
    def DrawForward(self) -> bool: ...
    @property
    def DrawTextFrame(self) -> bool: ...
    @property
    def ExtensionLineExtension(self) -> float: ...
    @property
    def ExtensionLineOffset(self) -> float: ...
    @property
    def FirstCharFont(self) -> Font: ...
    @property
    def FixedExtensionLength(self) -> float: ...
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @property
    def Font(self) -> Font: ...
    @property
    def FontIndex(self) -> int: ...
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @property
    def ForceDimLine(self) -> bool: ...
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @property
    def FormatWidth(self) -> float: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def LengthFactor(self) -> float: ...
    @property
    def LengthResolution(self) -> int: ...
    @property
    def LengthRoundoff(self) -> float: ...
    @property
    def MaskColor(self) -> Color: ...
    @property
    def MaskColorSource(self) -> MaskType: ...
    @property
    def MaskEnabled(self) -> bool: ...
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @property
    def MaskOffset(self) -> float: ...
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @property
    def NumericValue(self) -> float: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @property
    def PlainText(self) -> str: ...
    @property
    def PlainTextWithFields(self) -> str: ...
    @property
    def PlainUserText(self) -> str: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Prefix(self) -> str: ...
    @property
    def RichText(self) -> str: ...
    @property
    def Suffix(self) -> str: ...
    @property
    def SuppressExtension1(self) -> bool: ...
    @property
    def SuppressExtension2(self) -> bool: ...
    @property
    def Text(self) -> str: ...
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @property
    def TextFit(self) -> TextFit: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @property
    def TextHeight(self) -> float: ...
    @property
    def TextIsWrapped(self) -> bool: ...
    @property
    def TextLocation(self) -> TextLocation: ...
    @property
    def TextModelWidth(self) -> float: ...
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @property
    def TextPosition(self) -> Point2d: ...
    @property
    def TextRotation(self) -> float: ...
    @property
    def TextRotationDegrees(self) -> float: ...
    @property
    def TextRotationRadians(self) -> float: ...
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @property
    def ToleranceHeightScale(self) -> float: ...
    @property
    def ToleranceLowerValue(self) -> float: ...
    @property
    def ToleranceResolution(self) -> int: ...
    @property
    def ToleranceUpperValue(self) -> float: ...
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsAllBold(self) -> bool: ...
    def IsAllItalic(self) -> bool: ...
    def IsAllUnderlined(self) -> bool: ...
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @AlternateBelowLine.setter
    def AlternateBelowLine(self) -> MutableSequence[bool]: ...
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @AltLengthFactor.setter
    def AltLengthFactor(self) -> MutableSequence[float]: ...
    @AltLengthResolution.setter
    def AltLengthResolution(self) -> MutableSequence[int]: ...
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self) -> MutableSequence[float]: ...
    @AltPrefix.setter
    def AltPrefix(self) -> MutableSequence[str]: ...
    @AltSuffix.setter
    def AltSuffix(self) -> MutableSequence[str]: ...
    @AltToleranceResolution.setter
    def AltToleranceResolution(self) -> MutableSequence[int]: ...
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self) -> MutableSequence[bool]: ...
    @AltZeroSuppression.setter
    def AltZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    @ArrowBlockId1.setter
    def ArrowBlockId1(self) -> MutableSequence[Guid]: ...
    @ArrowBlockId2.setter
    def ArrowBlockId2(self) -> MutableSequence[Guid]: ...
    @ArrowFit.setter
    def ArrowFit(self) -> MutableSequence[ArrowFit]: ...
    @ArrowheadType1.setter
    def ArrowheadType1(self) -> MutableSequence[ArrowType]: ...
    @ArrowheadType2.setter
    def ArrowheadType2(self) -> MutableSequence[ArrowType]: ...
    @ArrowSize.setter
    def ArrowSize(self) -> MutableSequence[float]: ...
    @BaselineSpacing.setter
    def BaselineSpacing(self) -> MutableSequence[float]: ...
    @CentermarkSize.setter
    def CentermarkSize(self) -> MutableSequence[float]: ...
    @CentermarkStyle.setter
    def CentermarkStyle(self) -> MutableSequence[CenterMarkStyle]: ...
    @DecimalSeparator.setter
    def DecimalSeparator(self) -> MutableSequence[Char]: ...
    @DetailMeasured.setter
    def DetailMeasured(self) -> MutableSequence[Guid]: ...
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DimensionLineExtension.setter
    def DimensionLineExtension(self) -> MutableSequence[float]: ...
    @DimensionScale.setter
    def DimensionScale(self) -> MutableSequence[float]: ...
    @DimensionStyleId.setter
    def DimensionStyleId(self) -> MutableSequence[Guid]: ...
    @DistanceScale.setter
    def DistanceScale(self) -> MutableSequence[float]: ...
    @DrawForward.setter
    def DrawForward(self) -> MutableSequence[bool]: ...
    @DrawTextFrame.setter
    def DrawTextFrame(self) -> MutableSequence[bool]: ...
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self) -> MutableSequence[float]: ...
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self) -> MutableSequence[float]: ...
    @FixedExtensionLength.setter
    def FixedExtensionLength(self) -> MutableSequence[float]: ...
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self) -> MutableSequence[bool]: ...
    @Font.setter
    def Font(self) -> MutableSequence[Font]: ...
    @FontIndex.setter
    def FontIndex(self) -> MutableSequence[int]: ...
    @ForceArrowPosition.setter
    def ForceArrowPosition(self) -> MutableSequence[ForceArrow]: ...
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self) -> MutableSequence[bool]: ...
    @ForceDimLine.setter
    def ForceDimLine(self) -> MutableSequence[bool]: ...
    @ForceTextPosition.setter
    def ForceTextPosition(self) -> MutableSequence[ForceText]: ...
    @FormatWidth.setter
    def FormatWidth(self) -> MutableSequence[float]: ...
    @LengthFactor.setter
    def LengthFactor(self) -> MutableSequence[float]: ...
    @LengthResolution.setter
    def LengthResolution(self) -> MutableSequence[int]: ...
    @LengthRoundoff.setter
    def LengthRoundoff(self) -> MutableSequence[float]: ...
    @MaskColor.setter
    def MaskColor(self) -> MutableSequence[Color]: ...
    @MaskColorSource.setter
    def MaskColorSource(self) -> MutableSequence[MaskType]: ...
    @MaskEnabled.setter
    def MaskEnabled(self) -> MutableSequence[bool]: ...
    @MaskFrame.setter
    def MaskFrame(self) -> MutableSequence[MaskFrame]: ...
    @MaskOffset.setter
    def MaskOffset(self) -> MutableSequence[float]: ...
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self) -> MutableSequence[bool]: ...
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self) -> MutableSequence[DimensionStyle]: ...
    @PlainText.setter
    def PlainText(self) -> MutableSequence[str]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @Prefix.setter
    def Prefix(self) -> MutableSequence[str]: ...
    @RichText.setter
    def RichText(self) -> MutableSequence[str]: ...
    @Suffix.setter
    def Suffix(self) -> MutableSequence[str]: ...
    @SuppressExtension1.setter
    def SuppressExtension1(self) -> MutableSequence[bool]: ...
    @SuppressExtension2.setter
    def SuppressExtension2(self) -> MutableSequence[bool]: ...
    @Text.setter
    def Text(self) -> MutableSequence[str]: ...
    @TextAngleType.setter
    def TextAngleType(self) -> MutableSequence[LeaderContentAngleStyle]: ...
    @TextFit.setter
    def TextFit(self) -> MutableSequence[TextFit]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextHeight.setter
    def TextHeight(self) -> MutableSequence[float]: ...
    @TextIsWrapped.setter
    def TextIsWrapped(self) -> MutableSequence[bool]: ...
    @TextLocation.setter
    def TextLocation(self) -> MutableSequence[TextLocation]: ...
    @TextOrientation.setter
    def TextOrientation(self) -> MutableSequence[TextOrientation]: ...
    @TextPosition.setter
    def TextPosition(self) -> MutableSequence[Point2d]: ...
    @TextRotation.setter
    def TextRotation(self) -> MutableSequence[float]: ...
    @TextRotationDegrees.setter
    def TextRotationDegrees(self) -> MutableSequence[float]: ...
    @TextRotationRadians.setter
    def TextRotationRadians(self) -> MutableSequence[float]: ...
    @ToleranceFormat.setter
    def ToleranceFormat(self) -> MutableSequence[ToleranceDisplayFormat]: ...
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self) -> MutableSequence[float]: ...
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self) -> MutableSequence[float]: ...
    @ToleranceResolution.setter
    def ToleranceResolution(self) -> MutableSequence[int]: ...
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self) -> MutableSequence[float]: ...
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self) -> MutableSequence[bool]: ...
    @ZeroSuppression.setter
    def ZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetBold(self, set_on: bool) -> bool: ...
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    def SetItalic(self, set_on: bool) -> bool: ...
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    def SetUnderline(self, set_on: bool) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    def WrapText(self) -> None: ...


class Circle:
    @overload
    def __init__(self, radius: float): ...
    @overload
    def __init__(self, arc: Arc): ...
    @overload
    def __init__(self, plane: Plane, radius: float): ...
    @overload
    def __init__(self, center: Point3d, radius: float): ...
    @overload
    def __init__(self, point1: Point3d, point2: Point3d, point3: Point3d): ...
    @overload
    def __init__(self, plane: Plane, center: Point3d, radius: float): ...
    @overload
    def __init__(self, startPoint: Point3d, tangentAtP: Vector3d, pointOnCircle: Point3d): ...
    def ClosestParameter(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    def DerivativeAt(self, derivative: int, t: float) -> Vector3d: ...
    def EpsilonEquals(self, other: Circle, epsilon: float) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Circumference(self) -> float: ...
    @property
    def Diameter(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Normal(self) -> Vector3d: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Radius(self) -> float: ...
    @property
    def Unset() -> Circle: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def IsInPlane(self, plane: Plane, tolerance: float) -> bool: ...
    def PointAt(self, t: float) -> Point3d: ...
    def Reverse(self) -> None: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d, point: Point3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d, point: Point3d) -> bool: ...
    @Center.setter
    def Center(self) -> MutableSequence[Point3d]: ...
    @Circumference.setter
    def Circumference(self) -> MutableSequence[float]: ...
    @Diameter.setter
    def Diameter(self) -> MutableSequence[float]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @Radius.setter
    def Radius(self) -> MutableSequence[float]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    def Translate(self, delta: Vector3d) -> bool: ...
    @staticmethod
    def TryFitCircleToPoints(points: Iterable[Point3d]) -> Tuple[bool, Circle]: ...
    @staticmethod
    def TryFitCircleTT(c1: Curve, c2: Curve, t1: float, t2: float) -> Circle: ...
    @staticmethod
    def TryFitCircleTTT(c1: Curve, c2: Curve, c3: Curve, t1: float, t2: float, t3: float) -> Circle: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class ClippingPlaneSurface(PlaneSurface):
    def AddClipViewportId(self, viewportId: Guid) -> bool: ...
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Degree(self, direction: int) -> int: ...
    def Dispose(self) -> None: ...
    def Domain(self, direction: int) -> Interval: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    def IsAtSeam(self, u: float, v: float) -> int: ...
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    def RemoveClipViewportId(self, viewportId: Guid) -> bool: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    def SpanCount(self, direction: int) -> int: ...
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    def ToBrep(self) -> Brep: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...
    def ViewportIds(self) -> Iterable[Guid]: ...


class ComponentIndex:
    def __init__(self, type: ComponentIndexType, index: int): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ComponentIndexType(self) -> ComponentIndexType: ...
    @property
    def Index(self) -> int: ...
    @property
    def Unset() -> ComponentIndex: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def IsUnset(self) -> bool: ...
    def ToString(self) -> str: ...


class ComponentIndexType(Enum):
    InvalidType = 0
    BrepVertex = 1
    BrepEdge = 2
    BrepFace = 3
    BrepTrim = 4
    BrepLoop = 5
    MeshVertex = 11
    MeshTopologyVertex = 12
    MeshTopologyEdge = 13
    MeshFace = 14
    MeshNgon = 15
    InstanceDefinitionPart = 21
    PolycurveSegment = 31
    PointCloudPoint = 41
    GroupMember = 51
    ExtrusionBottomProfile = 61
    ExtrusionTopProfile = 62
    ExtrusionWallEdge = 63
    ExtrusionWallSurface = 64
    ExtrusionCapSurface = 65
    ExtrusionPath = 66
    SubdVertex = 71
    SubdEdge = 72
    SubdFace = 73
    DimLinearPoint = 100
    DimRadialPoint = 101
    DimAngularPoint = 102
    DimOrdinatePoint = 103
    DimTextPoint = 104
    NoType = 268435455


class ComponentStatus:
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, other: ComponentStatus) -> bool: ...
    @property
    def AllSet() -> ComponentStatus: ...
    @property
    def Clear() -> ComponentStatus: ...
    @property
    def Damaged() -> ComponentStatus: ...
    @property
    def Hidden() -> ComponentStatus: ...
    @property
    def Highlighted() -> ComponentStatus: ...
    @property
    def IsClear(self) -> bool: ...
    @property
    def IsDamaged(self) -> bool: ...
    @property
    def IsHidden(self) -> bool: ...
    @property
    def IsHighlighted(self) -> bool: ...
    @property
    def IsLocked(self) -> bool: ...
    @property
    def IsSelected(self) -> bool: ...
    @property
    def IsSelectedPersistent(self) -> bool: ...
    @property
    def Locked() -> ComponentStatus: ...
    @property
    def Selected() -> ComponentStatus: ...
    @property
    def SelectedPersistent() -> ComponentStatus: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def HasAllEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    def HasNoEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    def HasSomeEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    def __add__(a: ComponentStatus, b: ComponentStatus) -> ComponentStatus: ...
    def __eq__(a: ComponentStatus, b: ComponentStatus) -> bool: ...
    def __ne__(a: ComponentStatus, b: ComponentStatus) -> bool: ...
    def ToString(self) -> str: ...
    def WithStates(self, additionalStatus: ComponentStatus) -> ComponentStatus: ...


class ConcaveCornerOption(Enum):
    Unset = 0
    # None = 1
    AtMeshCorner = 2


class Concavity(Enum):
    Tangent = 0
    Convex = 1
    Concave = 2
    # None = -1


class Cone:
    def __init__(self, plane: Plane, height: float, radius: float): ...
    def AngleInDegrees(self) -> float: ...
    def AngleInRadians(self) -> float: ...
    def EpsilonEquals(self, other: Cone, epsilon: float) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ApexPoint(self) -> Point3d: ...
    @property
    def Axis(self) -> Vector3d: ...
    @property
    def BasePoint(self) -> Point3d: ...
    @property
    def Height(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Radius(self) -> float: ...
    @property
    def Unset() -> Cone: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @Height.setter
    def Height(self) -> MutableSequence[float]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @Radius.setter
    def Radius(self) -> MutableSequence[float]: ...
    def ToBrep(self, capBottom: bool) -> Brep: ...
    def ToNurbsSurface(self) -> NurbsSurface: ...
    def ToRevSurface(self) -> RevSurface: ...
    def ToString(self) -> str: ...


class ConicSectionType(Enum):
    Unknown = 0
    Circle = 1
    Ellipse = 2
    Hyperbola = 3
    Parabola = 4


class Continuity(Enum):
    # None = 0
    C0_continuous = 1
    C1_continuous = 2
    C2_continuous = 3
    G1_continuous = 4
    G2_continuous = 5
    C0_locus_continuous = 6
    C1_locus_continuous = 7
    C2_locus_continuous = 8
    G1_locus_continuous = 9
    G2_locus_continuous = 10
    Cinfinity_continuous = 11
    Gsmooth_continuous = 12


class ControlPoint:
    @overload
    def __init__(self, pt: Point3d): ...
    @overload
    def __init__(self, pt: Point4d): ...
    @overload
    def __init__(self, euclideanPt: Point3d, weight: float): ...
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    def __init__(self, x: float, y: float, z: float, weight: float): ...
    def EpsilonEquals(self, other: ControlPoint, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, other: ControlPoint) -> bool: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def Unset() -> ControlPoint: ...
    @property
    def Weight(self) -> float: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @property
    def Z(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @Location.setter
    def Location(self) -> MutableSequence[Point3d]: ...
    @Weight.setter
    def Weight(self) -> MutableSequence[float]: ...
    @X.setter
    def X(self) -> MutableSequence[float]: ...
    @Y.setter
    def Y(self) -> MutableSequence[float]: ...
    @Z.setter
    def Z(self) -> MutableSequence[float]: ...
    def ToString(self) -> str: ...


class ConvexCornerOption(Enum):
    Unset = 0
    # None = 1
    AtMeshCorner = 2


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Curve(GeometryBase):
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    @staticmethod
    def CreateArcBlend(startPt: Point3d, startDir: Vector3d, endPt: Point3d, endDir: Vector3d, controlPointLengthRatio: float) -> Curve: ...
    @staticmethod
    def CreateArcLineArcBlend(startPt: Point3d, startDir: Vector3d, endPt: Point3d, endDir: Vector3d, radius: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateBlendCurve(curveA: Curve, curveB: Curve, continuity: BlendContinuity) -> Curve: ...
    @overload
    @staticmethod
    def CreateBlendCurve(curveA: Curve, curveB: Curve, continuity: BlendContinuity, bulgeA: float, bulgeB: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateBlendCurve(curve0: Curve, t0: float, reverse0: bool, continuity0: BlendContinuity, curve1: Curve, t1: float, reverse1: bool, continuity1: BlendContinuity) -> Curve: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(curveA: Curve, subtractors: Iterable[Curve], tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(curveA: Curve, curveB: Curve, tolerance: float) -> Iterable[Curve]: ...
    @staticmethod
    def CreateBooleanIntersection(curveA: Curve, curveB: Curve, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateBooleanRegions(curves: Iterable[Curve], plane: Plane, combineRegions: bool, tolerance: float) -> CurveBooleanRegions: ...
    @overload
    @staticmethod
    def CreateBooleanRegions(curves: Iterable[Curve], plane: Plane, points: Iterable[Point3d], combineRegions: bool, tolerance: float) -> CurveBooleanRegions: ...
    @staticmethod
    def CreateBooleanUnion(curves: Iterable[Curve], tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateControlPointCurve(points: Iterable[Point3d]) -> Curve: ...
    @overload
    @staticmethod
    def CreateControlPointCurve(points: Iterable[Point3d], degree: int) -> Curve: ...
    @staticmethod
    def CreateCurve2View(curveA: Curve, curveB: Curve, vectorA: Vector3d, vectorB: Vector3d, tolerance: float, angleTolerance: float) -> Iterable[Curve]: ...
    @staticmethod
    def CreateFillet(curve0: Curve, curve1: Curve, radius: float, t0Base: float, t1Base: float) -> Arc: ...
    @staticmethod
    def CreateFilletCornersCurve(curve: Curve, radius: float, tolerance: float, angleTolerance: float) -> Curve: ...
    @staticmethod
    def CreateFilletCurves(curve0: Curve, point0: Point3d, curve1: Curve, point1: Point3d, radius: float, join: bool, trim: bool, arcExtension: bool, tolerance: float, angleTolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateInterpolatedCurve(points: Iterable[Point3d], degree: int) -> Curve: ...
    @overload
    @staticmethod
    def CreateInterpolatedCurve(points: Iterable[Point3d], degree: int, knots: CurveKnotStyle) -> Curve: ...
    @overload
    @staticmethod
    def CreateInterpolatedCurve(points: Iterable[Point3d], degree: int, knots: CurveKnotStyle, startTangent: Vector3d, endTangent: Vector3d) -> Curve: ...
    @staticmethod
    def CreateMatchCurve(curve0: Curve, reverse0: bool, continuity: BlendContinuity, curve1: Curve, reverse1: bool, preserve: PreserveEnd, average: bool) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateMeanCurve(curveA: Curve, curveB: Curve) -> Curve: ...
    @overload
    @staticmethod
    def CreateMeanCurve(curveA: Curve, curveB: Curve, angleToleranceRadians: float) -> Curve: ...
    @overload
    @staticmethod
    def CreatePeriodicCurve(curve: Curve) -> Curve: ...
    @overload
    @staticmethod
    def CreatePeriodicCurve(curve: Curve, smooth: bool) -> Curve: ...
    @staticmethod
    def CreateSoftEditCurve(curve: Curve, t: float, delta: Vector3d, length: float, fixEnds: bool) -> Curve: ...
    @staticmethod
    def CreateTextOutlines(text: str, font: str, textHeight: float, textStyle: int, closeLoops: bool, plane: Plane, smallCapsScale: float, tolerance: float) -> Iterable[Curve]: ...
    @staticmethod
    def CreateTweenCurves(curve0: Curve, curve1: Curve, numCurves: int, tolerance: float) -> Iterable[Curve]: ...
    @staticmethod
    def CreateTweenCurvesWithMatching(curve0: Curve, curve1: Curve, numCurves: int, tolerance: float) -> Iterable[Curve]: ...
    @staticmethod
    def CreateTweenCurvesWithSampling(curve0: Curve, curve1: Curve, numCurves: int, numSamples: int, tolerance: float) -> Iterable[Curve]: ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    def Dispose(self) -> None: ...
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    @staticmethod
    def DoDirectionsMatch(curveA: Curve, curveB: Curve) -> bool: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateCurve(self) -> Curve: ...
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @property
    def Degree(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Domain(self) -> Interval: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsPeriodic(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PointAtEnd(self) -> Point3d: ...
    @property
    def PointAtStart(self) -> Point3d: ...
    @property
    def SpanCount(self) -> int: ...
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    @staticmethod
    def GetDistancesBetweenCurves(curveA: Curve, curveB: Curve, tolerance: float) -> Tuple[bool, float, float, float, float, float, float]: ...
    @staticmethod
    def GetFilletPoints(curve0: Curve, curve1: Curve, radius: float, t0Base: float, t1Base: float) -> Tuple[bool, float, float, Plane]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Iterable[Curve]) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Iterable[Curve], joinTolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Iterable[Curve], joinTolerance: float, preserveDirection: bool) -> Iterable[Curve]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    def MakeClosed(self, tolerance: float) -> bool: ...
    def MakeDeformable(self) -> bool: ...
    @staticmethod
    def MakeEndsMeet(curveA: Curve, adjustStartCurveA: bool, curveB: Curve, adjustStartCurveB: bool) -> bool: ...
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @staticmethod
    def PlanarClosedCurveRelationship(curveA: Curve, curveB: Curve, testPlane: Plane, tolerance: float) -> RegionContainment: ...
    @staticmethod
    def PlanarCurveCollision(curveA: Curve, curveB: Curve, testPlane: Plane, tolerance: float) -> bool: ...
    def PointAt(self, t: float) -> Point3d: ...
    def PointAtLength(self, length: float) -> Point3d: ...
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    @overload
    @staticmethod
    def ProjectToBrep(curve: Curve, breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curve: Curve, brep: Brep, direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curves: Iterable[Curve], breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curve: Curve, breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Tuple[Iterable[Curve], Iterable[int]]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curves: Iterable[Curve], breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Tuple[Iterable[Curve], Iterable[int], Iterable[int]]: ...
    @overload
    @staticmethod
    def ProjectToMesh(curve: Curve, mesh: Mesh, direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToMesh(curve: Curve, meshes: Iterable[Mesh], direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToMesh(curves: Iterable[Curve], meshes: Iterable[Mesh], direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @staticmethod
    def ProjectToPlane(curve: Curve, plane: Plane) -> Curve: ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def PullToBrepFace(curve: Curve, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Domain.setter
    def Domain(self) -> MutableSequence[Interval]: ...
    def SetEndPoint(self, point: Point3d) -> bool: ...
    def SetStartPoint(self, point: Point3d) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    def TorsionAt(self, t: float) -> float: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class CurveBooleanRegions:
    def BoundaryCount(self, regionIndex: int) -> int: ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def PlanarCurveCount(self) -> int: ...
    @property
    def PointCount(self) -> int: ...
    @property
    def RegionCount(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def PlanarCurve(self, planarCurveIndex: int) -> Curve: ...
    def RegionCurves(self, regionIndex: int) -> Iterable[Curve]: ...
    def RegionPointIndex(self, pointIndex: int) -> int: ...
    def SegmentCount(self, regionIndex: int, boundaryIndex: int) -> int: ...
    def SegmentDetails(self, regionIndex: int, boundaryIndex: int, segmmentIndex: int) -> Tuple[int, Interval, bool]: ...
    def ToString(self) -> str: ...


class CurveEnd(Enum):
    # None = 0
    Start = 1
    End = 2
    Both = 3


class CurveEvaluationSide(Enum):
    Default = 0
    Above = 1
    Below = -1


class CurveExtensionStyle(Enum):
    Line = 0
    Arc = 1
    Smooth = 2


class CurveKnotStyle(Enum):
    Uniform = 0
    Chord = 1
    ChordSquareRoot = 2
    UniformPeriodic = 3
    ChordPeriodic = 4
    ChordSquareRootPeriodic = 5


class CurveOffsetCornerStyle(Enum):
    # None = 0
    Sharp = 1
    Round = 2
    Smooth = 3
    Chamfer = 4


class CurveOffsetEndStyle(Enum):
    # None = 0
    Flat = 1
    Round = 2


class CurveOrientation(Enum):
    Undefined = 0
    CounterClockwise = 1
    Clockwise = -1


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class CurveProxy(Curve):
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    def Dispose(self) -> None: ...
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateCurve(self) -> Curve: ...
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @property
    def Degree(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Domain(self) -> Interval: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsPeriodic(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PointAtEnd(self) -> Point3d: ...
    @property
    def PointAtStart(self) -> Point3d: ...
    @property
    def ProxyCurveIsReversed(self) -> bool: ...
    @property
    def SpanCount(self) -> int: ...
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    def MakeClosed(self, tolerance: float) -> bool: ...
    def MakeDeformable(self) -> bool: ...
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    def PointAt(self, t: float) -> Point3d: ...
    def PointAtLength(self, length: float) -> Point3d: ...
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Domain.setter
    def Domain(self) -> MutableSequence[Interval]: ...
    def SetEndPoint(self, point: Point3d) -> bool: ...
    def SetStartPoint(self, point: Point3d) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    def TorsionAt(self, t: float) -> float: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class CurveSimplifyOptions(Enum):
    # None = 0
    SplitAtFullyMultipleKnots = 1
    RebuildLines = 2
    RebuildArcs = 4
    RebuildRationals = 8
    AdjustG1 = 16
    Merge = 32
    All = 63


class Cylinder:
    @overload
    def __init__(self, baseCircle: Circle): ...
    @overload
    def __init__(self, baseCircle: Circle, height: float): ...
    def CircleAt(self, linearParameter: float) -> Circle: ...
    def EpsilonEquals(self, other: Cylinder, epsilon: float) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Axis(self) -> Vector3d: ...
    @property
    def BasePlane(self) -> Plane: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Height1(self) -> float: ...
    @property
    def Height2(self) -> float: ...
    @property
    def IsFinite(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Radius(self) -> float: ...
    @property
    def TotalHeight(self) -> float: ...
    @property
    def Unset() -> Cylinder: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def LineAt(self, angularParameter: float) -> Line: ...
    @BasePlane.setter
    def BasePlane(self) -> MutableSequence[Plane]: ...
    @Height1.setter
    def Height1(self) -> MutableSequence[float]: ...
    @Height2.setter
    def Height2(self) -> MutableSequence[float]: ...
    @Radius.setter
    def Radius(self) -> MutableSequence[float]: ...
    def ToBrep(self, capBottom: bool, capTop: bool) -> Brep: ...
    def ToNurbsSurface(self) -> NurbsSurface: ...
    def ToRevSurface(self) -> RevSurface: ...
    def ToString(self) -> str: ...


class Density(Enum):
    UnsetDensity = 0
    MinimumDensity = 0
    ExtraCoarseDensity = 1
    MinimumUserInterfaceDensity = 1
    MinimumAdaptiveDensity = 1
    CoarseDensity = 2
    MediumDensity = 3
    DefaultDensity = 4
    FineDensity = 4
    MaximumUserInterfaceDensity = 5
    ExtraFineDensity = 5
    MaximumDensity = 6


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class DetailView(GeometryBase):
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsParallelProjection(self) -> bool: ...
    @property
    def IsPerspectiveProjection(self) -> bool: ...
    @property
    def IsProjectionLocked(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PageToModelRatio(self) -> float: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @IsParallelProjection.setter
    def IsParallelProjection(self) -> MutableSequence[bool]: ...
    @IsPerspectiveProjection.setter
    def IsPerspectiveProjection(self) -> MutableSequence[bool]: ...
    @IsProjectionLocked.setter
    def IsProjectionLocked(self) -> MutableSequence[bool]: ...
    def SetScale(self, modelLength: float, modelUnits: UnitSystem, pageLength: float, pageUnits: UnitSystem) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class DevelopableSrf:
    def __init__(self): ...
    def Equals(self, obj: Object) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def GetLocalDevopableRuling(rail0: NurbsCurve, t0: float, dom0: Interval, rail1: NurbsCurve, t1: float, dom1: Interval, t0_out: float, t1_out: float) -> Tuple[int, float, float]: ...
    def GetType(self) -> Type: ...
    @overload
    @staticmethod
    def RulingMinTwist(rail0: NurbsCurve, t0: float, rail1: NurbsCurve, t1: float, dom1: Interval, t1_out: float, cos_twist_out: float) -> Tuple[bool, float, float]: ...
    @overload
    @staticmethod
    def RulingMinTwist(rail0: NurbsCurve, t0: float, dom0: Interval, rail1: NurbsCurve, t1: float, dom1: Interval, t0_out: float, t1_out: float, cos_twist_out: float) -> Tuple[bool, float, float, float]: ...
    def ToString(self) -> str: ...
    @staticmethod
    def UntwistRulings(rail0: NurbsCurve, rail1: NurbsCurve, rulings: Iterable[Point2d]) -> Tuple[bool, Iterable[Point2d]]: ...


from ..DocObjects import ViewportInfo
from ..DocObjects import DimensionStyle
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ArrowType
from ..DocObjects import ZeroSuppression
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Dimension(AnnotationBase):
    def ClearPropertyOverrides(self) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AlternateBelowLine(self) -> bool: ...
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def AltLengthFactor(self) -> float: ...
    @property
    def AltLengthResolution(self) -> int: ...
    @property
    def AltLengthRoundoff(self) -> float: ...
    @property
    def AltPrefix(self) -> str: ...
    @property
    def AltSuffix(self) -> str: ...
    @property
    def AltToleranceResolution(self) -> int: ...
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @property
    def ArrowSize(self) -> float: ...
    @property
    def BaselineSpacing(self) -> float: ...
    @property
    def CentermarkSize(self) -> float: ...
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @property
    def DecimalSeparator(self) -> Char: ...
    @property
    def DetailMeasured(self) -> Guid: ...
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def DimensionLineExtension(self) -> float: ...
    @property
    def DimensionScale(self) -> float: ...
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @property
    def DimensionStyleId(self) -> Guid: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def DistanceScale(self) -> float: ...
    @property
    def DrawForward(self) -> bool: ...
    @property
    def DrawTextFrame(self) -> bool: ...
    @property
    def ExtensionLineExtension(self) -> float: ...
    @property
    def ExtensionLineOffset(self) -> float: ...
    @property
    def FirstCharFont(self) -> Font: ...
    @property
    def FixedExtensionLength(self) -> float: ...
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @property
    def Font(self) -> Font: ...
    @property
    def FontIndex(self) -> int: ...
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @property
    def ForceDimLine(self) -> bool: ...
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @property
    def FormatWidth(self) -> float: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def LengthFactor(self) -> float: ...
    @property
    def LengthResolution(self) -> int: ...
    @property
    def LengthRoundoff(self) -> float: ...
    @property
    def MaskColor(self) -> Color: ...
    @property
    def MaskColorSource(self) -> MaskType: ...
    @property
    def MaskEnabled(self) -> bool: ...
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @property
    def MaskOffset(self) -> float: ...
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @property
    def NumericValue(self) -> float: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @property
    def PlainText(self) -> str: ...
    @property
    def PlainTextWithFields(self) -> str: ...
    @property
    def PlainUserText(self) -> str: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Prefix(self) -> str: ...
    @property
    def RichText(self) -> str: ...
    @property
    def Suffix(self) -> str: ...
    @property
    def SuppressExtension1(self) -> bool: ...
    @property
    def SuppressExtension2(self) -> bool: ...
    @property
    def Text(self) -> str: ...
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @property
    def TextFit(self) -> TextFit: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @property
    def TextHeight(self) -> float: ...
    @property
    def TextIsWrapped(self) -> bool: ...
    @property
    def TextLocation(self) -> TextLocation: ...
    @property
    def TextModelWidth(self) -> float: ...
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @property
    def TextPosition(self) -> Point2d: ...
    @property
    def TextRotation(self) -> float: ...
    @property
    def TextRotationDegrees(self) -> float: ...
    @property
    def TextRotationRadians(self) -> float: ...
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @property
    def ToleranceHeightScale(self) -> float: ...
    @property
    def ToleranceLowerValue(self) -> float: ...
    @property
    def ToleranceResolution(self) -> int: ...
    @property
    def ToleranceUpperValue(self) -> float: ...
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsAllBold(self) -> bool: ...
    def IsAllItalic(self) -> bool: ...
    def IsAllUnderlined(self) -> bool: ...
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @AlternateBelowLine.setter
    def AlternateBelowLine(self) -> MutableSequence[bool]: ...
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @AltLengthFactor.setter
    def AltLengthFactor(self) -> MutableSequence[float]: ...
    @AltLengthResolution.setter
    def AltLengthResolution(self) -> MutableSequence[int]: ...
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self) -> MutableSequence[float]: ...
    @AltPrefix.setter
    def AltPrefix(self) -> MutableSequence[str]: ...
    @AltSuffix.setter
    def AltSuffix(self) -> MutableSequence[str]: ...
    @AltToleranceResolution.setter
    def AltToleranceResolution(self) -> MutableSequence[int]: ...
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self) -> MutableSequence[bool]: ...
    @AltZeroSuppression.setter
    def AltZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    @ArrowBlockId1.setter
    def ArrowBlockId1(self) -> MutableSequence[Guid]: ...
    @ArrowBlockId2.setter
    def ArrowBlockId2(self) -> MutableSequence[Guid]: ...
    @ArrowFit.setter
    def ArrowFit(self) -> MutableSequence[ArrowFit]: ...
    @ArrowheadType1.setter
    def ArrowheadType1(self) -> MutableSequence[ArrowType]: ...
    @ArrowheadType2.setter
    def ArrowheadType2(self) -> MutableSequence[ArrowType]: ...
    @ArrowSize.setter
    def ArrowSize(self) -> MutableSequence[float]: ...
    @BaselineSpacing.setter
    def BaselineSpacing(self) -> MutableSequence[float]: ...
    @CentermarkSize.setter
    def CentermarkSize(self) -> MutableSequence[float]: ...
    @CentermarkStyle.setter
    def CentermarkStyle(self) -> MutableSequence[CenterMarkStyle]: ...
    @DecimalSeparator.setter
    def DecimalSeparator(self) -> MutableSequence[Char]: ...
    @DetailMeasured.setter
    def DetailMeasured(self) -> MutableSequence[Guid]: ...
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DimensionLineExtension.setter
    def DimensionLineExtension(self) -> MutableSequence[float]: ...
    @DimensionScale.setter
    def DimensionScale(self) -> MutableSequence[float]: ...
    @DimensionStyleId.setter
    def DimensionStyleId(self) -> MutableSequence[Guid]: ...
    @DistanceScale.setter
    def DistanceScale(self) -> MutableSequence[float]: ...
    @DrawForward.setter
    def DrawForward(self) -> MutableSequence[bool]: ...
    @DrawTextFrame.setter
    def DrawTextFrame(self) -> MutableSequence[bool]: ...
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self) -> MutableSequence[float]: ...
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self) -> MutableSequence[float]: ...
    @FixedExtensionLength.setter
    def FixedExtensionLength(self) -> MutableSequence[float]: ...
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self) -> MutableSequence[bool]: ...
    @Font.setter
    def Font(self) -> MutableSequence[Font]: ...
    @FontIndex.setter
    def FontIndex(self) -> MutableSequence[int]: ...
    @ForceArrowPosition.setter
    def ForceArrowPosition(self) -> MutableSequence[ForceArrow]: ...
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self) -> MutableSequence[bool]: ...
    @ForceDimLine.setter
    def ForceDimLine(self) -> MutableSequence[bool]: ...
    @ForceTextPosition.setter
    def ForceTextPosition(self) -> MutableSequence[ForceText]: ...
    @FormatWidth.setter
    def FormatWidth(self) -> MutableSequence[float]: ...
    @LengthFactor.setter
    def LengthFactor(self) -> MutableSequence[float]: ...
    @LengthResolution.setter
    def LengthResolution(self) -> MutableSequence[int]: ...
    @LengthRoundoff.setter
    def LengthRoundoff(self) -> MutableSequence[float]: ...
    @MaskColor.setter
    def MaskColor(self) -> MutableSequence[Color]: ...
    @MaskColorSource.setter
    def MaskColorSource(self) -> MutableSequence[MaskType]: ...
    @MaskEnabled.setter
    def MaskEnabled(self) -> MutableSequence[bool]: ...
    @MaskFrame.setter
    def MaskFrame(self) -> MutableSequence[MaskFrame]: ...
    @MaskOffset.setter
    def MaskOffset(self) -> MutableSequence[float]: ...
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self) -> MutableSequence[bool]: ...
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self) -> MutableSequence[DimensionStyle]: ...
    @PlainText.setter
    def PlainText(self) -> MutableSequence[str]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @Prefix.setter
    def Prefix(self) -> MutableSequence[str]: ...
    @RichText.setter
    def RichText(self) -> MutableSequence[str]: ...
    @Suffix.setter
    def Suffix(self) -> MutableSequence[str]: ...
    @SuppressExtension1.setter
    def SuppressExtension1(self) -> MutableSequence[bool]: ...
    @SuppressExtension2.setter
    def SuppressExtension2(self) -> MutableSequence[bool]: ...
    @Text.setter
    def Text(self) -> MutableSequence[str]: ...
    @TextAngleType.setter
    def TextAngleType(self) -> MutableSequence[LeaderContentAngleStyle]: ...
    @TextFit.setter
    def TextFit(self) -> MutableSequence[TextFit]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextHeight.setter
    def TextHeight(self) -> MutableSequence[float]: ...
    @TextIsWrapped.setter
    def TextIsWrapped(self) -> MutableSequence[bool]: ...
    @TextLocation.setter
    def TextLocation(self) -> MutableSequence[TextLocation]: ...
    @TextOrientation.setter
    def TextOrientation(self) -> MutableSequence[TextOrientation]: ...
    @TextPosition.setter
    def TextPosition(self) -> MutableSequence[Point2d]: ...
    @TextRotation.setter
    def TextRotation(self) -> MutableSequence[float]: ...
    @TextRotationDegrees.setter
    def TextRotationDegrees(self) -> MutableSequence[float]: ...
    @TextRotationRadians.setter
    def TextRotationRadians(self) -> MutableSequence[float]: ...
    @ToleranceFormat.setter
    def ToleranceFormat(self) -> MutableSequence[ToleranceDisplayFormat]: ...
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self) -> MutableSequence[float]: ...
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self) -> MutableSequence[float]: ...
    @ToleranceResolution.setter
    def ToleranceResolution(self) -> MutableSequence[int]: ...
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self) -> MutableSequence[float]: ...
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self) -> MutableSequence[bool]: ...
    @ZeroSuppression.setter
    def ZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetBold(self, set_on: bool) -> bool: ...
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    def SetItalic(self, set_on: bool) -> bool: ...
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    def SetUnderline(self, set_on: bool) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    def WrapText(self) -> None: ...


class DistancingMode(Enum):
    Undefined = 0
    Linear = 1
    LinearFromEnd = 2
    Ratio = 3
    RatioFromEnd = 4


class EdgeAdjacency(Enum):
    # None = 0
    Naked = 1
    Interior = 2
    NonManifold = 3


class Ellipse:
    @overload
    def __init__(self, plane: Plane, radius1: float, radius2: float): ...
    @overload
    def __init__(self, center: Point3d, second: Point3d, third: Point3d): ...
    def EpsilonEquals(self, other: Ellipse, epsilon: float) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def FocalDistance(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Radius1(self) -> float: ...
    @property
    def Radius2(self) -> float: ...
    def GetFoci(self) -> Tuple[Point3d, Point3d]: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @Center.setter
    def Center(self) -> MutableSequence[Point3d]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @Radius1.setter
    def Radius1(self) -> MutableSequence[float]: ...
    @Radius2.setter
    def Radius2(self) -> MutableSequence[float]: ...
    def ToNurbsCurve(self) -> NurbsCurve: ...
    def ToString(self) -> str: ...


class ExtraordinaryVertexProcessOption(Enum):
    # None = 0
    LocalG1 = 1
    LocalG2 = 2
    LocalG1x = 3


class ExtrudeCornerType(Enum):
    # None = 0
    Sharp = 1
    Round = 2
    Smooth = 3
    Chamfer = 4


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Extrusion(Surface):
    def __init__(self): ...
    def AddInnerProfile(self, innerProfile: Curve) -> bool: ...
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @staticmethod
    def Create(planarCurve: Curve, height: float, cap: bool) -> Extrusion: ...
    @staticmethod
    def CreateBoxExtrusion(box: Box, cap: bool) -> Extrusion: ...
    @staticmethod
    def CreateCylinderExtrusion(cylinder: Cylinder, capBottom: bool, capTop: bool) -> Extrusion: ...
    @staticmethod
    def CreatePipeExtrusion(cylinder: Cylinder, otherRadius: float, capTop: bool, capBottom: bool) -> Extrusion: ...
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Degree(self, direction: int) -> int: ...
    def Dispose(self) -> None: ...
    def Domain(self, direction: int) -> Interval: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @property
    def CapCount(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsCappedAtBottom(self) -> bool: ...
    @property
    def IsCappedAtTop(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsMiteredAtEnd(self) -> bool: ...
    @property
    def IsMiteredAtStart(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def MiterPlaneNormalAtEnd(self) -> Vector3d: ...
    @property
    def MiterPlaneNormalAtStart(self) -> Vector3d: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PathEnd(self) -> Point3d: ...
    @property
    def PathStart(self) -> Point3d: ...
    @property
    def PathTangent(self) -> Vector3d: ...
    @property
    def ProfileCount(self) -> int: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetBrepFormComponentIndex(self, extrusionComponentIndex: ComponentIndex) -> ComponentIndex: ...
    def GetHashCode(self) -> int: ...
    def GetMesh(self, meshType: MeshType) -> Mesh: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPathPlane(self, s: float) -> Plane: ...
    def GetProfilePlane(self, s: float) -> Plane: ...
    def GetProfileTransformation(self, s: float) -> Transform: ...
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def GetWireframe(self) -> Iterable[Curve]: ...
    def HasNurbsForm(self) -> int: ...
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    def IsAtSeam(self, u: float, v: float) -> int: ...
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    def PathLineCurve(self) -> LineCurve: ...
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Profile3d(self, ci: ComponentIndex) -> Curve: ...
    @overload
    def Profile3d(self, profileIndex: int, s: float) -> Curve: ...
    def ProfileIndex(self, profileParameter: float) -> int: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @MiterPlaneNormalAtEnd.setter
    def MiterPlaneNormalAtEnd(self) -> MutableSequence[Vector3d]: ...
    @MiterPlaneNormalAtStart.setter
    def MiterPlaneNormalAtStart(self) -> MutableSequence[Vector3d]: ...
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    def SetOuterProfile(self, outerProfile: Curve, cap: bool) -> bool: ...
    def SetPathAndUp(self, a: Point3d, b: Point3d, up: Vector3d) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    def SpanCount(self, direction: int) -> int: ...
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToBrep(self, splitKinkyFaces: bool) -> Brep: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...
    def WallEdge(self, ci: ComponentIndex) -> Curve: ...
    def WallSurface(self, ci: ComponentIndex) -> Surface: ...


class ForceArrow(Enum):
    Auto = 0
    Inside = 1
    Outside = 2


class ForceText(Enum):
    Auto = 0
    Inside = 1
    Right = 2
    Left = 3
    HintRight = 4
    HintLeft = 5


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
from ..Runtime import CommonObject
class GeometryBase(CommonObject):
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @staticmethod
    def GeometryEquals(first: GeometryBase, second: GeometryBase) -> bool: ...
    @staticmethod
    def GeometryReferenceEquals(one: GeometryBase, other: GeometryBase) -> bool: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


from ..DocObjects import HatchPattern
from ..Display import ColorGradient
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Hatch(GeometryBase):
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(curves: Iterable[Curve], hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> Iterable[Hatch]: ...
    @overload
    @staticmethod
    def Create(curve: Curve, hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> Iterable[Hatch]: ...
    @overload
    @staticmethod
    def Create(hatchPlane: Plane, outerLoop: Curve, innerLoops: Iterable[Curve], hatchPatternIndex: int, rotationRadians: float, scale: float) -> Hatch: ...
    def CreateDisplayGeometry(self, pattern: HatchPattern, patternScale: float) -> Tuple[Iterable[Curve], Iterable[Line], Brep]: ...
    @staticmethod
    def CreateFromBrep(brep: Brep, brepFaceIndex: int, hatchPatternIndex: int, rotationRadians: float, scale: float, basePoint: Point3d) -> Hatch: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Explode(self) -> Iterable[GeometryBase]: ...
    @property
    def BasePoint(self) -> Point3d: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PatternIndex(self) -> int: ...
    @property
    def PatternRotation(self) -> float: ...
    @property
    def PatternScale(self) -> float: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    def Get3dCurves(self, outer: bool) -> Iterable[Curve]: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetGradientFill(self) -> ColorGradient: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def ScalePattern(self, xform: Transform) -> None: ...
    @BasePoint.setter
    def BasePoint(self) -> MutableSequence[Point3d]: ...
    @PatternIndex.setter
    def PatternIndex(self) -> MutableSequence[int]: ...
    @PatternRotation.setter
    def PatternRotation(self) -> MutableSequence[float]: ...
    @PatternScale.setter
    def PatternScale(self) -> MutableSequence[float]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    def SetGradientFill(self, fill: ColorGradient) -> None: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class HermiteSurface:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, uCount: int, vCount: int): ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def UCount(self) -> int: ...
    @property
    def VCount(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def PointAt(self, uIndex: int, vIndex: int) -> Point3d: ...
    def SetPointAt(self, uIndex: int, vIndex: int, point: Point3d) -> None: ...
    def SetTwistAt(self, uIndex: int, vIndex: int, twist: Vector3d) -> None: ...
    def SetUParameterAt(self, index: int, parameter: float) -> None: ...
    def SetUTangentAt(self, uIndex: int, vIndex: int, tangent: Vector3d) -> None: ...
    def SetVParameterAt(self, index: int, parameter: float) -> None: ...
    def SetVTangentAt(self, uIndex: int, vIndex: int, tangent: Vector3d) -> None: ...
    def ToNurbsSurface(self) -> NurbsSurface: ...
    def ToString(self) -> str: ...
    def TwistAt(self, uIndex: int, vIndex: int) -> Vector3d: ...
    def UParameterAt(self, index: int) -> float: ...
    def UTangentAt(self, uIndex: int, vIndex: int) -> Vector3d: ...
    def VParameterAt(self, index: int) -> float: ...
    def VTangentAt(self, uIndex: int, vIndex: int) -> Vector3d: ...


from ..DocObjects import ViewportInfo
class HiddenLineDrawing:
    def BoundingBox(self, includeHidden: bool) -> BoundingBox: ...
    @overload
    @staticmethod
    def Compute(parameters: HiddenLineDrawingParameters, multipleThreads: bool) -> HiddenLineDrawing: ...
    @overload
    @staticmethod
    def Compute(parameters: HiddenLineDrawingParameters, multipleThreads: bool, progress: IProgress, cancelToken: CancellationToken) -> HiddenLineDrawing: ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Points(self) -> Iterable[HiddenLineDrawingPoint]: ...
    @property
    def Segments(self) -> Iterable[HiddenLineDrawingSegment]: ...
    @property
    def Viewport(self) -> ViewportInfo: ...
    @property
    def WorldToHiddenLine(self) -> Transform: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


class HiddenLineDrawingObject:
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Geometry(self) -> GeometryBase: ...
    @property
    def Tag(self) -> Object: ...
    @property
    def Transform(self) -> Transform: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


class HiddenLineDrawingObjectCurve:
    @overload
    def Curve(self, t: float) -> HiddenLineDrawingSegment: ...
    @overload
    def Curve(self, t: float, side: int) -> HiddenLineDrawingSegment: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ClippingPlaneIndex(self) -> int: ...
    @property
    def Index(self) -> int: ...
    @property
    def IsProjecting(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def OriginalDomainStart(self) -> float: ...
    @property
    def Parameters(self) -> Iterable[float]: ...
    @property
    def Segments(self) -> Iterable[HiddenLineDrawingSegment]: ...
    @property
    def SilhouetteType(self) -> SilhouetteType: ...
    @property
    def SourceObject(self) -> HiddenLineDrawingObject: ...
    @property
    def SourceObjectComponentIndex(self) -> ComponentIndex: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


from ..DocObjects import ViewportInfo
from ..Display import RhinoViewport
class HiddenLineDrawingParameters:
    def __init__(self): ...
    def AddClippingPlane(self, plane: Plane) -> None: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, tag: Object) -> bool: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, xform: Transform, tag: Object) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AbsoluteTolerance(self) -> float: ...
    @property
    def Flatten(self) -> bool: ...
    @property
    def IncludeHiddenCurves(self) -> bool: ...
    @property
    def IncludeTangentEdges(self) -> bool: ...
    @property
    def IncludeTangentSeams(self) -> bool: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self) -> MutableSequence[float]: ...
    @Flatten.setter
    def Flatten(self) -> MutableSequence[bool]: ...
    @IncludeHiddenCurves.setter
    def IncludeHiddenCurves(self) -> MutableSequence[bool]: ...
    @IncludeTangentEdges.setter
    def IncludeTangentEdges(self) -> MutableSequence[bool]: ...
    @IncludeTangentSeams.setter
    def IncludeTangentSeams(self) -> MutableSequence[bool]: ...
    @overload
    def SetViewport(self, viewport: RhinoViewport) -> None: ...
    @overload
    def SetViewport(self, viewport: ViewportInfo) -> None: ...
    def ToString(self) -> str: ...


class HiddenLineDrawingPoint:
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ClippingPlaneIndex(self) -> int: ...
    @property
    def Index(self) -> int: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def PointVisibility(self) -> Visibility: ...
    @property
    def SourceObject(self) -> HiddenLineDrawingObject: ...
    @property
    def SourceObjectComponentIndex(self) -> ComponentIndex: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


class HiddenLineDrawingSegment:
    def Equals(self, obj: Object) -> bool: ...
    @property
    def CurveGeometry(self) -> Curve: ...
    @property
    def CurveSideFills(self) -> Iterable[SideFill]: ...
    @property
    def Index(self) -> int: ...
    @property
    def IsSceneSilhouette(self) -> bool: ...
    @property
    def ParentCurve(self) -> HiddenLineDrawingObjectCurve: ...
    @property
    def SegmentVisibility(self) -> Visibility: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


from ..DocObjects import ModelComponentType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
from ..DocObjects import ModelComponent
class InstanceDefinitionGeometry(ModelComponent):
    def __init__(self): ...
    def ClearId(self) -> None: ...
    def ClearIndex(self) -> None: ...
    def ClearName(self) -> None: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ComponentStatus(self) -> ComponentStatus: ...
    @property
    def ComponentType(self) -> ModelComponentType: ...
    @property
    def DeletedName(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasId(self) -> bool: ...
    @property
    def HasIndex(self) -> bool: ...
    @property
    def HasName(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def Id(self) -> Guid: ...
    @property
    def IdIsLocked(self) -> bool: ...
    @property
    def Index(self) -> int: ...
    @property
    def IndexIsLocked(self) -> bool: ...
    @property
    def InstanceDefinitionModelSerialNumber(self) -> UInt32: ...
    @property
    def IsComponentStatusLocked(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsSystemComponent(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ModelSerialNumber(self) -> UInt32: ...
    @property
    def Name(self) -> str: ...
    @property
    def NameIsLocked(self) -> bool: ...
    @property
    def ReferenceModelSerialNumber(self) -> UInt32: ...
    @property
    def Url(self) -> str: ...
    @property
    def UrlDescription(self) -> str: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetObjectIds(self) -> Iterable[Guid]: ...
    def GetType(self) -> Type: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def LockId(self) -> None: ...
    def LockIndex(self) -> None: ...
    def LockName(self) -> None: ...
    @ComponentStatus.setter
    def ComponentStatus(self) -> MutableSequence[ComponentStatus]: ...
    @Description.setter
    def Description(self) -> MutableSequence[str]: ...
    @Id.setter
    def Id(self) -> MutableSequence[Guid]: ...
    @Index.setter
    def Index(self) -> MutableSequence[int]: ...
    @Name.setter
    def Name(self) -> MutableSequence[str]: ...
    @Url.setter
    def Url(self) -> MutableSequence[str]: ...
    @UrlDescription.setter
    def UrlDescription(self) -> MutableSequence[str]: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class InstanceReferenceGeometry(GeometryBase):
    def __init__(self, instanceDefinitionId: Guid, transform: Transform): ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def ParentIdefId(self) -> Guid: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def Xform(self) -> Transform: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class InteriorCreaseOption(Enum):
    Unset = 0
    # None = 1
    AtMeshDoubleEdge = 2


from ..Collections import RhinoList
class Interpolator:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initialCapacity: int): ...
    @overload
    def __init__(self, list: RhinoList): ...
    @overload
    def __init__(self, collection: Iterable[float]): ...
    @overload
    def __init__(self, amount: int, defaultValue: float): ...
    def __iter__(self) -> Iterator[float]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float): ...
    def Add(self, item: float) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[float]) -> None: ...
    @overload
    def AddRange(self, collection: IEnumerable) -> None: ...
    def AsReadOnly(self) -> ReadOnlyCollection: ...
    @overload
    def BinarySearch(self, item: float) -> int: ...
    @overload
    def BinarySearch(self, item: float, comparer: IComparer) -> int: ...
    @overload
    def BinarySearch(self, index: int, count: int, item: float, comparer: IComparer) -> int: ...
    def Clear(self) -> None: ...
    def Contains(self, item: float) -> bool: ...
    def ConvertAll(self, converter: Converter) -> RhinoList: ...
    @overload
    def CopyTo(self, array: Iterable[float]) -> None: ...
    @overload
    def CopyTo(self, array: Iterable[float], arrayIndex: int) -> None: ...
    @overload
    def CopyTo(self, index: int, array: Iterable[float], arrayIndex: int, count: int) -> None: ...
    def Duplicate(self) -> RhinoList: ...
    def Equals(self, obj: Object) -> bool: ...
    def Exists(self, match: Predicate) -> bool: ...
    def Find(self, match: Predicate) -> float: ...
    def FindAll(self, match: Predicate) -> RhinoList: ...
    @overload
    def FindIndex(self, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    def FindLast(self, match: Predicate) -> float: ...
    @overload
    def FindLastIndex(self, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    def ForEach(self, action: Action) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def Cyclical(self) -> bool: ...
    @property
    def First(self) -> float: ...
    @property
    def Item(self) -> Sequence[int]: ...
    @property
    def Last(self) -> float: ...
    @property
    def NullCount(self) -> int: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetHashCode(self) -> int: ...
    def GetRange(self, index: int, count: int) -> RhinoList: ...
    def GetType(self) -> Type: ...
    @overload
    def IndexOf(self, item: float) -> int: ...
    @overload
    def IndexOf(self, item: float, index: int) -> int: ...
    @overload
    def IndexOf(self, item: float, index: int, count: int) -> int: ...
    def Insert(self, index: int, item: float) -> None: ...
    def InsertRange(self, index: int, collection: Iterable[float]) -> None: ...
    def InterpolateCatmullRom(self, t: float) -> float: ...
    def InterpolateCosine(self, t: float) -> float: ...
    def InterpolateCubic(self, t: float) -> float: ...
    def InterpolateLinear(self, t: float) -> float: ...
    def InterpolateNearestNeighbour(self, t: float) -> float: ...
    @overload
    def LastIndexOf(self, item: float) -> int: ...
    @overload
    def LastIndexOf(self, item: float, index: int) -> int: ...
    @overload
    def LastIndexOf(self, item: float, index: int, count: int) -> int: ...
    def RemapIndex(self, index: int) -> int: ...
    def Remove(self, item: float) -> bool: ...
    def RemoveAll(self, match: Predicate) -> int: ...
    def RemoveAt(self, index: int) -> None: ...
    def RemoveNulls(self) -> int: ...
    def RemoveRange(self, index: int, count: int) -> None: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    def Reverse(self, index: int, count: int) -> None: ...
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @Cyclical.setter
    def Cyclical(self) -> MutableSequence[bool]: ...
    @First.setter
    def First(self) -> MutableSequence[float]: ...
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @Last.setter
    def Last(self) -> MutableSequence[float]: ...
    @overload
    def Sort(self) -> None: ...
    @overload
    def Sort(self, keys: Iterable[float]) -> None: ...
    @overload
    def Sort(self, keys: Iterable[int]) -> None: ...
    @overload
    def Sort(self, comparer: IComparer) -> None: ...
    @overload
    def Sort(self, comparison: Comparison) -> None: ...
    @overload
    def Sort(self, index: int, count: int, comparer: IComparer) -> None: ...
    def ToArray(self) -> Iterable[float]: ...
    def ToString(self) -> str: ...
    def TrimExcess(self) -> None: ...
    def TrueForAll(self, match: Predicate) -> bool: ...


class Interval:
    @overload
    def __init__(self, other: Interval): ...
    @overload
    def __init__(self, t0: float, t1: float): ...
    def CompareTo(self, other: Interval) -> int: ...
    def EpsilonEquals(self, other: Interval, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: Interval) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @staticmethod
    def FromIntersection(a: Interval, b: Interval) -> Interval: ...
    @staticmethod
    def FromUnion(a: Interval, b: Interval) -> Interval: ...
    @property
    def IsDecreasing(self) -> bool: ...
    @property
    def IsIncreasing(self) -> bool: ...
    @property
    def IsSingleton(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> Sequence[int]: ...
    @property
    def Length(self) -> float: ...
    @property
    def Max(self) -> float: ...
    @property
    def Mid(self) -> float: ...
    @property
    def Min(self) -> float: ...
    @property
    def T0(self) -> float: ...
    @property
    def T1(self) -> float: ...
    @property
    def Unset() -> Interval: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def Grow(self, value: float) -> None: ...
    @overload
    def IncludesInterval(self, interval: Interval) -> bool: ...
    @overload
    def IncludesInterval(self, interval: Interval, strict: bool) -> bool: ...
    @overload
    def IncludesParameter(self, t: float) -> bool: ...
    @overload
    def IncludesParameter(self, t: float, strict: bool) -> bool: ...
    def MakeIncreasing(self) -> None: ...
    def NormalizedIntervalAt(self, intervalParameter: Interval) -> Interval: ...
    def NormalizedParameterAt(self, intervalParameter: float) -> float: ...
    @overload
    def __add__(interval: Interval, number: float) -> Interval: ...
    @overload
    def __radd__(interval: Interval, number: float) -> Interval: ...
    def __eq__(a: Interval, b: Interval) -> bool: ...
    def __gt__(a: Interval, b: Interval) -> bool: ...
    def __ge__(a: Interval, b: Interval) -> bool: ...
    def __ne__(a: Interval, b: Interval) -> bool: ...
    def __lt__(a: Interval, b: Interval) -> bool: ...
    def __le__(a: Interval, b: Interval) -> bool: ...
    @overload
    def __sub__(interval: Interval, number: float) -> Interval: ...
    @overload
    def __rsub__(interval: Interval, number: float) -> Interval: ...
    def ParameterAt(self, normalizedParameter: float) -> float: ...
    def ParameterIntervalAt(self, normalizedInterval: Interval) -> Interval: ...
    def Reverse(self) -> None: ...
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @T0.setter
    def T0(self) -> MutableSequence[float]: ...
    @T1.setter
    def T1(self) -> MutableSequence[float]: ...
    def Swap(self) -> None: ...
    def ToString(self) -> str: ...


class InvalidDimensionStyleIdException:
    def __init__(self, msg: str): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @property
    def HResult(self) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...
    def GetBaseException(self) -> Exception: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> Type: ...
    @overload
    def GetType(self) -> Type: ...
    @HelpLink.setter
    def HelpLink(self) -> MutableSequence[str]: ...
    @Source.setter
    def Source(self) -> MutableSequence[str]: ...
    def ToString(self) -> str: ...


class IsoStatus(Enum):
    # None = 0
    X = 1
    Y = 2
    West = 3
    South = 4
    East = 5
    North = 6


class KnotStyle(Enum):
    Unknown = 0
    Uniform = 1
    QuasiUniform = 2
    PiecewiseBezier = 3
    ClampedEnd = 4
    NonUniform = 5


from ..DocObjects import DimensionStyle
from ..DocObjects import TextHorizontalAlignment
from ..DocObjects import TextVerticalAlignment
from ..DocObjects import ArrowType
from ..DocObjects import LeaderCurveStyle
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import LengthDisplay
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Leader(AnnotationBase):
    def __init__(self): ...
    def ClearPropertyOverrides(self) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @staticmethod
    def Create(text: str, plane: Plane, dimstyle: DimensionStyle, points: Iterable[Point3d]) -> Leader: ...
    @staticmethod
    def CreateWithRichText(richText: str, plane: Plane, dimstyle: DimensionStyle, points: Iterable[Point3d]) -> Leader: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def Curve(self) -> NurbsCurve: ...
    @property
    def DecimalSeparator(self) -> Char: ...
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def DimensionScale(self) -> float: ...
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @property
    def DimensionStyleId(self) -> Guid: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def DrawForward(self) -> bool: ...
    @property
    def DrawTextFrame(self) -> bool: ...
    @property
    def FirstCharFont(self) -> Font: ...
    @property
    def Font(self) -> Font: ...
    @property
    def FontIndex(self) -> int: ...
    @property
    def FormatWidth(self) -> float: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def LeaderArrowBlockId(self) -> Guid: ...
    @property
    def LeaderArrowSize(self) -> float: ...
    @property
    def LeaderArrowType(self) -> ArrowType: ...
    @property
    def LeaderContentAngleStyle(self) -> LeaderContentAngleStyle: ...
    @property
    def LeaderCurveStyle(self) -> LeaderCurveStyle: ...
    @property
    def LeaderHasLanding(self) -> bool: ...
    @property
    def LeaderLandingLength(self) -> float: ...
    @property
    def LeaderTextHorizontalAlignment(self) -> TextHorizontalAlignment: ...
    @property
    def LeaderTextVerticalAlignment(self) -> TextVerticalAlignment: ...
    @property
    def MaskColor(self) -> Color: ...
    @property
    def MaskColorSource(self) -> MaskType: ...
    @property
    def MaskEnabled(self) -> bool: ...
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @property
    def MaskOffset(self) -> float: ...
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @property
    def PlainText(self) -> str: ...
    @property
    def PlainTextWithFields(self) -> str: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Points2D(self) -> Iterable[Point2d]: ...
    @property
    def Points3D(self) -> Iterable[Point3d]: ...
    @property
    def RichText(self) -> str: ...
    @property
    def Text(self) -> str: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @property
    def TextHeight(self) -> float: ...
    @property
    def TextIsWrapped(self) -> bool: ...
    @property
    def TextModelWidth(self) -> float: ...
    @property
    def TextRotationDegrees(self) -> float: ...
    @property
    def TextRotationRadians(self) -> float: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsAllBold(self) -> bool: ...
    def IsAllItalic(self) -> bool: ...
    def IsAllUnderlined(self) -> bool: ...
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DecimalSeparator.setter
    def DecimalSeparator(self) -> MutableSequence[Char]: ...
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DimensionScale.setter
    def DimensionScale(self) -> MutableSequence[float]: ...
    @DimensionStyleId.setter
    def DimensionStyleId(self) -> MutableSequence[Guid]: ...
    @DrawForward.setter
    def DrawForward(self) -> MutableSequence[bool]: ...
    @DrawTextFrame.setter
    def DrawTextFrame(self) -> MutableSequence[bool]: ...
    @Font.setter
    def Font(self) -> MutableSequence[Font]: ...
    @FontIndex.setter
    def FontIndex(self) -> MutableSequence[int]: ...
    @FormatWidth.setter
    def FormatWidth(self) -> MutableSequence[float]: ...
    @LeaderArrowBlockId.setter
    def LeaderArrowBlockId(self) -> MutableSequence[Guid]: ...
    @LeaderArrowSize.setter
    def LeaderArrowSize(self) -> MutableSequence[float]: ...
    @LeaderArrowType.setter
    def LeaderArrowType(self) -> MutableSequence[ArrowType]: ...
    @LeaderContentAngleStyle.setter
    def LeaderContentAngleStyle(self) -> MutableSequence[LeaderContentAngleStyle]: ...
    @LeaderCurveStyle.setter
    def LeaderCurveStyle(self) -> MutableSequence[LeaderCurveStyle]: ...
    @LeaderHasLanding.setter
    def LeaderHasLanding(self) -> MutableSequence[bool]: ...
    @LeaderLandingLength.setter
    def LeaderLandingLength(self) -> MutableSequence[float]: ...
    @LeaderTextHorizontalAlignment.setter
    def LeaderTextHorizontalAlignment(self) -> MutableSequence[TextHorizontalAlignment]: ...
    @LeaderTextVerticalAlignment.setter
    def LeaderTextVerticalAlignment(self) -> MutableSequence[TextVerticalAlignment]: ...
    @MaskColor.setter
    def MaskColor(self) -> MutableSequence[Color]: ...
    @MaskColorSource.setter
    def MaskColorSource(self) -> MutableSequence[MaskType]: ...
    @MaskEnabled.setter
    def MaskEnabled(self) -> MutableSequence[bool]: ...
    @MaskFrame.setter
    def MaskFrame(self) -> MutableSequence[MaskFrame]: ...
    @MaskOffset.setter
    def MaskOffset(self) -> MutableSequence[float]: ...
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self) -> MutableSequence[bool]: ...
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self) -> MutableSequence[DimensionStyle]: ...
    @PlainText.setter
    def PlainText(self) -> MutableSequence[str]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @Points2D.setter
    def Points2D(self) -> MutableSequence[Iterable[Point2d]]: ...
    @Points3D.setter
    def Points3D(self) -> MutableSequence[Iterable[Point3d]]: ...
    @RichText.setter
    def RichText(self) -> MutableSequence[str]: ...
    @Text.setter
    def Text(self) -> MutableSequence[str]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextHeight.setter
    def TextHeight(self) -> MutableSequence[float]: ...
    @TextIsWrapped.setter
    def TextIsWrapped(self) -> MutableSequence[bool]: ...
    @TextRotationDegrees.setter
    def TextRotationDegrees(self) -> MutableSequence[float]: ...
    @TextRotationRadians.setter
    def TextRotationRadians(self) -> MutableSequence[float]: ...
    def SetBold(self, set_on: bool) -> bool: ...
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    def SetItalic(self, set_on: bool) -> bool: ...
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    def SetUnderline(self, set_on: bool) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    def WrapText(self) -> None: ...


class LengthMassProperties:
    def CentroidCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    def CentroidCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    @staticmethod
    def Compute(curve: Curve) -> LengthMassProperties: ...
    @overload
    @staticmethod
    def Compute(curves: Iterable[Curve]) -> LengthMassProperties: ...
    @overload
    @staticmethod
    def Compute(curve: Curve, length: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> LengthMassProperties: ...
    @overload
    @staticmethod
    def Compute(curves: Iterable[Curve], length: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> LengthMassProperties: ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Centroid(self) -> Point3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @property
    def CentroidError(self) -> Vector3d: ...
    @property
    def Length(self) -> float: ...
    @property
    def LengthError(self) -> float: ...
    @property
    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...
    def WorldCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    def WorldCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...


from ..Render import Sun
from ..DocObjects import CoordinateSystem
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Light(GeometryBase):
    def __init__(self): ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def CreateSunLight(sun: Sun) -> Light: ...
    @overload
    @staticmethod
    def CreateSunLight(northAngleDegrees: float, azimuthDegrees: float, altitudeDegrees: float) -> Light: ...
    @overload
    @staticmethod
    def CreateSunLight(northAngleDegrees: float, when: DateTime, latitudeDegrees: float, longitudeDegrees: float) -> Light: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Ambient(self) -> Color: ...
    @property
    def AttenuationType(self) -> Attenuation: ...
    @property
    def AttenuationVector(self) -> Vector3d: ...
    @property
    def CoordinateSystem(self) -> CoordinateSystem: ...
    @property
    def Diffuse(self) -> Color: ...
    @property
    def Direction(self) -> Vector3d: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def HotSpot(self) -> float: ...
    @property
    def Id(self) -> Guid: ...
    @property
    def Intensity(self) -> float: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDirectionalLight(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsEnabled(self) -> bool: ...
    @property
    def IsLinearLight(self) -> bool: ...
    @property
    def IsPointLight(self) -> bool: ...
    @property
    def IsRectangularLight(self) -> bool: ...
    @property
    def IsSpotLight(self) -> bool: ...
    @property
    def IsSunLight(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Length(self) -> Vector3d: ...
    @property
    def LightStyle(self) -> LightStyle: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def Name(self) -> str: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PerpendicularDirection(self) -> Vector3d: ...
    @property
    def PowerCandela(self) -> float: ...
    @property
    def PowerLumens(self) -> float: ...
    @property
    def PowerWatts(self) -> float: ...
    @property
    def ShadowIntensity(self) -> float: ...
    @property
    def Specular(self) -> Color: ...
    @property
    def SpotAngleRadians(self) -> float: ...
    @property
    def SpotExponent(self) -> float: ...
    @property
    def SpotLightShadowIntensity(self) -> float: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def Width(self) -> Vector3d: ...
    def GetAttenuation(self, d: float) -> float: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetSpotLightRadii(self) -> Tuple[bool, float, float]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Ambient.setter
    def Ambient(self) -> MutableSequence[Color]: ...
    @AttenuationType.setter
    def AttenuationType(self) -> MutableSequence[Attenuation]: ...
    @AttenuationVector.setter
    def AttenuationVector(self) -> MutableSequence[Vector3d]: ...
    @Diffuse.setter
    def Diffuse(self) -> MutableSequence[Color]: ...
    @Direction.setter
    def Direction(self) -> MutableSequence[Vector3d]: ...
    @HotSpot.setter
    def HotSpot(self) -> MutableSequence[float]: ...
    @Id.setter
    def Id(self) -> MutableSequence[Guid]: ...
    @Intensity.setter
    def Intensity(self) -> MutableSequence[float]: ...
    @IsEnabled.setter
    def IsEnabled(self) -> MutableSequence[bool]: ...
    @Length.setter
    def Length(self) -> MutableSequence[Vector3d]: ...
    @LightStyle.setter
    def LightStyle(self) -> MutableSequence[LightStyle]: ...
    @Location.setter
    def Location(self) -> MutableSequence[Point3d]: ...
    @Name.setter
    def Name(self) -> MutableSequence[str]: ...
    @PowerCandela.setter
    def PowerCandela(self) -> MutableSequence[float]: ...
    @PowerLumens.setter
    def PowerLumens(self) -> MutableSequence[float]: ...
    @PowerWatts.setter
    def PowerWatts(self) -> MutableSequence[float]: ...
    @ShadowIntensity.setter
    def ShadowIntensity(self) -> MutableSequence[float]: ...
    @Specular.setter
    def Specular(self) -> MutableSequence[Color]: ...
    @SpotAngleRadians.setter
    def SpotAngleRadians(self) -> MutableSequence[float]: ...
    @SpotExponent.setter
    def SpotExponent(self) -> MutableSequence[float]: ...
    @SpotLightShadowIntensity.setter
    def SpotLightShadowIntensity(self) -> MutableSequence[float]: ...
    @Width.setter
    def Width(self) -> MutableSequence[Vector3d]: ...
    def SetAttenuation(self, a0: float, a1: float, a2: float) -> None: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class LightStyle(Enum):
    # None = 0
    CameraDirectional = 4
    CameraPoint = 5
    CameraSpot = 6
    WorldDirectional = 7
    WorldPoint = 8
    WorldSpot = 9
    Ambient = 10
    WorldLinear = 11
    WorldRectangular = 12


class Line:
    @overload
    def __init__(self, from_: Point3d, to: Point3d): ...
    @overload
    def __init__(self, start: Point3d, span: Vector3d): ...
    @overload
    def __init__(self, start: Point3d, direction: Vector3d, length: float): ...
    @overload
    def __init__(self, x0: float, y0: float, z0: float, x1: float, y1: float, z1: float): ...
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    def ClosestPoint(self, testPoint: Point3d, limitToFiniteSegment: bool) -> Point3d: ...
    def DistanceTo(self, testPoint: Point3d, limitToFiniteSegment: bool) -> float: ...
    def EpsilonEquals(self, other: Line, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: Line) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    def Extend(self, startLength: float, endLength: float) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: Box) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: Box, additionalLength: float) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox, additionalLength: float) -> bool: ...
    def Flip(self) -> None: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Direction(self) -> Vector3d: ...
    @property
    def From(self) -> Point3d: ...
    @property
    def FromX(self) -> float: ...
    @property
    def FromY(self) -> float: ...
    @property
    def FromZ(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Length(self) -> float: ...
    @property
    def To(self) -> Point3d: ...
    @property
    def ToX(self) -> float: ...
    @property
    def ToY(self) -> float: ...
    @property
    def ToZ(self) -> float: ...
    @property
    def UnitTangent(self) -> Vector3d: ...
    @property
    def Unset() -> Line: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    def MaximumDistanceTo(self, testLine: Line) -> float: ...
    @overload
    def MaximumDistanceTo(self, testPoint: Point3d) -> float: ...
    @overload
    def MinimumDistanceTo(self, testLine: Line) -> float: ...
    @overload
    def MinimumDistanceTo(self, testPoint: Point3d) -> float: ...
    def __eq__(a: Line, b: Line) -> bool: ...
    def __ne__(a: Line, b: Line) -> bool: ...
    def PointAt(self, t: float) -> Point3d: ...
    def PointAtLength(self, distance: float) -> Point3d: ...
    @From.setter
    def From(self) -> MutableSequence[Point3d]: ...
    @FromX.setter
    def FromX(self) -> MutableSequence[float]: ...
    @FromY.setter
    def FromY(self) -> MutableSequence[float]: ...
    @FromZ.setter
    def FromZ(self) -> MutableSequence[float]: ...
    @Length.setter
    def Length(self) -> MutableSequence[float]: ...
    @To.setter
    def To(self) -> MutableSequence[Point3d]: ...
    @ToX.setter
    def ToX(self) -> MutableSequence[float]: ...
    @ToY.setter
    def ToY(self) -> MutableSequence[float]: ...
    @ToZ.setter
    def ToZ(self) -> MutableSequence[float]: ...
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @staticmethod
    def TryCreateBetweenCurves(curve0: Curve, curve1: Curve, t0: float, t1: float, perpendicular0: bool, perpendicular1: bool) -> Tuple[bool, float, float, Line]: ...
    @staticmethod
    def TryFitLineToPoints(points: Iterable[Point3d]) -> Tuple[bool, Line]: ...
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...


from ..DocObjects import DimensionStyle
from ..DocObjects import ViewportInfo
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ArrowType
from ..DocObjects import ZeroSuppression
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class LinearDimension(Dimension):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, dimensionPlane: Plane, extensionLine1End: Point2d, extensionLine2End: Point2d, pointOnDimensionLine: Point2d): ...
    def ClearPropertyOverrides(self) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @staticmethod
    def Create(dimtype: AnnotationType, dimStyle: DimensionStyle, plane: Plane, horizontal: Vector3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d, rotationInPlane: float) -> LinearDimension: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @staticmethod
    def FromPoints(extensionLine1End: Point3d, extensionLine2End: Point3d, pointOnDimensionLine: Point3d) -> LinearDimension: ...
    @property
    def Aligned(self) -> bool: ...
    @property
    def AlternateBelowLine(self) -> bool: ...
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def AltLengthFactor(self) -> float: ...
    @property
    def AltLengthResolution(self) -> int: ...
    @property
    def AltLengthRoundoff(self) -> float: ...
    @property
    def AltPrefix(self) -> str: ...
    @property
    def AltSuffix(self) -> str: ...
    @property
    def AltToleranceResolution(self) -> int: ...
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @property
    def Arrowhead1End(self) -> Point2d: ...
    @property
    def Arrowhead2End(self) -> Point2d: ...
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @property
    def ArrowSize(self) -> float: ...
    @property
    def BaselineSpacing(self) -> float: ...
    @property
    def CentermarkSize(self) -> float: ...
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @property
    def DecimalSeparator(self) -> Char: ...
    @property
    def DetailMeasured(self) -> Guid: ...
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def DimensionLineExtension(self) -> float: ...
    @property
    def DimensionLinePoint(self) -> Point2d: ...
    @property
    def DimensionScale(self) -> float: ...
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @property
    def DimensionStyleId(self) -> Guid: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def DistanceBetweenArrowTips(self) -> float: ...
    @property
    def DistanceScale(self) -> float: ...
    @property
    def DrawForward(self) -> bool: ...
    @property
    def DrawTextFrame(self) -> bool: ...
    @property
    def ExtensionLine1End(self) -> Point2d: ...
    @property
    def ExtensionLine2End(self) -> Point2d: ...
    @property
    def ExtensionLineExtension(self) -> float: ...
    @property
    def ExtensionLineOffset(self) -> float: ...
    @property
    def FirstCharFont(self) -> Font: ...
    @property
    def FixedExtensionLength(self) -> float: ...
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @property
    def Font(self) -> Font: ...
    @property
    def FontIndex(self) -> int: ...
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @property
    def ForceDimLine(self) -> bool: ...
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @property
    def FormatWidth(self) -> float: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def LengthFactor(self) -> float: ...
    @property
    def LengthResolution(self) -> int: ...
    @property
    def LengthRoundoff(self) -> float: ...
    @property
    def MaskColor(self) -> Color: ...
    @property
    def MaskColorSource(self) -> MaskType: ...
    @property
    def MaskEnabled(self) -> bool: ...
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @property
    def MaskOffset(self) -> float: ...
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @property
    def NumericValue(self) -> float: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @property
    def PlainText(self) -> str: ...
    @property
    def PlainTextWithFields(self) -> str: ...
    @property
    def PlainUserText(self) -> str: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Prefix(self) -> str: ...
    @property
    def RichText(self) -> str: ...
    @property
    def Suffix(self) -> str: ...
    @property
    def SuppressExtension1(self) -> bool: ...
    @property
    def SuppressExtension2(self) -> bool: ...
    @property
    def Text(self) -> str: ...
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @property
    def TextFit(self) -> TextFit: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @property
    def TextHeight(self) -> float: ...
    @property
    def TextIsWrapped(self) -> bool: ...
    @property
    def TextLocation(self) -> TextLocation: ...
    @property
    def TextModelWidth(self) -> float: ...
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @property
    def TextPosition(self) -> Point2d: ...
    @property
    def TextRotation(self) -> float: ...
    @property
    def TextRotationDegrees(self) -> float: ...
    @property
    def TextRotationRadians(self) -> float: ...
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @property
    def ToleranceHeightScale(self) -> float: ...
    @property
    def ToleranceLowerValue(self) -> float: ...
    @property
    def ToleranceResolution(self) -> int: ...
    @property
    def ToleranceUpperValue(self) -> float: ...
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d]: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Iterable[Line]]: ...
    def GetDistanceDisplayText(self, unitsystem: UnitSystem, style: DimensionStyle) -> str: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    def GetTextRectangle(self) -> Tuple[bool, Iterable[Point3d]]: ...
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsAllBold(self) -> bool: ...
    def IsAllItalic(self) -> bool: ...
    def IsAllUnderlined(self) -> bool: ...
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Aligned.setter
    def Aligned(self) -> MutableSequence[bool]: ...
    @AlternateBelowLine.setter
    def AlternateBelowLine(self) -> MutableSequence[bool]: ...
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @AltLengthFactor.setter
    def AltLengthFactor(self) -> MutableSequence[float]: ...
    @AltLengthResolution.setter
    def AltLengthResolution(self) -> MutableSequence[int]: ...
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self) -> MutableSequence[float]: ...
    @AltPrefix.setter
    def AltPrefix(self) -> MutableSequence[str]: ...
    @AltSuffix.setter
    def AltSuffix(self) -> MutableSequence[str]: ...
    @AltToleranceResolution.setter
    def AltToleranceResolution(self) -> MutableSequence[int]: ...
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self) -> MutableSequence[bool]: ...
    @AltZeroSuppression.setter
    def AltZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    @AnnotationType.setter
    def AnnotationType(self) -> MutableSequence[AnnotationType]: ...
    @ArrowBlockId1.setter
    def ArrowBlockId1(self) -> MutableSequence[Guid]: ...
    @ArrowBlockId2.setter
    def ArrowBlockId2(self) -> MutableSequence[Guid]: ...
    @ArrowFit.setter
    def ArrowFit(self) -> MutableSequence[ArrowFit]: ...
    @ArrowheadType1.setter
    def ArrowheadType1(self) -> MutableSequence[ArrowType]: ...
    @ArrowheadType2.setter
    def ArrowheadType2(self) -> MutableSequence[ArrowType]: ...
    @ArrowSize.setter
    def ArrowSize(self) -> MutableSequence[float]: ...
    @BaselineSpacing.setter
    def BaselineSpacing(self) -> MutableSequence[float]: ...
    @CentermarkSize.setter
    def CentermarkSize(self) -> MutableSequence[float]: ...
    @CentermarkStyle.setter
    def CentermarkStyle(self) -> MutableSequence[CenterMarkStyle]: ...
    @DecimalSeparator.setter
    def DecimalSeparator(self) -> MutableSequence[Char]: ...
    @DetailMeasured.setter
    def DetailMeasured(self) -> MutableSequence[Guid]: ...
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DimensionLineExtension.setter
    def DimensionLineExtension(self) -> MutableSequence[float]: ...
    @DimensionLinePoint.setter
    def DimensionLinePoint(self) -> MutableSequence[Point2d]: ...
    @DimensionScale.setter
    def DimensionScale(self) -> MutableSequence[float]: ...
    @DimensionStyleId.setter
    def DimensionStyleId(self) -> MutableSequence[Guid]: ...
    @DistanceScale.setter
    def DistanceScale(self) -> MutableSequence[float]: ...
    @DrawForward.setter
    def DrawForward(self) -> MutableSequence[bool]: ...
    @DrawTextFrame.setter
    def DrawTextFrame(self) -> MutableSequence[bool]: ...
    @ExtensionLine1End.setter
    def ExtensionLine1End(self) -> MutableSequence[Point2d]: ...
    @ExtensionLine2End.setter
    def ExtensionLine2End(self) -> MutableSequence[Point2d]: ...
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self) -> MutableSequence[float]: ...
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self) -> MutableSequence[float]: ...
    @FixedExtensionLength.setter
    def FixedExtensionLength(self) -> MutableSequence[float]: ...
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self) -> MutableSequence[bool]: ...
    @Font.setter
    def Font(self) -> MutableSequence[Font]: ...
    @FontIndex.setter
    def FontIndex(self) -> MutableSequence[int]: ...
    @ForceArrowPosition.setter
    def ForceArrowPosition(self) -> MutableSequence[ForceArrow]: ...
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self) -> MutableSequence[bool]: ...
    @ForceDimLine.setter
    def ForceDimLine(self) -> MutableSequence[bool]: ...
    @ForceTextPosition.setter
    def ForceTextPosition(self) -> MutableSequence[ForceText]: ...
    @FormatWidth.setter
    def FormatWidth(self) -> MutableSequence[float]: ...
    @LengthFactor.setter
    def LengthFactor(self) -> MutableSequence[float]: ...
    @LengthResolution.setter
    def LengthResolution(self) -> MutableSequence[int]: ...
    @LengthRoundoff.setter
    def LengthRoundoff(self) -> MutableSequence[float]: ...
    @MaskColor.setter
    def MaskColor(self) -> MutableSequence[Color]: ...
    @MaskColorSource.setter
    def MaskColorSource(self) -> MutableSequence[MaskType]: ...
    @MaskEnabled.setter
    def MaskEnabled(self) -> MutableSequence[bool]: ...
    @MaskFrame.setter
    def MaskFrame(self) -> MutableSequence[MaskFrame]: ...
    @MaskOffset.setter
    def MaskOffset(self) -> MutableSequence[float]: ...
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self) -> MutableSequence[bool]: ...
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self) -> MutableSequence[DimensionStyle]: ...
    @PlainText.setter
    def PlainText(self) -> MutableSequence[str]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @Prefix.setter
    def Prefix(self) -> MutableSequence[str]: ...
    @RichText.setter
    def RichText(self) -> MutableSequence[str]: ...
    @Suffix.setter
    def Suffix(self) -> MutableSequence[str]: ...
    @SuppressExtension1.setter
    def SuppressExtension1(self) -> MutableSequence[bool]: ...
    @SuppressExtension2.setter
    def SuppressExtension2(self) -> MutableSequence[bool]: ...
    @Text.setter
    def Text(self) -> MutableSequence[str]: ...
    @TextAngleType.setter
    def TextAngleType(self) -> MutableSequence[LeaderContentAngleStyle]: ...
    @TextFit.setter
    def TextFit(self) -> MutableSequence[TextFit]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextHeight.setter
    def TextHeight(self) -> MutableSequence[float]: ...
    @TextIsWrapped.setter
    def TextIsWrapped(self) -> MutableSequence[bool]: ...
    @TextLocation.setter
    def TextLocation(self) -> MutableSequence[TextLocation]: ...
    @TextOrientation.setter
    def TextOrientation(self) -> MutableSequence[TextOrientation]: ...
    @TextPosition.setter
    def TextPosition(self) -> MutableSequence[Point2d]: ...
    @TextRotation.setter
    def TextRotation(self) -> MutableSequence[float]: ...
    @TextRotationDegrees.setter
    def TextRotationDegrees(self) -> MutableSequence[float]: ...
    @TextRotationRadians.setter
    def TextRotationRadians(self) -> MutableSequence[float]: ...
    @ToleranceFormat.setter
    def ToleranceFormat(self) -> MutableSequence[ToleranceDisplayFormat]: ...
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self) -> MutableSequence[float]: ...
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self) -> MutableSequence[float]: ...
    @ToleranceResolution.setter
    def ToleranceResolution(self) -> MutableSequence[int]: ...
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self) -> MutableSequence[float]: ...
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self) -> MutableSequence[bool]: ...
    @ZeroSuppression.setter
    def ZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetBold(self, set_on: bool) -> bool: ...
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    def SetItalic(self, set_on: bool) -> bool: ...
    def SetLocations(self, extensionLine1End: Point2d, extensionLine2End: Point2d, pointOnDimensionLine: Point2d) -> None: ...
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    def SetUnderline(self, set_on: bool) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    def WrapText(self) -> None: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class LineCurve(Curve):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: LineCurve): ...
    @overload
    def __init__(self, line: Line): ...
    @overload
    def __init__(self, from_: Point2d, to: Point2d): ...
    @overload
    def __init__(self, from_: Point3d, to: Point3d): ...
    @overload
    def __init__(self, line: Line, t0: float, t1: float): ...
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    def Dispose(self) -> None: ...
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateCurve(self) -> Curve: ...
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @property
    def Degree(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Domain(self) -> Interval: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsPeriodic(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Line(self) -> Line: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PointAtEnd(self) -> Point3d: ...
    @property
    def PointAtStart(self) -> Point3d: ...
    @property
    def SpanCount(self) -> int: ...
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    def MakeClosed(self, tolerance: float) -> bool: ...
    def MakeDeformable(self) -> bool: ...
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    def PointAt(self, t: float) -> Point3d: ...
    def PointAtLength(self, length: float) -> Point3d: ...
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Domain.setter
    def Domain(self) -> MutableSequence[Interval]: ...
    @Line.setter
    def Line(self) -> MutableSequence[Line]: ...
    def SetEndPoint(self, point: Point3d) -> bool: ...
    def SetStartPoint(self, point: Point3d) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    def TorsionAt(self, t: float) -> float: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class LoftType(Enum):
    Normal = 0
    Loose = 1
    Tight = 2
    Straight = 3
    Developable = 4
    Uniform = 5


class Matrix:
    @overload
    def __init__(self, xform: Transform): ...
    @overload
    def __init__(self, rowCount: int, columnCount: int): ...
    def BackSolve(self, zeroTolerance: float, b: Iterable[float]) -> Iterable[float]: ...
    def BackSolvePoints(self, zeroTolerance: float, b: Iterable[Point3d]) -> Iterable[Point3d]: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> Matrix: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ColumnCount(self) -> int: ...
    @property
    def IsColumnOrthogonal(self) -> bool: ...
    @property
    def IsColumnOrthoNormal(self) -> bool: ...
    @property
    def IsRowOrthogonal(self) -> bool: ...
    @property
    def IsRowOrthoNormal(self) -> bool: ...
    @property
    def IsSquare(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> Sequence[int]: ...
    @property
    def RowCount(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def Invert(self, zeroTolerance: float) -> bool: ...
    def __add__(a: Matrix, b: Matrix) -> Matrix: ...
    def __mul__(a: Matrix, b: Matrix) -> Matrix: ...
    @overload
    def RowReduce(self, zeroTolerance: float, b: Iterable[Point3d]) -> Tuple[int, float]: ...
    @overload
    def RowReduce(self, zeroTolerance: float) -> Tuple[int, float, float]: ...
    @overload
    def RowReduce(self, zeroTolerance: float, b: Iterable[float]) -> Tuple[int, float]: ...
    def Scale(self, s: float) -> None: ...
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    def SetDiagonal(self, d: float) -> None: ...
    def SwapColumns(self, columnA: int, columnB: int) -> bool: ...
    def SwapRows(self, rowA: int, rowB: int) -> bool: ...
    def ToString(self) -> str: ...
    def Transpose(self) -> bool: ...
    def Zero(self) -> None: ...


class MeasuredDirection(Enum):
    Unset = 0
    Xaxis = 1
    Yaxis = 2


from ..Render import TextureMapping
from ..FileIO import TextLog
from .MeshRefinements import LoopFormula
from .MeshRefinements import RefinementSettings
from .Collections import MeshVertexList
from .Collections import MeshTopologyVertexList
from .Collections import MeshTopologyEdgeList
from .Collections import MeshVertexNormalList
from .Collections import MeshFaceList
from .Collections import MeshNgonList
from .Collections import MeshFaceNormalList
from .Collections import MeshVertexColorList
from .Collections import MeshTextureCoordinateList
from .Collections import MeshVertexStatusList
from ..Render import CachedTextureCoordinates
from ..Display import RhinoViewport
from ..DocObjects import ViewportInfo
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Mesh(GeometryBase):
    def __init__(self): ...
    @overload
    def Append(self, other: Mesh) -> None: ...
    @overload
    def Append(self, meshes: Iterable[Mesh]) -> None: ...
    def Check(self, textLog: TextLog, parameters: MeshCheckParameters) -> Tuple[bool, MeshCheckParameters]: ...
    def ClearSurfaceData(self) -> None: ...
    def ClearTextureData(self) -> None: ...
    def ClosestMeshPoint(self, testPoint: Point3d, maximumDistance: float) -> MeshPoint: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[int, Point3d]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[int, Point3d, Vector3d]: ...
    def CollapseFacesByArea(self, lessThanArea: float, greaterThanArea: float) -> int: ...
    def CollapseFacesByByAspectRatio(self, aspectRatio: float) -> int: ...
    def CollapseFacesByEdgeLength(self, bGreaterThan: bool, edgeLength: float) -> int: ...
    @overload
    def ColorAt(self, meshPoint: MeshPoint) -> Color: ...
    @overload
    def ColorAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Color: ...
    def Compact(self) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def ComputeAutoCreaseInformation(self) -> Iterable[Byte]: ...
    @overload
    @staticmethod
    def ComputeThickness(meshes: Iterable[Mesh], maximumThickness: float) -> Iterable[MeshThicknessMeasurement]: ...
    @overload
    @staticmethod
    def ComputeThickness(meshes: Iterable[Mesh], maximumThickness: float, cancelToken: CancellationToken) -> Iterable[MeshThicknessMeasurement]: ...
    @overload
    @staticmethod
    def ComputeThickness(meshes: Iterable[Mesh], maximumThickness: float, sharpAngle: float, cancelToken: CancellationToken) -> Iterable[MeshThicknessMeasurement]: ...
    def CopyFrom(self, other: Mesh) -> None: ...
    @staticmethod
    def CreateBooleanDifference(firstSet: Iterable[Mesh], secondSet: Iterable[Mesh]) -> Iterable[Mesh]: ...
    @staticmethod
    def CreateBooleanIntersection(firstSet: Iterable[Mesh], secondSet: Iterable[Mesh]) -> Iterable[Mesh]: ...
    @staticmethod
    def CreateBooleanSplit(meshesToSplit: Iterable[Mesh], meshSplitters: Iterable[Mesh]) -> Iterable[Mesh]: ...
    @staticmethod
    def CreateBooleanUnion(meshes: Iterable[Mesh]) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def CreateContourCurves(meshToContour: Mesh, sectionPlane: Plane, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateContourCurves(meshToContour: Mesh, contourStart: Point3d, contourEnd: Point3d, interval: float, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateFromBox(box: BoundingBox, xCount: int, yCount: int, zCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromBox(corners: Iterable[Point3d], xCount: int, yCount: int, zCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromBox(box: Box, xCount: int, yCount: int, zCount: int) -> Mesh: ...
    @staticmethod
    def CreateFromBrep(brep: Brep, meshingParameters: MeshingParameters) -> Iterable[Mesh]: ...
    @staticmethod
    def CreateFromClosedPolyline(polyline: Polyline) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone, vertical: int, around: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone, vertical: int, around: int, solid: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone, vertical: int, around: int, solid: bool, quadCaps: bool) -> Mesh: ...
    @staticmethod
    def CreateFromCurveExtrusion(curve: Curve, direction: Vector3d, parameters: MeshingParameters, boundingBox: BoundingBox) -> Mesh: ...
    @staticmethod
    def CreateFromCurvePipe(curve: Curve, radius: float, segments: int, accuracy: int, capType: MeshPipeCapStyle, faceted: bool, intervals: Iterable[Interval]) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool, quadCaps: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool, circumscribe: bool, quadCaps: bool) -> Mesh: ...
    @staticmethod
    def CreateFromFilteredFaceList(original: Mesh, inclusion: Iterable[bool]) -> Mesh: ...
    @staticmethod
    def CreateFromIterativeCleanup(meshes: Iterable[Mesh], tolerance: float) -> Iterable[Mesh]: ...
    @staticmethod
    def CreateFromLines(lines: Iterable[Curve], maxFaceValence: int, tolerance: float) -> Mesh: ...
    @staticmethod
    def CreateFromPlanarBoundary(boundary: Curve, parameters: MeshingParameters, tolerance: float) -> Mesh: ...
    @staticmethod
    def CreateFromPlane(plane: Plane, xInterval: Interval, yInterval: Interval, xCount: int, yCount: int) -> Mesh: ...
    @staticmethod
    def CreateFromSphere(sphere: Sphere, xCount: int, yCount: int) -> Mesh: ...
    @staticmethod
    def CreateFromSubD(subd: SubD, displayDensity: int) -> Mesh: ...
    @staticmethod
    def CreateFromSubDControlNet(subd: SubD) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSurface(surface: Surface) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSurface(surface: Surface, meshingParameters: MeshingParameters) -> Mesh: ...
    @staticmethod
    def CreateFromSurfaceControlNet(surface: Surface) -> Mesh: ...
    @staticmethod
    def CreateFromTessellation(points: Iterable[Point3d], edges: Iterable[Iterable[Point3d]], plane: Plane, allowNewVertices: bool) -> Mesh: ...
    @staticmethod
    def CreateFromTorus(torus: Torus, vertical: int, around: int) -> Mesh: ...
    @staticmethod
    def CreateIcoSphere(sphere: Sphere, subdivisions: int) -> Mesh: ...
    def CreatePartitions(self, maximumVertexCount: int, maximumTriangleCount: int) -> bool: ...
    @staticmethod
    def CreatePatch(outerBoundary: Polyline, angleToleranceRadians: float, pullbackSurface: Surface, innerBoundaryCurves: Iterable[Curve], innerBothSideCurves: Iterable[Curve], innerPoints: Iterable[Point3d], trimback: bool, divisions: int) -> Mesh: ...
    @staticmethod
    def CreateQuadSphere(sphere: Sphere, subdivisions: int) -> Mesh: ...
    @staticmethod
    def CreateRefinedCatmullClarkMesh(mesh: Mesh, settings: RefinementSettings) -> Mesh: ...
    @staticmethod
    def CreateRefinedLoopMesh(mesh: Mesh, formula: LoopFormula, settings: RefinementSettings) -> Mesh: ...
    def CreateVertexColorsFromBitmap(self, doc: RhinoDoc, mapping: TextureMapping, xform: Transform, bitmap: Bitmap) -> bool: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def DestroyPartition(self) -> None: ...
    def DestroyTopology(self) -> None: ...
    def DestroyTree(self) -> None: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateMesh(self) -> Mesh: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def EvaluateMeshGeometry(self, surface: Surface) -> bool: ...
    def ExplodeAtUnweldedEdges(self) -> Iterable[Mesh]: ...
    def ExtendSelectionByEdgeRidge(self, preselectedEdges: Iterable[int], newEdge: int, iterative: bool) -> Iterable[int]: ...
    def ExtendSelectionByFaceLoop(self, preselectedFaces: Iterable[int], newFace: int, iterative: bool) -> Iterable[int]: ...
    def ExtractNonManifoldEdges(self, selective: bool) -> Mesh: ...
    def FileHole(self, topologyEdgeIndex: int) -> bool: ...
    def FillHoles(self) -> bool: ...
    @overload
    def Flip(self, vertexNormals: bool, faceNormals: bool, faceOrientation: bool) -> None: ...
    @overload
    def Flip(self, vertexNormals: bool, faceNormals: bool, faceOrientation: bool, ngonsBoundaryDirection: bool) -> None: ...
    @property
    def ComponentStates(self) -> MeshVertexStatusList: ...
    @property
    def DisjointMeshCount(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def FaceNormals(self) -> MeshFaceNormalList: ...
    @property
    def Faces(self) -> MeshFaceList: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasCachedTextureCoordinates(self) -> bool: ...
    @property
    def HasPrincipalCurvatures(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsOriented(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Ngons(self) -> MeshNgonList: ...
    @property
    def Normals(self) -> MeshVertexNormalList: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PartitionCount(self) -> int: ...
    @property
    def TextureCoordinates(self) -> MeshTextureCoordinateList: ...
    @property
    def TopologyEdges(self) -> MeshTopologyEdgeList: ...
    @property
    def TopologyVertices(self) -> MeshTopologyVertexList: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def VertexColors(self) -> MeshVertexColorList: ...
    @property
    def Vertices(self) -> MeshVertexList: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetCachedTextureCoordinates(self, textureMappingId: Guid) -> CachedTextureCoordinates: ...
    def GetHashCode(self) -> int: ...
    def GetNakedEdgePointStatus(self) -> Iterable[bool]: ...
    def GetNakedEdges(self) -> Iterable[Polyline]: ...
    def GetNgonAndFacesCount(self) -> int: ...
    def GetNgonAndFacesEnumerable(self) -> Iterable[MeshNgon]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetOutlines(self, viewport: RhinoViewport) -> Iterable[Polyline]: ...
    @overload
    def GetOutlines(self, plane: Plane) -> Iterable[Polyline]: ...
    @overload
    def GetOutlines(self, viewportInfo: ViewportInfo, plane: Plane) -> Iterable[Polyline]: ...
    def GetPartition(self, which: int) -> MeshPart: ...
    def GetSelfIntersections(self, tolerance: float, overlapsPolylines: bool, overlapsMesh: bool, textLog: TextLog, cancel: CancellationToken, progress: IProgress) -> Tuple[bool, Iterable[Polyline], Iterable[Polyline], Mesh]: ...
    def GetType(self) -> Type: ...
    def GetUnsafeLock(self, writable: bool) -> MeshUnsafeLock: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HealNakedEdges(self, distance: float) -> bool: ...
    @overload
    def IsManifold(self) -> bool: ...
    @overload
    def IsManifold(self, topologicalTest: bool) -> Tuple[bool, bool, bool]: ...
    def IsPointInside(self, point: Point3d, tolerance: float, strictlyIn: bool) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MatchEdges(self, distance: float, rachet: bool) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float) -> bool: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def NormalAt(self, meshPoint: MeshPoint) -> Vector3d: ...
    @overload
    def NormalAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool, direction: Vector3d) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool, direction: Vector3d) -> Tuple[Mesh, List]: ...
    @overload
    def PointAt(self, meshPoint: MeshPoint) -> Point3d: ...
    @overload
    def PointAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Point3d: ...
    def PullCurve(self, curve: Curve, tolerance: float) -> PolylineCurve: ...
    def PullPointsToMesh(self, points: Iterable[Point3d]) -> Iterable[Point3d]: ...
    @overload
    def QuadRemesh(self, parameters: QuadRemeshParameters) -> Mesh: ...
    @overload
    def QuadRemesh(self, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve]) -> Mesh: ...
    @overload
    def QuadRemeshAsync(self, parameters: QuadRemeshParameters, progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    def QuadRemeshAsync(self, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve], progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    def QuadRemeshAsync(self, faceBlocks: Iterable[int], parameters: QuadRemeshParameters, guideCurves: Iterable[Curve], progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    @staticmethod
    def QuadRemeshBrep(brep: Brep, parameters: QuadRemeshParameters) -> Mesh: ...
    @overload
    @staticmethod
    def QuadRemeshBrep(brep: Brep, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve]) -> Mesh: ...
    @overload
    @staticmethod
    def QuadRemeshBrepAsync(brep: Brep, parameters: QuadRemeshParameters, progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    @staticmethod
    def QuadRemeshBrepAsync(brep: Brep, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve], progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    def RebuildNormals(self) -> None: ...
    @overload
    def Reduce(self, parameters: ReduceMeshParameters) -> bool: ...
    @overload
    def Reduce(self, parameters: ReduceMeshParameters, threaded: bool) -> bool: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool) -> bool: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, threaded: bool) -> bool: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: CancellationToken, progress: IProgress) -> Tuple[bool, str]: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: CancellationToken, progress: IProgress, threaded: bool) -> Tuple[bool, str]: ...
    def ReleaseUnsafeLock(self, meshData: MeshUnsafeLock) -> None: ...
    @staticmethod
    def RequireIterativeCleanup(meshes: Iterable[Mesh], tolerance: float) -> bool: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetCachedTextureCoordinates(self, tm: TextureMapping, xf: Transform) -> Tuple[Transform]: ...
    @overload
    def SetTextureCoordinates(self, tm: TextureMapping, xf: Transform, lazy: bool) -> None: ...
    @overload
    def SetTextureCoordinates(self, tm: TextureMapping, xf: Transform, lazy: bool, seamCheck: bool) -> None: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> bool: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    @overload
    def Smooth(self, vertexIndices: Iterable[int], smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    def SolidOrientation(self) -> int: ...
    @overload
    def Split(self, plane: Plane) -> Iterable[Mesh]: ...
    @overload
    def Split(self, mesh: Mesh) -> Iterable[Mesh]: ...
    @overload
    def Split(self, meshes: Iterable[Mesh]) -> Iterable[Mesh]: ...
    @overload
    def Split(self, meshes: Iterable[Mesh], tolerance: float, splitAtCoplanar: bool, textLog: TextLog, cancel: CancellationToken, progress: IProgress) -> Iterable[Mesh]: ...
    @overload
    def Split(self, meshes: Iterable[Mesh], tolerance: float, splitAtCoplanar: bool, createNgons: bool, textLog: TextLog, cancel: CancellationToken, progress: IProgress) -> Iterable[Mesh]: ...
    def SplitDisjointPieces(self) -> Iterable[Mesh]: ...
    @overload
    def SplitWithProjectedPolylines(self, curves: Iterable[PolylineCurve], tolerance: float) -> Iterable[Mesh]: ...
    @overload
    def SplitWithProjectedPolylines(self, curves: Iterable[PolylineCurve], tolerance: float, textLog: TextLog, cancel: CancellationToken, progress: IProgress) -> Iterable[Mesh]: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def UnifyNormals(self) -> int: ...
    @overload
    def UnifyNormals(self, countOnly: bool) -> int: ...
    def Unweld(self, angleToleranceRadians: float, modifyNormals: bool) -> None: ...
    def UnweldEdge(self, edgeIndices: Iterable[int], modifyNormals: bool) -> bool: ...
    def UnweldVertices(self, topologyVertexIndices: Iterable[int], modifyNormals: bool) -> bool: ...
    def Volume(self) -> float: ...
    def Weld(self, angleToleranceRadians: float) -> None: ...
    def WithDisplacement(self, displacement: MeshDisplacementInfo) -> Mesh: ...
    def WithEdgeSoftening(self, softeningRadius: float, chamfer: bool, faceted: bool, force: bool, angleThreshold: float) -> Mesh: ...
    def WithShutLining(self, faceted: bool, tolerance: float, curves: Iterable[ShutLiningCurveInfo]) -> Mesh: ...


class MeshCheckParameters:
    @staticmethod
    def Defaults() -> MeshCheckParameters: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def CheckForBadNormals(self) -> bool: ...
    @property
    def CheckForDegenerateFaces(self) -> bool: ...
    @property
    def CheckForDisjointMeshes(self) -> bool: ...
    @property
    def CheckForDuplicateFaces(self) -> bool: ...
    @property
    def CheckForExtremelyShortEdges(self) -> bool: ...
    @property
    def CheckForInvalidNgons(self) -> bool: ...
    @property
    def CheckForNakedEdges(self) -> bool: ...
    @property
    def CheckForNonManifoldEdges(self) -> bool: ...
    @property
    def CheckForRandomFaceNormals(self) -> bool: ...
    @property
    def CheckForSelfIntersection(self) -> bool: ...
    @property
    def CheckForUnusedVertices(self) -> bool: ...
    @property
    def DegenerateFaceCount(self) -> int: ...
    @property
    def DisjointMeshCount(self) -> int: ...
    @property
    def DuplicateFaceCount(self) -> int: ...
    @property
    def ExtremelyShortEdgeCount(self) -> int: ...
    @property
    def InvalidNgonCount(self) -> int: ...
    @property
    def NakedEdgeCount(self) -> int: ...
    @property
    def NonManifoldEdgeCount(self) -> int: ...
    @property
    def NonUnitVectorNormalCount(self) -> int: ...
    @property
    def RandomFaceNormalCount(self) -> int: ...
    @property
    def SelfIntersectingPairsCount(self) -> int: ...
    @property
    def UnusedVertexCount(self) -> int: ...
    @property
    def VertexFaceNormalsDifferCount(self) -> int: ...
    @property
    def ZeroLengthNormalCount(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @CheckForBadNormals.setter
    def CheckForBadNormals(self) -> MutableSequence[bool]: ...
    @CheckForDegenerateFaces.setter
    def CheckForDegenerateFaces(self) -> MutableSequence[bool]: ...
    @CheckForDisjointMeshes.setter
    def CheckForDisjointMeshes(self) -> MutableSequence[bool]: ...
    @CheckForDuplicateFaces.setter
    def CheckForDuplicateFaces(self) -> MutableSequence[bool]: ...
    @CheckForExtremelyShortEdges.setter
    def CheckForExtremelyShortEdges(self) -> MutableSequence[bool]: ...
    @CheckForInvalidNgons.setter
    def CheckForInvalidNgons(self) -> MutableSequence[bool]: ...
    @CheckForNakedEdges.setter
    def CheckForNakedEdges(self) -> MutableSequence[bool]: ...
    @CheckForNonManifoldEdges.setter
    def CheckForNonManifoldEdges(self) -> MutableSequence[bool]: ...
    @CheckForRandomFaceNormals.setter
    def CheckForRandomFaceNormals(self) -> MutableSequence[bool]: ...
    @CheckForSelfIntersection.setter
    def CheckForSelfIntersection(self) -> MutableSequence[bool]: ...
    @CheckForUnusedVertices.setter
    def CheckForUnusedVertices(self) -> MutableSequence[bool]: ...
    def ToString(self) -> str: ...


from ..Render import RenderTexture
from ..Render import TextureMapping
class MeshDisplacementInfo:
    def __init__(self, texture: RenderTexture, mapping: TextureMapping): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Black(self) -> float: ...
    @property
    def BlackMove(self) -> float: ...
    @property
    def ChannelNumber(self) -> int: ...
    @property
    def FaceLimit(self) -> int: ...
    @property
    def FairingAmount(self) -> int: ...
    @property
    def InstanceTransform(self) -> Transform: ...
    @property
    def Mapping(self) -> TextureMapping: ...
    @property
    def MappingTransform(self) -> Transform: ...
    @property
    def MemoryLimit(self) -> int: ...
    @property
    def PostWeldAngle(self) -> float: ...
    @property
    def RefineSensitivity(self) -> float: ...
    @property
    def RefineStepCount(self) -> int: ...
    @property
    def SweepPitch(self) -> float: ...
    @property
    def Texture(self) -> RenderTexture: ...
    @property
    def White(self) -> float: ...
    @property
    def WhiteMove(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @Black.setter
    def Black(self) -> MutableSequence[float]: ...
    @BlackMove.setter
    def BlackMove(self) -> MutableSequence[float]: ...
    @ChannelNumber.setter
    def ChannelNumber(self) -> MutableSequence[int]: ...
    @FaceLimit.setter
    def FaceLimit(self) -> MutableSequence[int]: ...
    @FairingAmount.setter
    def FairingAmount(self) -> MutableSequence[int]: ...
    @InstanceTransform.setter
    def InstanceTransform(self) -> MutableSequence[Transform]: ...
    @MappingTransform.setter
    def MappingTransform(self) -> MutableSequence[Transform]: ...
    @MemoryLimit.setter
    def MemoryLimit(self) -> MutableSequence[int]: ...
    @PostWeldAngle.setter
    def PostWeldAngle(self) -> MutableSequence[float]: ...
    @RefineSensitivity.setter
    def RefineSensitivity(self) -> MutableSequence[float]: ...
    @RefineStepCount.setter
    def RefineStepCount(self) -> MutableSequence[int]: ...
    @SweepPitch.setter
    def SweepPitch(self) -> MutableSequence[float]: ...
    @White.setter
    def White(self) -> MutableSequence[float]: ...
    @WhiteMove.setter
    def WhiteMove(self) -> MutableSequence[float]: ...
    def ToString(self) -> str: ...


class MeshExtruder:
    def __init__(self, inputMesh: Mesh, componentIndices: Iterable[ComponentIndex]): ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def ExtrudedMesh(self) -> Tuple[bool, Mesh]: ...
    @overload
    def ExtrudedMesh(self) -> Tuple[bool, Mesh, List]: ...
    @property
    def EdgeBasedUVN(self) -> bool: ...
    @property
    def FaceDirectionMode(self) -> MeshExtruderFaceDirectionMode: ...
    @property
    def KeepOriginalFaces(self) -> bool: ...
    @property
    def PreviewLines(self) -> Iterable[Line]: ...
    @property
    def SurfaceParameterMode(self) -> MeshExtruderParameterMode: ...
    @property
    def TextureCoordinateMode(self) -> MeshExtruderParameterMode: ...
    @property
    def Transform(self) -> Transform: ...
    @property
    def UVN(self) -> bool: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def GetWallFaces(self) -> List: ...
    @EdgeBasedUVN.setter
    def EdgeBasedUVN(self) -> MutableSequence[bool]: ...
    @FaceDirectionMode.setter
    def FaceDirectionMode(self) -> MutableSequence[MeshExtruderFaceDirectionMode]: ...
    @KeepOriginalFaces.setter
    def KeepOriginalFaces(self) -> MutableSequence[bool]: ...
    @SurfaceParameterMode.setter
    def SurfaceParameterMode(self) -> MutableSequence[MeshExtruderParameterMode]: ...
    @TextureCoordinateMode.setter
    def TextureCoordinateMode(self) -> MutableSequence[MeshExtruderParameterMode]: ...
    @Transform.setter
    def Transform(self) -> MutableSequence[Transform]: ...
    @UVN.setter
    def UVN(self) -> MutableSequence[bool]: ...
    def ToString(self) -> str: ...


class MeshExtruderFaceDirectionMode(Enum):
    Keep = 0
    OrientClosedFrontOut = 1


class MeshExtruderParameterMode(Enum):
    CoverWalls = 0
    KeepAndStretch = 1


class MeshFace:
    @overload
    def __init__(self, a: int, b: int, c: int): ...
    @overload
    def __init__(self, a: int, b: int, c: int, d: int): ...
    def CompareTo(self, other: MeshFace) -> int: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, other: MeshFace) -> bool: ...
    def Flip(self) -> MeshFace: ...
    @property
    def A(self) -> int: ...
    @property
    def B(self) -> int: ...
    @property
    def C(self) -> int: ...
    @property
    def D(self) -> int: ...
    @property
    def IsQuad(self) -> bool: ...
    @property
    def IsTriangle(self) -> bool: ...
    @property
    def Item(self) -> Sequence[int]: ...
    @property
    def Unset() -> MeshFace: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    def IsValid(self) -> bool: ...
    @overload
    def IsValid(self, vertexCount: int) -> bool: ...
    @overload
    def IsValid(self, points: Iterable[Point3d]) -> bool: ...
    def IsValidEx(self, points: Iterable[Point3d]) -> Tuple[bool, Iterable[Point3d]]: ...
    def __eq__(a: MeshFace, b: MeshFace) -> bool: ...
    def __ne__(a: MeshFace, b: MeshFace) -> bool: ...
    def Repair(self, points: Iterable[Point3d]) -> bool: ...
    def RepairEx(self, points: Iterable[Point3d]) -> Tuple[bool, Iterable[Point3d]]: ...
    @A.setter
    def A(self) -> MutableSequence[int]: ...
    @B.setter
    def B(self) -> MutableSequence[int]: ...
    @C.setter
    def C(self) -> MutableSequence[int]: ...
    @D.setter
    def D(self) -> MutableSequence[int]: ...
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def Set(self, a: int, b: int, c: int) -> None: ...
    @overload
    def Set(self, a: int, b: int, c: int, d: int) -> None: ...
    def ToString(self) -> str: ...


class MeshingParameters:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, density: float): ...
    @overload
    def __init__(self, density: float, minimumEdgeLength: float): ...
    def Dispose(self) -> None: ...
    @staticmethod
    def DocumentCurrentSetting(doc: RhinoDoc) -> MeshingParameters: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ClosedObjectPostProcess(self) -> bool: ...
    @property
    def Coarse() -> MeshingParameters: ...
    @property
    def ComputeCurvature(self) -> bool: ...
    @property
    def Default() -> MeshingParameters: ...
    @property
    def DefaultAnalysisMesh() -> MeshingParameters: ...
    @property
    def FastRenderMesh() -> MeshingParameters: ...
    @property
    def GridAmplification(self) -> float: ...
    @property
    def GridAngle(self) -> float: ...
    @property
    def GridAspectRatio(self) -> float: ...
    @property
    def GridMaxCount(self) -> int: ...
    @property
    def GridMinCount(self) -> int: ...
    @property
    def JaggedSeams(self) -> bool: ...
    @property
    def MaximumEdgeLength(self) -> float: ...
    @property
    def Minimal() -> MeshingParameters: ...
    @property
    def MinimumEdgeLength(self) -> float: ...
    @property
    def MinimumTolerance(self) -> float: ...
    @property
    def QualityRenderMesh() -> MeshingParameters: ...
    @property
    def RefineAngle(self) -> float: ...
    @property
    def RefineGrid(self) -> bool: ...
    @property
    def RelativeTolerance(self) -> float: ...
    @property
    def SimplePlanes(self) -> bool: ...
    @property
    def Smooth() -> MeshingParameters: ...
    @property
    def TextureRange(self) -> MeshingParameterTextureRange: ...
    @property
    def Tolerance(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @ClosedObjectPostProcess.setter
    def ClosedObjectPostProcess(self) -> MutableSequence[bool]: ...
    @ComputeCurvature.setter
    def ComputeCurvature(self) -> MutableSequence[bool]: ...
    @GridAmplification.setter
    def GridAmplification(self) -> MutableSequence[float]: ...
    @GridAngle.setter
    def GridAngle(self) -> MutableSequence[float]: ...
    @GridAspectRatio.setter
    def GridAspectRatio(self) -> MutableSequence[float]: ...
    @GridMaxCount.setter
    def GridMaxCount(self) -> MutableSequence[int]: ...
    @GridMinCount.setter
    def GridMinCount(self) -> MutableSequence[int]: ...
    @JaggedSeams.setter
    def JaggedSeams(self) -> MutableSequence[bool]: ...
    @MaximumEdgeLength.setter
    def MaximumEdgeLength(self) -> MutableSequence[float]: ...
    @MinimumEdgeLength.setter
    def MinimumEdgeLength(self) -> MutableSequence[float]: ...
    @MinimumTolerance.setter
    def MinimumTolerance(self) -> MutableSequence[float]: ...
    @RefineAngle.setter
    def RefineAngle(self) -> MutableSequence[float]: ...
    @RefineGrid.setter
    def RefineGrid(self) -> MutableSequence[bool]: ...
    @RelativeTolerance.setter
    def RelativeTolerance(self) -> MutableSequence[float]: ...
    @SimplePlanes.setter
    def SimplePlanes(self) -> MutableSequence[bool]: ...
    @TextureRange.setter
    def TextureRange(self) -> MutableSequence[MeshingParameterTextureRange]: ...
    @Tolerance.setter
    def Tolerance(self) -> MutableSequence[float]: ...
    def SetSubDDisplayParameters(self, subDDisplayParameters: SubDDisplayParameters) -> None: ...
    def SubDDisplayParameters(self) -> SubDDisplayParameters: ...
    def ToString(self) -> str: ...


class MeshingParameterStyle(Enum):
    # None = 0
    Fast = 1
    Quality = 2
    Custom = 9
    PerObject = 10


class MeshingParameterTextureRange(Enum):
    Unset = 0
    UnpackedUnscaledNormalized = 1
    PackedScaledNormalized = 2


class MeshNgon:
    def BoundaryVertexIndexList(self) -> Iterable[UInt32]: ...
    def CompareTo(self, otherNgon: MeshNgon) -> int: ...
    @staticmethod
    def Create(meshVertexIndexList: Iterable[int], meshFaceIndexList: Iterable[int]) -> MeshNgon: ...
    @overload
    def Equals(self, otherNgon: MeshNgon) -> bool: ...
    @overload
    def Equals(self, otherObj: Object) -> bool: ...
    def FaceIndexList(self) -> Iterable[UInt32]: ...
    @property
    def BoundaryVertexCount(self) -> int: ...
    @property
    def Empty() -> MeshNgon: ...
    @property
    def FaceCount(self) -> int: ...
    @property
    def Item(self) -> Sequence[int]: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def __eq__(a: MeshNgon, b: MeshNgon) -> bool: ...
    def __ne__(a: MeshNgon, b: MeshNgon) -> bool: ...
    def Set(self, meshVertexIndexList: Iterable[int], meshFaceIndexList: Iterable[int]) -> None: ...
    def ToString(self) -> str: ...


class MeshPart:
    def Equals(self, obj: Object) -> bool: ...
    @property
    def EndFaceIndex(self) -> int: ...
    @property
    def EndVertexIndex(self) -> int: ...
    @property
    def StartFaceIndex(self) -> int: ...
    @property
    def StartVertexIndex(self) -> int: ...
    @property
    def TriangleCount(self) -> int: ...
    @property
    def VertexCount(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


class MeshPipeCapStyle(Enum):
    # None = 0
    Flat = 1
    Box = 2
    Dome = 3


class MeshPoint:
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ComponentIndex(self) -> ComponentIndex: ...
    @property
    def EdgeIndex(self) -> int: ...
    @property
    def EdgeParameter(self) -> float: ...
    @property
    def FaceIndex(self) -> int: ...
    @property
    def Mesh(self) -> Mesh: ...
    @property
    def Point(self) -> Point3d: ...
    @property
    def T(self) -> Iterable[float]: ...
    @property
    def Triangle(self) -> Char: ...
    def GetHashCode(self) -> int: ...
    def GetTriangle(self) -> Tuple[bool, int, int, int]: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


class MeshThicknessMeasurement:
    def __init__(self, meshIndex: int, vertexIndex: int, thickness: float, point: Point3d, oppositePoint: Point3d): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def MeshIndex(self) -> int: ...
    @property
    def OppositePoint(self) -> Point3d: ...
    @property
    def Point(self) -> Point3d: ...
    @property
    def Thickness(self) -> float: ...
    @property
    def VertexIndex(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


class MeshType(Enum):
    Default = 0
    Render = 1
    Analysis = 2
    Preview = 3
    Any = 4


class MeshUnsafeLock:
    def Equals(self, obj: Object) -> bool: ...
    def FacesArray(self) -> Tuple[MeshFace, int]: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def NormalVector3fArray(self) -> Tuple[Vector3f, int]: ...
    def Release(self) -> None: ...
    def ToString(self) -> str: ...
    def VertexPoint3dArray(self) -> Tuple[Point3d, int]: ...
    def VertexPoint3fArray(self) -> Tuple[Point3f, int]: ...


class MeshUnwrapMethod(Enum):
    LSCM = 0


class MeshUnwrapper:
    @overload
    def __init__(self, mesh: Mesh): ...
    @overload
    def __init__(self, meshes: Iterable[Mesh]): ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @SymmetryPlane.setter
    def SymmetryPlane(self) -> MutableSequence[Plane]: ...
    def ToString(self) -> str: ...
    def Unwrap(self, method: MeshUnwrapMethod) -> bool: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class MorphControl(GeometryBase):
    def __init__(self, originCurve: NurbsCurve, targetCurve: NurbsCurve): ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Curve(self) -> NurbsCurve: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PreserveStructure(self) -> bool: ...
    @property
    def QuickPreview(self) -> bool: ...
    @property
    def SpaceMorphTolerance(self) -> float: ...
    @property
    def Surface(self) -> NurbsSurface: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Morph(self, geometry: GeometryBase) -> bool: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @PreserveStructure.setter
    def PreserveStructure(self) -> MutableSequence[bool]: ...
    @QuickPreview.setter
    def QuickPreview(self) -> MutableSequence[bool]: ...
    @SpaceMorphTolerance.setter
    def SpaceMorphTolerance(self) -> MutableSequence[float]: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


from .Collections import NurbsCurveKnotList
from .Collections import NurbsCurvePointList
from ..Collections import Point3dList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class NurbsCurve(Curve):
    @overload
    def __init__(self, other: NurbsCurve): ...
    @overload
    def __init__(self, degree: int, pointCount: int): ...
    @overload
    def __init__(self, dimension: int, rational: bool, order: int, pointCount: int): ...
    def Append(self, nurbsCurve: NurbsCurve) -> bool: ...
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    def ConvertSpanToBezier(self, spanIndex: int) -> BezierCurve: ...
    @staticmethod
    def Create(periodic: bool, degree: int, points: Iterable[Point3d]) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromArc(arc: Arc) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromArc(arc: Arc, degree: int, cvCount: int) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromCircle(circle: Circle) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromCircle(circle: Circle, degree: int, cvCount: int) -> NurbsCurve: ...
    @staticmethod
    def CreateFromEllipse(ellipse: Ellipse) -> NurbsCurve: ...
    @staticmethod
    def CreateFromLine(line: Line) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateHSpline(points: Iterable[Point3d]) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateHSpline(points: Iterable[Point3d], startTangent: Vector3d, endTangent: Vector3d) -> NurbsCurve: ...
    @staticmethod
    def CreateParabolaFromFocus(focus: Point3d, startPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...
    @staticmethod
    def CreateParabolaFromVertex(vertex: Point3d, startPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...
    def CreatePlanarRailFrames(self, parameters: Iterable[float], normal: Vector3d) -> Iterable[Plane]: ...
    def CreateRailFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    @overload
    @staticmethod
    def CreateSpiral(axisStart: Point3d, axisDir: Vector3d, radiusPoint: Point3d, pitch: float, turnCount: float, radius0: float, radius1: float) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSpiral(railCurve: Curve, t0: float, t1: float, radiusPoint: Point3d, pitch: float, turnCount: float, radius0: float, radius1: float, pointsPerTurn: int) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSubDFriendly(curve: Curve) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSubDFriendly(points: Iterable[Point3d], interpolatePoints: bool, periodicClosedCurve: bool) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSubDFriendly(curve: Curve, pointCount: int, periodicClosedCurve: bool) -> NurbsCurve: ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    def Dispose(self) -> None: ...
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateCurve(self) -> Curve: ...
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def EpsilonEquals(self, other: NurbsCurve, epsilon: float) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @property
    def Degree(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Domain(self) -> Interval: ...
    @property
    def HasBezierSpans(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsPeriodic(self) -> bool: ...
    @property
    def IsRational(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Knots(self) -> NurbsCurveKnotList: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def Order(self) -> int: ...
    @property
    def PointAtEnd(self) -> Point3d: ...
    @property
    def PointAtStart(self) -> Point3d: ...
    @property
    def Points(self) -> NurbsCurvePointList: ...
    @property
    def SpanCount(self) -> int: ...
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def GrevilleParameter(self, index: int) -> float: ...
    def GrevilleParameters(self) -> Iterable[float]: ...
    def GrevillePoint(self, index: int) -> Point3d: ...
    @overload
    def GrevillePoints(self) -> Point3dList: ...
    @overload
    def GrevillePoints(self, all: bool) -> Point3dList: ...
    def HasNurbsForm(self) -> int: ...
    def IncreaseDegree(self, desiredDegree: int) -> bool: ...
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @staticmethod
    def IsDuplicate(curveA: NurbsCurve, curveB: NurbsCurve, ignoreParameterization: bool, tolerance: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    def MakeClosed(self, tolerance: float) -> bool: ...
    @staticmethod
    def MakeCompatible(curves: Iterable[Curve], startPt: Point3d, endPt: Point3d, simplifyMethod: int, numPoints: int, refitTolerance: float, angleTolerance: float) -> Iterable[NurbsCurve]: ...
    def MakeDeformable(self) -> bool: ...
    def MakePiecewiseBezier(self, setEndWeightsToOne: bool) -> bool: ...
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    def PointAt(self, t: float) -> Point3d: ...
    def PointAtLength(self, length: float) -> Point3d: ...
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    def Reparameterize(self, c: float) -> bool: ...
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Domain.setter
    def Domain(self) -> MutableSequence[Interval]: ...
    @overload
    def SetEndCondition(self, bSetEnd: bool, continuity: NurbsCurveEndConditionType, point: Point3d, tangent: Vector3d) -> bool: ...
    @overload
    def SetEndCondition(self, bSetEnd: bool, continuity: NurbsCurveEndConditionType, point: Point3d, tangent: Vector3d, curvature: Vector3d) -> bool: ...
    def SetEndPoint(self, point: Point3d) -> bool: ...
    def SetGrevillePoints(self, points: Iterable[Point3d]) -> bool: ...
    def SetStartPoint(self, point: Point3d) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    def TorsionAt(self, t: float) -> float: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...
    def UVNDirectionsAt(self, t: float) -> Tuple[bool, Vector3d, Vector3d, Vector3d]: ...


class NurbsCurveEndConditionType(Enum):
    Nothing = 0
    Position = 1
    Tangency = 2
    Curvature = 3


from .Collections import NurbsSurfaceKnotList
from .Collections import NurbsSurfacePointList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class NurbsSurface(Surface):
    def __init__(self, other: NurbsSurface): ...
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def ConvertSpanToBezier(self, spanIndex0: int, spanIndex1: int) -> BezierSurface: ...
    def CopyFrom(self, other: NurbsSurface) -> None: ...
    @staticmethod
    def Create(dimension: int, isRational: bool, order0: int, order1: int, controlPointCount0: int, controlPointCount1: int) -> NurbsSurface: ...
    @staticmethod
    def CreateCurveOnSurface(surface: Surface, points: Iterable[Point2d], tolerance: float, periodic: bool) -> NurbsCurve: ...
    @staticmethod
    def CreateCurveOnSurfacePoints(surface: Surface, fixedPoints: Iterable[Point2d], tolerance: float, periodic: bool, initCount: int, levels: int) -> Iterable[Point2d]: ...
    @staticmethod
    def CreateFromCone(cone: Cone) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d, tolerance: float) -> NurbsSurface: ...
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder) -> NurbsSurface: ...
    @staticmethod
    def CreateFromPlane(plane: Plane, uInterval: Interval, vInterval: Interval, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @staticmethod
    def CreateFromPoints(points: Iterable[Point3d], uCount: int, vCount: int, uDegree: int, vDegree: int) -> NurbsSurface: ...
    @staticmethod
    def CreateFromSphere(sphere: Sphere) -> NurbsSurface: ...
    @staticmethod
    def CreateFromTorus(torus: Torus) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateNetworkSurface(curves: Iterable[Curve], continuity: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    @staticmethod
    def CreateNetworkSurface(uCurves: Iterable[Curve], uContinuityStart: int, uContinuityEnd: int, vCurves: Iterable[Curve], vContinuityStart: int, vContinuityEnd: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float) -> Tuple[NurbsSurface, int]: ...
    @staticmethod
    def CreateRailRevolvedSurface(profile: Curve, rail: Curve, axis: Line, scaleHeight: bool) -> NurbsSurface: ...
    @staticmethod
    def CreateRuledSurface(curveA: Curve, curveB: Curve) -> NurbsSurface: ...
    @staticmethod
    def CreateSubDFriendly(surface: Surface) -> NurbsSurface: ...
    @staticmethod
    def CreateThroughPoints(points: Iterable[Point3d], uCount: int, vCount: int, uDegree: int, vDegree: int, uClosed: bool, vClosed: bool) -> NurbsSurface: ...
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Degree(self, direction: int) -> int: ...
    def Dispose(self) -> None: ...
    def Domain(self, direction: int) -> Interval: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def EpsilonEquals(self, other: NurbsSurface, epsilon: float) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsRational(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def KnotsU(self) -> NurbsSurfaceKnotList: ...
    @property
    def KnotsV(self) -> NurbsSurfaceKnotList: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def OrderU(self) -> int: ...
    @property
    def OrderV(self) -> int: ...
    @property
    def Points(self) -> NurbsSurfacePointList: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def IncreaseDegreeU(self, desiredDegree: int) -> bool: ...
    def IncreaseDegreeV(self, desiredDegree: int) -> bool: ...
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    def IsAtSeam(self, u: float, v: float) -> int: ...
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    @staticmethod
    def MakeCompatible(surface0: Surface, surface1: Surface) -> Tuple[bool, NurbsSurface, NurbsSurface]: ...
    def MakeDeformable(self) -> bool: ...
    def MakeNonRational(self) -> bool: ...
    def MakeRational(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    def SpanCount(self, direction: int) -> int: ...
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    def ToBrep(self) -> Brep: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    def UVNDirectionsAt(self, u: float, v: float) -> Tuple[bool, Vector3d, Vector3d, Vector3d]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


class NurbsSurfaceType(Enum):
    Unset = 0
    Large = 1
    Medium = 2
    Small = 3
    Unprocessed = 4


from ..DocObjects import DimensionStyle
from ..DocObjects import ViewportInfo
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ArrowType
from ..DocObjects import ZeroSuppression
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class OrdinateDimension(Dimension):
    def __init__(self): ...
    def AdjustFromPoints(self, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float) -> bool: ...
    def ClearPropertyOverrides(self) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @staticmethod
    def Create(dimStyle: DimensionStyle, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float) -> OrdinateDimension: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AlternateBelowLine(self) -> bool: ...
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def AltLengthFactor(self) -> float: ...
    @property
    def AltLengthResolution(self) -> int: ...
    @property
    def AltLengthRoundoff(self) -> float: ...
    @property
    def AltPrefix(self) -> str: ...
    @property
    def AltSuffix(self) -> str: ...
    @property
    def AltToleranceResolution(self) -> int: ...
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @property
    def ArrowSize(self) -> float: ...
    @property
    def BaselineSpacing(self) -> float: ...
    @property
    def CentermarkSize(self) -> float: ...
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @property
    def DecimalSeparator(self) -> Char: ...
    @property
    def DefPoint(self) -> Point2d: ...
    @property
    def DetailMeasured(self) -> Guid: ...
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def DimensionLineExtension(self) -> float: ...
    @property
    def DimensionScale(self) -> float: ...
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @property
    def DimensionStyleId(self) -> Guid: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def DistanceScale(self) -> float: ...
    @property
    def DrawForward(self) -> bool: ...
    @property
    def DrawTextFrame(self) -> bool: ...
    @property
    def ExtensionLineExtension(self) -> float: ...
    @property
    def ExtensionLineOffset(self) -> float: ...
    @property
    def FirstCharFont(self) -> Font: ...
    @property
    def FixedExtensionLength(self) -> float: ...
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @property
    def Font(self) -> Font: ...
    @property
    def FontIndex(self) -> int: ...
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @property
    def ForceDimLine(self) -> bool: ...
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @property
    def FormatWidth(self) -> float: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def KinkOffset1(self) -> float: ...
    @property
    def KinkOffset2(self) -> float: ...
    @property
    def KinkPoint1(self) -> Point2d: ...
    @property
    def KinkPoint2(self) -> Point2d: ...
    @property
    def LeaderPoint(self) -> Point2d: ...
    @property
    def LengthFactor(self) -> float: ...
    @property
    def LengthResolution(self) -> int: ...
    @property
    def LengthRoundoff(self) -> float: ...
    @property
    def MaskColor(self) -> Color: ...
    @property
    def MaskColorSource(self) -> MaskType: ...
    @property
    def MaskEnabled(self) -> bool: ...
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @property
    def MaskOffset(self) -> float: ...
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @property
    def NumericValue(self) -> float: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @property
    def PlainText(self) -> str: ...
    @property
    def PlainTextWithFields(self) -> str: ...
    @property
    def PlainUserText(self) -> str: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Prefix(self) -> str: ...
    @property
    def RichText(self) -> str: ...
    @property
    def Suffix(self) -> str: ...
    @property
    def SuppressExtension1(self) -> bool: ...
    @property
    def SuppressExtension2(self) -> bool: ...
    @property
    def Text(self) -> str: ...
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @property
    def TextFit(self) -> TextFit: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @property
    def TextHeight(self) -> float: ...
    @property
    def TextIsWrapped(self) -> bool: ...
    @property
    def TextLocation(self) -> TextLocation: ...
    @property
    def TextModelWidth(self) -> float: ...
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @property
    def TextPosition(self) -> Point2d: ...
    @property
    def TextRotation(self) -> float: ...
    @property
    def TextRotationDegrees(self) -> float: ...
    @property
    def TextRotationRadians(self) -> float: ...
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @property
    def ToleranceHeightScale(self) -> float: ...
    @property
    def ToleranceLowerValue(self) -> float: ...
    @property
    def ToleranceResolution(self) -> int: ...
    @property
    def ToleranceUpperValue(self) -> float: ...
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d, Point3d]: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Iterable[Line]]: ...
    def GetDistanceDisplayText(self, unitsystem: UnitSystem, style: DimensionStyle) -> str: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    def GetTextRectangle(self) -> Tuple[bool, Iterable[Point3d]]: ...
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsAllBold(self) -> bool: ...
    def IsAllItalic(self) -> bool: ...
    def IsAllUnderlined(self) -> bool: ...
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @AlternateBelowLine.setter
    def AlternateBelowLine(self) -> MutableSequence[bool]: ...
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @AltLengthFactor.setter
    def AltLengthFactor(self) -> MutableSequence[float]: ...
    @AltLengthResolution.setter
    def AltLengthResolution(self) -> MutableSequence[int]: ...
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self) -> MutableSequence[float]: ...
    @AltPrefix.setter
    def AltPrefix(self) -> MutableSequence[str]: ...
    @AltSuffix.setter
    def AltSuffix(self) -> MutableSequence[str]: ...
    @AltToleranceResolution.setter
    def AltToleranceResolution(self) -> MutableSequence[int]: ...
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self) -> MutableSequence[bool]: ...
    @AltZeroSuppression.setter
    def AltZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    @ArrowBlockId1.setter
    def ArrowBlockId1(self) -> MutableSequence[Guid]: ...
    @ArrowBlockId2.setter
    def ArrowBlockId2(self) -> MutableSequence[Guid]: ...
    @ArrowFit.setter
    def ArrowFit(self) -> MutableSequence[ArrowFit]: ...
    @ArrowheadType1.setter
    def ArrowheadType1(self) -> MutableSequence[ArrowType]: ...
    @ArrowheadType2.setter
    def ArrowheadType2(self) -> MutableSequence[ArrowType]: ...
    @ArrowSize.setter
    def ArrowSize(self) -> MutableSequence[float]: ...
    @BaselineSpacing.setter
    def BaselineSpacing(self) -> MutableSequence[float]: ...
    @CentermarkSize.setter
    def CentermarkSize(self) -> MutableSequence[float]: ...
    @CentermarkStyle.setter
    def CentermarkStyle(self) -> MutableSequence[CenterMarkStyle]: ...
    @DecimalSeparator.setter
    def DecimalSeparator(self) -> MutableSequence[Char]: ...
    @DefPoint.setter
    def DefPoint(self) -> MutableSequence[Point2d]: ...
    @DetailMeasured.setter
    def DetailMeasured(self) -> MutableSequence[Guid]: ...
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DimensionLineExtension.setter
    def DimensionLineExtension(self) -> MutableSequence[float]: ...
    @DimensionScale.setter
    def DimensionScale(self) -> MutableSequence[float]: ...
    @DimensionStyleId.setter
    def DimensionStyleId(self) -> MutableSequence[Guid]: ...
    @DistanceScale.setter
    def DistanceScale(self) -> MutableSequence[float]: ...
    @DrawForward.setter
    def DrawForward(self) -> MutableSequence[bool]: ...
    @DrawTextFrame.setter
    def DrawTextFrame(self) -> MutableSequence[bool]: ...
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self) -> MutableSequence[float]: ...
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self) -> MutableSequence[float]: ...
    @FixedExtensionLength.setter
    def FixedExtensionLength(self) -> MutableSequence[float]: ...
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self) -> MutableSequence[bool]: ...
    @Font.setter
    def Font(self) -> MutableSequence[Font]: ...
    @FontIndex.setter
    def FontIndex(self) -> MutableSequence[int]: ...
    @ForceArrowPosition.setter
    def ForceArrowPosition(self) -> MutableSequence[ForceArrow]: ...
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self) -> MutableSequence[bool]: ...
    @ForceDimLine.setter
    def ForceDimLine(self) -> MutableSequence[bool]: ...
    @ForceTextPosition.setter
    def ForceTextPosition(self) -> MutableSequence[ForceText]: ...
    @FormatWidth.setter
    def FormatWidth(self) -> MutableSequence[float]: ...
    @KinkOffset1.setter
    def KinkOffset1(self) -> MutableSequence[float]: ...
    @KinkOffset2.setter
    def KinkOffset2(self) -> MutableSequence[float]: ...
    @LeaderPoint.setter
    def LeaderPoint(self) -> MutableSequence[Point2d]: ...
    @LengthFactor.setter
    def LengthFactor(self) -> MutableSequence[float]: ...
    @LengthResolution.setter
    def LengthResolution(self) -> MutableSequence[int]: ...
    @LengthRoundoff.setter
    def LengthRoundoff(self) -> MutableSequence[float]: ...
    @MaskColor.setter
    def MaskColor(self) -> MutableSequence[Color]: ...
    @MaskColorSource.setter
    def MaskColorSource(self) -> MutableSequence[MaskType]: ...
    @MaskEnabled.setter
    def MaskEnabled(self) -> MutableSequence[bool]: ...
    @MaskFrame.setter
    def MaskFrame(self) -> MutableSequence[MaskFrame]: ...
    @MaskOffset.setter
    def MaskOffset(self) -> MutableSequence[float]: ...
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self) -> MutableSequence[bool]: ...
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self) -> MutableSequence[DimensionStyle]: ...
    @PlainText.setter
    def PlainText(self) -> MutableSequence[str]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @Prefix.setter
    def Prefix(self) -> MutableSequence[str]: ...
    @RichText.setter
    def RichText(self) -> MutableSequence[str]: ...
    @Suffix.setter
    def Suffix(self) -> MutableSequence[str]: ...
    @SuppressExtension1.setter
    def SuppressExtension1(self) -> MutableSequence[bool]: ...
    @SuppressExtension2.setter
    def SuppressExtension2(self) -> MutableSequence[bool]: ...
    @Text.setter
    def Text(self) -> MutableSequence[str]: ...
    @TextAngleType.setter
    def TextAngleType(self) -> MutableSequence[LeaderContentAngleStyle]: ...
    @TextFit.setter
    def TextFit(self) -> MutableSequence[TextFit]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextHeight.setter
    def TextHeight(self) -> MutableSequence[float]: ...
    @TextIsWrapped.setter
    def TextIsWrapped(self) -> MutableSequence[bool]: ...
    @TextLocation.setter
    def TextLocation(self) -> MutableSequence[TextLocation]: ...
    @TextOrientation.setter
    def TextOrientation(self) -> MutableSequence[TextOrientation]: ...
    @TextPosition.setter
    def TextPosition(self) -> MutableSequence[Point2d]: ...
    @TextRotation.setter
    def TextRotation(self) -> MutableSequence[float]: ...
    @TextRotationDegrees.setter
    def TextRotationDegrees(self) -> MutableSequence[float]: ...
    @TextRotationRadians.setter
    def TextRotationRadians(self) -> MutableSequence[float]: ...
    @ToleranceFormat.setter
    def ToleranceFormat(self) -> MutableSequence[ToleranceDisplayFormat]: ...
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self) -> MutableSequence[float]: ...
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self) -> MutableSequence[float]: ...
    @ToleranceResolution.setter
    def ToleranceResolution(self) -> MutableSequence[int]: ...
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self) -> MutableSequence[float]: ...
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self) -> MutableSequence[bool]: ...
    @ZeroSuppression.setter
    def ZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetBold(self, set_on: bool) -> bool: ...
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    def SetItalic(self, set_on: bool) -> bool: ...
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    def SetUnderline(self, set_on: bool) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    def WrapText(self) -> None: ...


class Particle:
    def __init__(self): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Color(self) -> Color: ...
    @property
    def DisplayBitmapIndex(self) -> int: ...
    @property
    def Index(self) -> int: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def ParentSystem(self) -> ParticleSystem: ...
    @property
    def Size(self) -> Single: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @Color.setter
    def Color(self) -> MutableSequence[Color]: ...
    @DisplayBitmapIndex.setter
    def DisplayBitmapIndex(self) -> MutableSequence[int]: ...
    @Location.setter
    def Location(self) -> MutableSequence[Point3d]: ...
    @Size.setter
    def Size(self) -> MutableSequence[Single]: ...
    def ToString(self) -> str: ...
    def Update(self) -> None: ...


class ParticleSystem:
    def __init__(self): ...
    def __iter__(self) -> Iterator[Particle]: ...
    def Add(self, particle: Particle) -> bool: ...
    def Clear(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def DisplaySizesInWorldUnits(self) -> bool: ...
    @property
    def DrawRequiresDepthSorting(self) -> bool: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def Remove(self, particle: Particle) -> None: ...
    @DisplaySizesInWorldUnits.setter
    def DisplaySizesInWorldUnits(self) -> MutableSequence[bool]: ...
    @DrawRequiresDepthSorting.setter
    def DrawRequiresDepthSorting(self) -> MutableSequence[bool]: ...
    def ToString(self) -> str: ...
    def Update(self) -> None: ...


class PipeCapMode(Enum):
    # None = 0
    Flat = 1
    Round = 2


class Plane:
    @overload
    def __init__(self, other: Plane): ...
    @overload
    def __init__(self, origin: Point3d, normal: Vector3d): ...
    @overload
    def __init__(self, origin: Point3d, xDirection: Vector3d, yDirection: Vector3d): ...
    @overload
    def __init__(self, origin: Point3d, xPoint: Point3d, yPoint: Point3d): ...
    @overload
    def __init__(self, a: float, b: float, c: float, d: float): ...
    def Clone(self) -> Plane: ...
    def ClosestParameter(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def DistanceTo(self, testPoint: Point3d) -> float: ...
    @overload
    def DistanceTo(self, bbox: BoundingBox) -> Tuple[bool, float, float]: ...
    def EpsilonEquals(self, other: Plane, epsilon: float) -> bool: ...
    @overload
    def Equals(self, plane: Plane) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: Box) -> Tuple[bool, Interval, Interval]: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox) -> Tuple[bool, Interval, Interval]: ...
    @overload
    @staticmethod
    def FitPlaneToPoints(points: Iterable[Point3d]) -> Tuple[PlaneFitResult, Plane]: ...
    @overload
    @staticmethod
    def FitPlaneToPoints(points: Iterable[Point3d]) -> Tuple[PlaneFitResult, Plane, float]: ...
    def Flip(self) -> None: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Normal(self) -> Vector3d: ...
    @property
    def Origin(self) -> Point3d: ...
    @property
    def OriginX(self) -> float: ...
    @property
    def OriginY(self) -> float: ...
    @property
    def OriginZ(self) -> float: ...
    @property
    def Unset() -> Plane: ...
    @property
    def WorldXY() -> Plane: ...
    @property
    def WorldYZ() -> Plane: ...
    @property
    def WorldZX() -> Plane: ...
    @property
    def XAxis(self) -> Vector3d: ...
    @property
    def YAxis(self) -> Vector3d: ...
    @property
    def ZAxis(self) -> Vector3d: ...
    def GetHashCode(self) -> int: ...
    def GetPlaneEquation(self) -> Iterable[float]: ...
    def GetType(self) -> Type: ...
    def __eq__(a: Plane, b: Plane) -> bool: ...
    def __ne__(a: Plane, b: Plane) -> bool: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def PointAt(self, u: float, v: float, w: float) -> Point3d: ...
    def RemapToPlaneSpace(self, ptSample: Point3d) -> Tuple[bool, Point3d]: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @Origin.setter
    def Origin(self) -> MutableSequence[Point3d]: ...
    @OriginX.setter
    def OriginX(self) -> MutableSequence[float]: ...
    @OriginY.setter
    def OriginY(self) -> MutableSequence[float]: ...
    @OriginZ.setter
    def OriginZ(self) -> MutableSequence[float]: ...
    @XAxis.setter
    def XAxis(self) -> MutableSequence[Vector3d]: ...
    @YAxis.setter
    def YAxis(self) -> MutableSequence[Vector3d]: ...
    @ZAxis.setter
    def ZAxis(self) -> MutableSequence[Vector3d]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    def Translate(self, delta: Vector3d) -> bool: ...
    def UpdateEquation(self) -> bool: ...
    def ValueAt(self, p: Point3d) -> float: ...


class PlaneFitResult(Enum):
    Success = 0
    Inconclusive = 1
    Failure = -1


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class PlaneSurface(Surface):
    def __init__(self, plane: Plane, xExtents: Interval, yExtents: Interval): ...
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def CreateThroughBox(plane: Plane, box: BoundingBox) -> PlaneSurface: ...
    @overload
    @staticmethod
    def CreateThroughBox(lineInPlane: Line, vectorInPlane: Vector3d, box: BoundingBox) -> PlaneSurface: ...
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Degree(self, direction: int) -> int: ...
    def Dispose(self) -> None: ...
    def Domain(self, direction: int) -> Interval: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    def IsAtSeam(self, u: float, v: float) -> int: ...
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    def SpanCount(self, direction: int) -> int: ...
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    def ToBrep(self) -> Brep: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Point(GeometryBase):
    def __init__(self, location: Point3d): ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Location.setter
    def Location(self) -> MutableSequence[Point3d]: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class Point2d:
    @overload
    def __init__(self, vector: Vector2d): ...
    @overload
    def __init__(self, point: Point2d): ...
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, x: float, y: float): ...
    @overload
    @staticmethod
    def Add(point1: Point2d, point2: Point2d) -> Point2d: ...
    @overload
    @staticmethod
    def Add(vector: Vector2d, point: Point2d) -> Point2d: ...
    @overload
    @staticmethod
    def Add(point: Point2d, vector: Vector2d) -> Point2d: ...
    def CompareTo(self, other: Point2d) -> int: ...
    def DistanceTo(self, other: Point2d) -> float: ...
    @staticmethod
    def Divide(point: Point2d, t: float) -> Point2d: ...
    def EpsilonEquals(self, other: Point2d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, point: Point2d) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> Sequence[int]: ...
    @property
    def MaximumCoordinate(self) -> float: ...
    @property
    def MinimumCoordinate(self) -> float: ...
    @property
    def Origin() -> Point2d: ...
    @property
    def Unset() -> Point2d: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    @staticmethod
    def Multiply(point: Point2d, t: float) -> Point2d: ...
    @overload
    @staticmethod
    def Multiply(t: float, point: Point2d) -> Point2d: ...
    @overload
    def __add__(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    def __radd__(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    def __add__(point1: Point2d, point2: Point2d) -> Point2d: ...
    def __truediv__(point: Point2d, t: float) -> Point2d: ...
    def __eq__(a: Point2d, b: Point2d) -> bool: ...
    def __gt__(a: Point2d, b: Point2d) -> bool: ...
    def __ge__(a: Point2d, b: Point2d) -> bool: ...
    def __ne__(a: Point2d, b: Point2d) -> bool: ...
    def __lt__(a: Point2d, b: Point2d) -> bool: ...
    def __le__(a: Point2d, b: Point2d) -> bool: ...
    @overload
    def __rmul__(point: Point2d, t: float) -> Point2d: ...
    @overload
    def __mul__(point: Point2d, t: float) -> Point2d: ...
    @overload
    def __sub__(point1: Point2d, point2: Point2d) -> Vector2d: ...
    @overload
    def __sub__(point: Point2d, vector: Vector2d) -> Point2d: ...
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @X.setter
    def X(self) -> MutableSequence[float]: ...
    @Y.setter
    def Y(self) -> MutableSequence[float]: ...
    @overload
    @staticmethod
    def Subtract(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    @staticmethod
    def Subtract(point1: Point2d, point2: Point2d) -> Vector2d: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Transform(self, xform: Transform) -> None: ...


class Point2f:
    @overload
    def __init__(self, x: Single, y: Single): ...
    @overload
    def __init__(self, x: float, y: float): ...
    def CompareTo(self, other: Point2f) -> int: ...
    def DistanceTo(self, other: Point2f) -> float: ...
    def DistanceToSquared(self, other: Point2f) -> float: ...
    def EpsilonEquals(self, other: Point2f, epsilon: Single) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, point: Point2f) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> Sequence[int]: ...
    @property
    def Unset() -> Point2f: ...
    @property
    def X(self) -> Single: ...
    @property
    def Y(self) -> Single: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def __add__(a: Point2f, b: Point2f) -> Vector2f: ...
    def __truediv__(a: Point2f, b: Single) -> Point2f: ...
    def __eq__(a: Point2f, b: Point2f) -> bool: ...
    def op_Explicit(point: Point2d) -> Point2f: ...
    def __gt__(a: Point2f, b: Point2f) -> bool: ...
    def __ge__(a: Point2f, b: Point2f) -> bool: ...
    def __ne__(a: Point2f, b: Point2f) -> bool: ...
    def __lt__(a: Point2f, b: Point2f) -> bool: ...
    def __le__(a: Point2f, b: Point2f) -> bool: ...
    def __mul__(a: Point2f, b: Single) -> Point2f: ...
    def __sub__(a: Point2f, b: Point2f) -> Vector2f: ...
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @X.setter
    def X(self) -> MutableSequence[Single]: ...
    @Y.setter
    def Y(self) -> MutableSequence[Single]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...


class Point3d:
    @overload
    def __init__(self, vector: Vector3d): ...
    @overload
    def __init__(self, point: Point3f): ...
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, point: Point4d): ...
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    @staticmethod
    def Add(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    @staticmethod
    def Add(vector: Vector3d, point: Point3d) -> Point3d: ...
    @overload
    @staticmethod
    def Add(point1: Point3d, point2: Point3d) -> Point3d: ...
    @overload
    @staticmethod
    def Add(point: Point3d, vector: Vector3f) -> Point3d: ...
    @staticmethod
    def ArePointsCoplanar(points: Iterable[Point3d], tolerance: float) -> bool: ...
    def CompareTo(self, other: Point3d) -> int: ...
    @staticmethod
    def CullDuplicates(points: Iterable[Point3d], tolerance: float) -> Iterable[Point3d]: ...
    def DistanceTo(self, other: Point3d) -> float: ...
    def DistanceToSquared(self, other: Point3d) -> float: ...
    @staticmethod
    def Divide(point: Point3d, t: float) -> Point3d: ...
    def EpsilonEquals(self, other: Point3d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, point: Point3d) -> bool: ...
    @staticmethod
    def FromPoint3f(point: Point3f) -> Point3d: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> Sequence[int]: ...
    @property
    def MaximumCoordinate(self) -> float: ...
    @property
    def MinimumCoordinate(self) -> float: ...
    @property
    def Origin() -> Point3d: ...
    @property
    def Unset() -> Point3d: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @property
    def Z(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def Interpolate(self, pA: Point3d, pB: Point3d, t: float) -> None: ...
    @overload
    @staticmethod
    def Multiply(t: float, point: Point3d) -> Point3d: ...
    @overload
    @staticmethod
    def Multiply(point: Point3d, t: float) -> Point3d: ...
    @overload
    def __add__(point: Point3d, vector: Vector3f) -> Point3d: ...
    @overload
    def __add__(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    def __add__(point1: Point3d, point2: Point3d) -> Point3d: ...
    @overload
    def __radd__(point: Point3d, vector: Vector3d) -> Point3d: ...
    def __truediv__(point: Point3d, t: float) -> Point3d: ...
    def __eq__(a: Point3d, b: Point3d) -> bool: ...
    @overload
    def op_Explicit(vector: Vector3d) -> Point3d: ...
    @overload
    def op_Explicit(point: Point3d) -> Vector3d: ...
    def __gt__(a: Point3d, b: Point3d) -> bool: ...
    def __ge__(a: Point3d, b: Point3d) -> bool: ...
    @overload
    def op_Implicit(pt: Point3d) -> ControlPoint: ...
    @overload
    def op_Implicit(point: Point3f) -> Point3d: ...
    def __ne__(a: Point3d, b: Point3d) -> bool: ...
    def __lt__(a: Point3d, b: Point3d) -> bool: ...
    def __le__(a: Point3d, b: Point3d) -> bool: ...
    @overload
    def __rmul__(point: Point3d, t: float) -> Point3d: ...
    @overload
    def __mul__(point: Point3d, t: float) -> Point3d: ...
    @overload
    def __sub__(point1: Point3d, point2: Point3d) -> Vector3d: ...
    @overload
    def __sub__(point: Point3d, vector: Vector3d) -> Point3d: ...
    def __neg__(point: Point3d) -> Point3d: ...
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @X.setter
    def X(self) -> MutableSequence[float]: ...
    @Y.setter
    def Y(self) -> MutableSequence[float]: ...
    @Z.setter
    def Z(self) -> MutableSequence[float]: ...
    @staticmethod
    def SortAndCullPointList(points: Iterable[Point3d], minimumDistance: float) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def Subtract(point1: Point3d, point2: Point3d) -> Vector3d: ...
    @overload
    @staticmethod
    def Subtract(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Transform(self, xform: Transform) -> None: ...
    @staticmethod
    def TryParse(input: str) -> Tuple[bool, Point3d]: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Point3dGrid(GeometryBase):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, rows: int, columns: int): ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class Point3f:
    def __init__(self, x: Single, y: Single, z: Single): ...
    def CompareTo(self, other: Point3f) -> int: ...
    def DistanceTo(self, other: Point3f) -> float: ...
    def DistanceToSquared(self, other: Point3f) -> float: ...
    def EpsilonEquals(self, other: Point3f, epsilon: Single) -> bool: ...
    @overload
    def Equals(self, point: Point3f) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Origin() -> Point3f: ...
    @property
    def Unset() -> Point3f: ...
    @property
    def X(self) -> Single: ...
    @property
    def Y(self) -> Single: ...
    @property
    def Z(self) -> Single: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def __add__(point1: Point3f, point2: Point3f) -> Point3f: ...
    def __eq__(a: Point3f, b: Point3f) -> bool: ...
    @overload
    def op_Explicit(point: Point3f) -> Vector3f: ...
    @overload
    def op_Explicit(point: Point3d) -> Point3f: ...
    def __gt__(a: Point3f, b: Point3f) -> bool: ...
    def __ge__(a: Point3f, b: Point3f) -> bool: ...
    def __ne__(a: Point3f, b: Point3f) -> bool: ...
    def __lt__(a: Point3f, b: Point3f) -> bool: ...
    def __le__(a: Point3f, b: Point3f) -> bool: ...
    @overload
    def __rmul__(point: Point3f, value: Single) -> Point3f: ...
    @overload
    def __mul__(point: Point3f, value: Single) -> Point3f: ...
    def __sub__(point1: Point3f, point2: Point3f) -> Vector3f: ...
    @X.setter
    def X(self) -> MutableSequence[Single]: ...
    @Y.setter
    def Y(self) -> MutableSequence[Single]: ...
    @Z.setter
    def Z(self) -> MutableSequence[Single]: ...
    @staticmethod
    def Subtract(point1: Point3f, point2: Point3f) -> Vector3f: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Transform(self, xform: Transform) -> None: ...


class Point4d:
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, point: Point4d): ...
    @overload
    def __init__(self, x: float, y: float, z: float, w: float): ...
    @staticmethod
    def Add(point1: Point4d, point2: Point4d) -> Point4d: ...
    def EpsilonEquals(self, other: Point4d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, point: Point4d) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Unset() -> Point4d: ...
    @property
    def W(self) -> float: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @property
    def Z(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @staticmethod
    def Multiply(point: Point4d, d: float) -> Point4d: ...
    def __add__(point1: Point4d, point2: Point4d) -> Point4d: ...
    def __eq__(a: Point4d, b: Point4d) -> bool: ...
    def __ne__(a: Point4d, b: Point4d) -> bool: ...
    @overload
    def __mul__(point: Point4d, d: float) -> Point4d: ...
    @overload
    def __mul__(point1: Point4d, point2: Point4d) -> float: ...
    def __sub__(point1: Point4d, point2: Point4d) -> Point4d: ...
    @W.setter
    def W(self) -> MutableSequence[float]: ...
    @X.setter
    def X(self) -> MutableSequence[float]: ...
    @Y.setter
    def Y(self) -> MutableSequence[float]: ...
    @Z.setter
    def Z(self) -> MutableSequence[float]: ...
    @staticmethod
    def Subtract(point1: Point4d, point2: Point4d) -> Point4d: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Transform(self, xform: Transform) -> None: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class PointCloud(GeometryBase):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: PointCloud): ...
    @overload
    def __init__(self, points: Iterable[Point3d]): ...
    def __iter__(self) -> Iterator[PointCloudItem]: ...
    @overload
    def Add(self, point: Point3d) -> None: ...
    @overload
    def Add(self, point: Point3d, color: Color) -> None: ...
    @overload
    def Add(self, point: Point3d, normal: Vector3d) -> None: ...
    @overload
    def Add(self, point: Point3d, normal: Vector3d, color: Color) -> None: ...
    @overload
    def Add(self, point: Point3d, normal: Vector3d, color: Color, value: float) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d]) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d], colors: Iterable[Color]) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d], normals: Iterable[Vector3d]) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d], normals: Iterable[Vector3d], colors: Iterable[Color]) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d], normals: Iterable[Vector3d], colors: Iterable[Color], values: Iterable[float]) -> None: ...
    def AppendNew(self) -> PointCloudItem: ...
    def AsReadOnlyListOfPoints(self) -> IReadOnlyList: ...
    def ClearColors(self) -> None: ...
    def ClearHiddenFlags(self) -> None: ...
    def ClearNormals(self) -> None: ...
    def ClearPointValues(self) -> None: ...
    def ClosestPoint(self, testPoint: Point3d) -> int: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ContainsColors(self) -> bool: ...
    @property
    def ContainsHiddenFlags(self) -> bool: ...
    @property
    def ContainsNormals(self) -> bool: ...
    @property
    def ContainsPointValues(self) -> bool: ...
    @property
    def Count(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def HiddenPointCount(self) -> int: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> Sequence[int]: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetColors(self) -> Iterable[Color]: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetHashCode(self) -> int: ...
    def GetNormals(self) -> Iterable[Vector3d]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPoints(self) -> Iterable[Point3d]: ...
    def GetPointValues(self) -> Iterable[float]: ...
    @overload
    def GetRandomSubsample(self, numberOfPoints: UInt32) -> PointCloud: ...
    @overload
    def GetRandomSubsample(self, numberOfPoints: UInt32, cancelToken: CancellationToken, progress: IProgress) -> PointCloud: ...
    def GetType(self) -> Type: ...
    def GetUnsafeLock(self, writable: bool) -> PointCloudUnsafeLock: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def Insert(self, index: int, point: Point3d) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, color: Color) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, normal: Vector3d) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, normal: Vector3d, color: Color) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, normal: Vector3d, color: Color, value: float) -> None: ...
    def InsertNew(self, index: int) -> PointCloudItem: ...
    def InsertRange(self, index: int, points: Iterable[Point3d]) -> None: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Merge(self, other: PointCloud) -> None: ...
    def PointAt(self, index: int) -> Point3d: ...
    def ReleaseUnsafeLock(self, pointCloudData: PointCloudUnsafeLock) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    def RemoveRange(self, indices: Iterable[int]) -> int: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class PointCloudItem:
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Color(self) -> Color: ...
    @property
    def Hidden(self) -> bool: ...
    @property
    def Index(self) -> int: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def Normal(self) -> Vector3d: ...
    @property
    def PointValue(self) -> float: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @property
    def Z(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @Color.setter
    def Color(self) -> MutableSequence[Color]: ...
    @Hidden.setter
    def Hidden(self) -> MutableSequence[bool]: ...
    @Location.setter
    def Location(self) -> MutableSequence[Point3d]: ...
    @Normal.setter
    def Normal(self) -> MutableSequence[Vector3d]: ...
    @PointValue.setter
    def PointValue(self) -> MutableSequence[float]: ...
    @X.setter
    def X(self) -> MutableSequence[float]: ...
    @Y.setter
    def Y(self) -> MutableSequence[float]: ...
    @Z.setter
    def Z(self) -> MutableSequence[float]: ...
    def ToString(self) -> str: ...


class PointCloudUnsafeLock:
    def ColorArray(self) -> Tuple[Int32, int]: ...
    def Equals(self, obj: Object) -> bool: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def NormalArray(self) -> Tuple[Vector3d, int]: ...
    def PointArray(self) -> Tuple[Point3d, int]: ...
    def Release(self) -> None: ...
    def ToString(self) -> str: ...
    def ValueArray(self) -> Tuple[Double, int]: ...


class PointContainment(Enum):
    Unset = 0
    Inside = 1
    Outside = 2
    Coincident = 3


class PointFaceRelation(Enum):
    Exterior = 0
    Interior = 1
    Boundary = 2


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class PolyCurve(Curve):
    def __init__(self): ...
    @overload
    def Append(self, line: Line) -> bool: ...
    @overload
    def Append(self, arc: Arc) -> bool: ...
    @overload
    def Append(self, curve: Curve) -> bool: ...
    def AppendSegment(self, curve: Curve) -> bool: ...
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    def CleanUp(self) -> Curve: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    def Dispose(self) -> None: ...
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateCurve(self) -> Curve: ...
    def DuplicatePolyCurve(self) -> PolyCurve: ...
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Explode(self) -> Iterable[Curve]: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @property
    def Degree(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Domain(self) -> Interval: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasGap(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsNested(self) -> bool: ...
    @property
    def IsPeriodic(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PointAtEnd(self) -> Point3d: ...
    @property
    def PointAtStart(self) -> Point3d: ...
    @property
    def SegmentCount(self) -> int: ...
    @property
    def SpanCount(self) -> int: ...
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    def MakeClosed(self, tolerance: float) -> bool: ...
    def MakeDeformable(self) -> bool: ...
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    def PointAt(self, t: float) -> Point3d: ...
    def PointAtLength(self, length: float) -> Point3d: ...
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    def PolyCurveParameter(self, segmentIndex: int, segmentCurveParameter: float) -> float: ...
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    def RemoveNesting(self) -> bool: ...
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SegmentCurve(self, index: int) -> Curve: ...
    def SegmentCurveParameter(self, polycurveParameter: float) -> float: ...
    def SegmentDomain(self, segmentIndex: int) -> Interval: ...
    def SegmentIndex(self, polycurveParameter: float) -> int: ...
    def SegmentIndexes(self, subdomain: Interval) -> Tuple[int, int, int]: ...
    @Domain.setter
    def Domain(self) -> MutableSequence[Interval]: ...
    def SetEndPoint(self, point: Point3d) -> bool: ...
    def SetStartPoint(self, point: Point3d) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    def TorsionAt(self, t: float) -> float: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


from ..Collections import XAccess
from ..Collections import YAccess
from ..Collections import ZAccess
from ..Collections import Point3dList
from ..Collections import RhinoList
from ..Collections import Point3dList
class Polyline(Point3dList):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initialCapacity: int): ...
    @overload
    def __init__(self, collection: Iterable[Point3d]): ...
    def __iter__(self) -> Iterator[Point3d]: ...
    def __getitem__(self, index: int) -> Point3d: ...
    def __setitem__(self, index: int, value: Point3d): ...
    @overload
    def Add(self, item: Point3d) -> None: ...
    @overload
    def Add(self, x: float, y: float, z: float) -> None: ...
    @overload
    def AddRange(self, collection: IEnumerable) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[Point3d]) -> None: ...
    def AsReadOnly(self) -> ReadOnlyCollection: ...
    @overload
    def BinarySearch(self, item: Point3d) -> int: ...
    @overload
    def BinarySearch(self, item: Point3d, comparer: IComparer) -> int: ...
    @overload
    def BinarySearch(self, index: int, count: int, item: Point3d, comparer: IComparer) -> int: ...
    def BreakAtAngles(self, angle: float) -> Iterable[Polyline]: ...
    def CenterPoint(self) -> Point3d: ...
    def Clear(self) -> None: ...
    def ClosestIndex(self, testPoint: Point3d) -> int: ...
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    def CollapseShortSegments(self, tolerance: float) -> int: ...
    def Contains(self, item: Point3d) -> bool: ...
    def ConvertAll(self, converter: Converter) -> RhinoList: ...
    @overload
    def CopyTo(self, array: Iterable[Point3d]) -> None: ...
    @overload
    def CopyTo(self, array: Iterable[Point3d], arrayIndex: int) -> None: ...
    @overload
    def CopyTo(self, index: int, array: Iterable[Point3d], arrayIndex: int, count: int) -> None: ...
    @staticmethod
    def CreateCircumscribedPolygon(circle: Circle, sideCount: int) -> Polyline: ...
    @staticmethod
    def CreateInscribedPolygon(circle: Circle, sideCount: int) -> Polyline: ...
    @staticmethod
    def CreateStarPolygon(circle: Circle, radius: float, cornerCount: int) -> Polyline: ...
    def DeleteShortSegments(self, tolerance: float) -> int: ...
    @overload
    def Duplicate(self) -> Polyline: ...
    @overload
    def Duplicate(self) -> Point3dList: ...
    @overload
    def Duplicate(self) -> RhinoList: ...
    @overload
    def Equals(self, other: Point3dList) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    def Exists(self, match: Predicate) -> bool: ...
    def Find(self, match: Predicate) -> Point3d: ...
    def FindAll(self, match: Predicate) -> RhinoList: ...
    @overload
    def FindIndex(self, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    def FindLast(self, match: Predicate) -> Point3d: ...
    @overload
    def FindLastIndex(self, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    def ForEach(self, action: Action) -> None: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Capacity(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def First(self) -> Point3d: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> Sequence[int]: ...
    @property
    def Last(self) -> Point3d: ...
    @property
    def Length(self) -> float: ...
    @property
    def NullCount(self) -> int: ...
    @property
    def SegmentCount(self) -> int: ...
    @property
    def X(self) -> XAccess: ...
    @property
    def Y(self) -> YAccess: ...
    @property
    def Z(self) -> ZAccess: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetHashCode(self) -> int: ...
    def GetRange(self, index: int, count: int) -> RhinoList: ...
    def GetSegments(self) -> Iterable[Line]: ...
    def GetType(self) -> Type: ...
    @overload
    def IndexOf(self, item: Point3d) -> int: ...
    @overload
    def IndexOf(self, item: Point3d, index: int) -> int: ...
    @overload
    def IndexOf(self, item: Point3d, index: int, count: int) -> int: ...
    def Insert(self, index: int, item: Point3d) -> None: ...
    def InsertRange(self, index: int, collection: Iterable[Point3d]) -> None: ...
    def IsClosedWithinTolerance(self, tolerance: float) -> bool: ...
    @overload
    def LastIndexOf(self, item: Point3d) -> int: ...
    @overload
    def LastIndexOf(self, item: Point3d, index: int) -> int: ...
    @overload
    def LastIndexOf(self, item: Point3d, index: int, count: int) -> int: ...
    def MergeColinearSegments(self, angleTolerance: float, includeSeam: bool) -> int: ...
    def PointAt(self, t: float) -> Point3d: ...
    def ReduceSegments(self, tolerance: float) -> int: ...
    def RemapIndex(self, index: int) -> int: ...
    def Remove(self, item: Point3d) -> bool: ...
    def RemoveAll(self, match: Predicate) -> int: ...
    def RemoveAt(self, index: int) -> None: ...
    def RemoveNearlyEqualSubsequentPoints(self, tolerance: float) -> None: ...
    def RemoveNulls(self) -> int: ...
    def RemoveRange(self, index: int, count: int) -> None: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    def Reverse(self, index: int, count: int) -> None: ...
    def SegmentAt(self, index: int) -> Line: ...
    @Capacity.setter
    def Capacity(self) -> MutableSequence[int]: ...
    @First.setter
    def First(self) -> MutableSequence[Point3d]: ...
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @Last.setter
    def Last(self) -> MutableSequence[Point3d]: ...
    def SetAllX(self, xValue: float) -> None: ...
    def SetAllY(self, yValue: float) -> None: ...
    def SetAllZ(self, zValue: float) -> None: ...
    def Smooth(self, amount: float) -> bool: ...
    @overload
    def Sort(self) -> None: ...
    @overload
    def Sort(self, comparer: IComparer) -> None: ...
    @overload
    def Sort(self, comparison: Comparison) -> None: ...
    @overload
    def Sort(self, keys: Iterable[float]) -> None: ...
    @overload
    def Sort(self, keys: Iterable[int]) -> None: ...
    @overload
    def Sort(self, index: int, count: int, comparer: IComparer) -> None: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ToArray(self) -> Iterable[Point3d]: ...
    def ToNurbsCurve(self) -> NurbsCurve: ...
    def ToPolylineCurve(self) -> PolylineCurve: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> None: ...
    def TriangulateClosedPolyline(self) -> Iterable[MeshFace]: ...
    def Trim(self, domain: Interval) -> Polyline: ...
    def TrimExcess(self) -> None: ...
    def TrueForAll(self, match: Predicate) -> bool: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class PolylineCurve(Curve):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: PolylineCurve): ...
    @overload
    def __init__(self, points: Iterable[Point3d]): ...
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    def Dispose(self) -> None: ...
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateCurve(self) -> Curve: ...
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @property
    def Degree(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Domain(self) -> Interval: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsPeriodic(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def PointAtEnd(self) -> Point3d: ...
    @property
    def PointAtStart(self) -> Point3d: ...
    @property
    def PointCount(self) -> int: ...
    @property
    def SpanCount(self) -> int: ...
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    def MakeClosed(self, tolerance: float) -> bool: ...
    def MakeDeformable(self) -> bool: ...
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    def Parameter(self, index: int) -> float: ...
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    def Point(self, index: int) -> Point3d: ...
    def PointAt(self, t: float) -> Point3d: ...
    def PointAtLength(self, length: float) -> Point3d: ...
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @Domain.setter
    def Domain(self) -> MutableSequence[Interval]: ...
    def SetEndPoint(self, point: Point3d) -> bool: ...
    def SetParameter(self, index: int, parameter: float) -> None: ...
    def SetPoint(self, index: int, point: Point3d) -> None: ...
    def SetStartPoint(self, point: Point3d) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self) -> Polyline: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    def TorsionAt(self, t: float) -> float: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class PreserveEnd(Enum):
    # None = 0
    Position = 1
    Tangency = 2
    Curvature = 3


class QuadRemeshParameters:
    def __init__(self): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AdaptiveQuadCount(self) -> bool: ...
    @property
    def AdaptiveSize(self) -> float: ...
    @property
    def DetectHardEdges(self) -> bool: ...
    @property
    def GuideCurveInfluence(self) -> int: ...
    @property
    def PreserveMeshArrayEdgesMode(self) -> int: ...
    @property
    def SymmetryAxis(self) -> QuadRemeshSymmetryAxis: ...
    @property
    def TargetEdgeLength(self) -> float: ...
    @property
    def TargetQuadCount(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @AdaptiveQuadCount.setter
    def AdaptiveQuadCount(self) -> MutableSequence[bool]: ...
    @AdaptiveSize.setter
    def AdaptiveSize(self) -> MutableSequence[float]: ...
    @DetectHardEdges.setter
    def DetectHardEdges(self) -> MutableSequence[bool]: ...
    @GuideCurveInfluence.setter
    def GuideCurveInfluence(self) -> MutableSequence[int]: ...
    @PreserveMeshArrayEdgesMode.setter
    def PreserveMeshArrayEdgesMode(self) -> MutableSequence[int]: ...
    @SymmetryAxis.setter
    def SymmetryAxis(self) -> MutableSequence[QuadRemeshSymmetryAxis]: ...
    @TargetEdgeLength.setter
    def TargetEdgeLength(self) -> MutableSequence[float]: ...
    @TargetQuadCount.setter
    def TargetQuadCount(self) -> MutableSequence[int]: ...
    def ToString(self) -> str: ...


class QuadRemeshSymmetryAxis(Enum):
    # None = 0
    X = 1
    Y = 2
    Z = 4


class Quaternion:
    def __init__(self, a: float, b: float, c: float, d: float): ...
    @staticmethod
    def CrossProduct(p: Quaternion, q: Quaternion) -> Quaternion: ...
    @staticmethod
    def Distance(p: Quaternion, q: Quaternion) -> float: ...
    def DistanceTo(self, q: Quaternion) -> float: ...
    def EpsilonEquals(self, other: Quaternion, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: Quaternion) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @property
    def A(self) -> float: ...
    @property
    def B(self) -> float: ...
    @property
    def C(self) -> float: ...
    @property
    def Conjugate(self) -> Quaternion: ...
    @property
    def D(self) -> float: ...
    @property
    def I() -> Quaternion: ...
    @property
    def Identity() -> Quaternion: ...
    @property
    def Inverse(self) -> Quaternion: ...
    @property
    def IsScalar(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsVector(self) -> bool: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def J() -> Quaternion: ...
    @property
    def K() -> Quaternion: ...
    @property
    def Length(self) -> float: ...
    @property
    def LengthSquared(self) -> float: ...
    @property
    def Scalar(self) -> float: ...
    @property
    def Vector(self) -> Vector3d: ...
    @property
    def Zero() -> Quaternion: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetRotation(self) -> Tuple[bool, Plane]: ...
    @overload
    def GetRotation(self) -> Tuple[bool, Transform]: ...
    @overload
    def GetRotation(self) -> Tuple[bool, float, Vector3d]: ...
    def GetType(self) -> Type: ...
    def Invert(self) -> bool: ...
    def MatrixForm(self) -> Transform: ...
    def __add__(a: Quaternion, b: Quaternion) -> Quaternion: ...
    def __truediv__(q: Quaternion, y: float) -> Quaternion: ...
    def __eq__(a: Quaternion, b: Quaternion) -> bool: ...
    def __ne__(a: Quaternion, b: Quaternion) -> bool: ...
    @overload
    def __mul__(q: Quaternion, x: int) -> Quaternion: ...
    @overload
    def __mul__(a: Quaternion, b: Quaternion) -> Quaternion: ...
    @overload
    def __mul__(q: Quaternion, x: Single) -> Quaternion: ...
    @overload
    def __mul__(q: Quaternion, x: float) -> Quaternion: ...
    def __sub__(a: Quaternion, b: Quaternion) -> Quaternion: ...
    @staticmethod
    def Product(p: Quaternion, q: Quaternion) -> Quaternion: ...
    def Rotate(self, v: Vector3d) -> Vector3d: ...
    @overload
    @staticmethod
    def Rotation(angle: float, axisOfRotation: Vector3d) -> Quaternion: ...
    @overload
    @staticmethod
    def Rotation(plane0: Plane, plane1: Plane) -> Quaternion: ...
    @A.setter
    def A(self) -> MutableSequence[float]: ...
    @B.setter
    def B(self) -> MutableSequence[float]: ...
    @C.setter
    def C(self) -> MutableSequence[float]: ...
    @D.setter
    def D(self) -> MutableSequence[float]: ...
    def Set(self, a: float, b: float, c: float, d: float) -> None: ...
    @overload
    def SetRotation(self, plane0: Plane, plane1: Plane) -> None: ...
    @overload
    def SetRotation(self, angle: float, axisOfRotation: Vector3d) -> None: ...
    def ToString(self) -> str: ...
    def Unitize(self) -> bool: ...


from ..DocObjects import DimensionStyle
from ..DocObjects import TextHorizontalAlignment
from ..DocObjects import ArrowType
from ..DocObjects import LeaderCurveStyle
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import ViewportInfo
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ZeroSuppression
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class RadialDimension(Dimension):
    def __init__(self): ...
    def AdjustFromPoints(self, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d, rotationInPlane: float) -> bool: ...
    def ClearPropertyOverrides(self) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @staticmethod
    def Create(dimStyle: DimensionStyle, dimtype: AnnotationType, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d) -> RadialDimension: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AlternateBelowLine(self) -> bool: ...
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def AltLengthFactor(self) -> float: ...
    @property
    def AltLengthResolution(self) -> int: ...
    @property
    def AltLengthRoundoff(self) -> float: ...
    @property
    def AltPrefix(self) -> str: ...
    @property
    def AltSuffix(self) -> str: ...
    @property
    def AltToleranceResolution(self) -> int: ...
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @property
    def ArrowSize(self) -> float: ...
    @property
    def BaselineSpacing(self) -> float: ...
    @property
    def CentermarkSize(self) -> float: ...
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @property
    def CenterPoint(self) -> Point2d: ...
    @property
    def DecimalSeparator(self) -> Char: ...
    @property
    def DetailMeasured(self) -> Guid: ...
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def DimensionLineExtension(self) -> float: ...
    @property
    def DimensionScale(self) -> float: ...
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @property
    def DimensionStyleId(self) -> Guid: ...
    @property
    def DimlinePoint(self) -> Point2d: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def DistanceScale(self) -> float: ...
    @property
    def DrawForward(self) -> bool: ...
    @property
    def DrawTextFrame(self) -> bool: ...
    @property
    def ExtensionLineExtension(self) -> float: ...
    @property
    def ExtensionLineOffset(self) -> float: ...
    @property
    def FirstCharFont(self) -> Font: ...
    @property
    def FixedExtensionLength(self) -> float: ...
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @property
    def Font(self) -> Font: ...
    @property
    def FontIndex(self) -> int: ...
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @property
    def ForceDimLine(self) -> bool: ...
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @property
    def FormatWidth(self) -> float: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDiameterDimension(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def KneePoint(self) -> Point2d: ...
    @property
    def LeaderArrowBlockId(self) -> Guid: ...
    @property
    def LeaderArrowSize(self) -> float: ...
    @property
    def LeaderArrowType(self) -> ArrowType: ...
    @property
    def LeaderCurveStyle(self) -> LeaderCurveStyle: ...
    @property
    def LeaderTextHorizontalAlignment(self) -> TextHorizontalAlignment: ...
    @property
    def LengthFactor(self) -> float: ...
    @property
    def LengthResolution(self) -> int: ...
    @property
    def LengthRoundoff(self) -> float: ...
    @property
    def MaskColor(self) -> Color: ...
    @property
    def MaskColorSource(self) -> MaskType: ...
    @property
    def MaskEnabled(self) -> bool: ...
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @property
    def MaskOffset(self) -> float: ...
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @property
    def NumericValue(self) -> float: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @property
    def PlainText(self) -> str: ...
    @property
    def PlainTextWithFields(self) -> str: ...
    @property
    def PlainUserText(self) -> str: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Prefix(self) -> str: ...
    @property
    def RadiusPoint(self) -> Point2d: ...
    @property
    def RichText(self) -> str: ...
    @property
    def Suffix(self) -> str: ...
    @property
    def SuppressExtension1(self) -> bool: ...
    @property
    def SuppressExtension2(self) -> bool: ...
    @property
    def Text(self) -> str: ...
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @property
    def TextFit(self) -> TextFit: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @property
    def TextHeight(self) -> float: ...
    @property
    def TextIsWrapped(self) -> bool: ...
    @property
    def TextLocation(self) -> TextLocation: ...
    @property
    def TextModelWidth(self) -> float: ...
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @property
    def TextPosition(self) -> Point2d: ...
    @property
    def TextRotation(self) -> float: ...
    @property
    def TextRotationDegrees(self) -> float: ...
    @property
    def TextRotationRadians(self) -> float: ...
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @property
    def ToleranceHeightScale(self) -> float: ...
    @property
    def ToleranceLowerValue(self) -> float: ...
    @property
    def ToleranceResolution(self) -> int: ...
    @property
    def ToleranceUpperValue(self) -> float: ...
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d]: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Iterable[Line]]: ...
    def GetDistanceDisplayText(self, unitsystem: UnitSystem, style: DimensionStyle) -> str: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    def GetTextRectangle(self) -> Tuple[bool, Iterable[Point3d]]: ...
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsAllBold(self) -> bool: ...
    def IsAllItalic(self) -> bool: ...
    def IsAllUnderlined(self) -> bool: ...
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @AlternateBelowLine.setter
    def AlternateBelowLine(self) -> MutableSequence[bool]: ...
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @AltLengthFactor.setter
    def AltLengthFactor(self) -> MutableSequence[float]: ...
    @AltLengthResolution.setter
    def AltLengthResolution(self) -> MutableSequence[int]: ...
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self) -> MutableSequence[float]: ...
    @AltPrefix.setter
    def AltPrefix(self) -> MutableSequence[str]: ...
    @AltSuffix.setter
    def AltSuffix(self) -> MutableSequence[str]: ...
    @AltToleranceResolution.setter
    def AltToleranceResolution(self) -> MutableSequence[int]: ...
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self) -> MutableSequence[bool]: ...
    @AltZeroSuppression.setter
    def AltZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    @AnnotationType.setter
    def AnnotationType(self) -> MutableSequence[AnnotationType]: ...
    @ArrowBlockId1.setter
    def ArrowBlockId1(self) -> MutableSequence[Guid]: ...
    @ArrowBlockId2.setter
    def ArrowBlockId2(self) -> MutableSequence[Guid]: ...
    @ArrowFit.setter
    def ArrowFit(self) -> MutableSequence[ArrowFit]: ...
    @ArrowheadType1.setter
    def ArrowheadType1(self) -> MutableSequence[ArrowType]: ...
    @ArrowheadType2.setter
    def ArrowheadType2(self) -> MutableSequence[ArrowType]: ...
    @ArrowSize.setter
    def ArrowSize(self) -> MutableSequence[float]: ...
    @BaselineSpacing.setter
    def BaselineSpacing(self) -> MutableSequence[float]: ...
    @CentermarkSize.setter
    def CentermarkSize(self) -> MutableSequence[float]: ...
    @CentermarkStyle.setter
    def CentermarkStyle(self) -> MutableSequence[CenterMarkStyle]: ...
    @CenterPoint.setter
    def CenterPoint(self) -> MutableSequence[Point2d]: ...
    @DecimalSeparator.setter
    def DecimalSeparator(self) -> MutableSequence[Char]: ...
    @DetailMeasured.setter
    def DetailMeasured(self) -> MutableSequence[Guid]: ...
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DimensionLineExtension.setter
    def DimensionLineExtension(self) -> MutableSequence[float]: ...
    @DimensionScale.setter
    def DimensionScale(self) -> MutableSequence[float]: ...
    @DimensionStyleId.setter
    def DimensionStyleId(self) -> MutableSequence[Guid]: ...
    @DimlinePoint.setter
    def DimlinePoint(self) -> MutableSequence[Point2d]: ...
    @DistanceScale.setter
    def DistanceScale(self) -> MutableSequence[float]: ...
    @DrawForward.setter
    def DrawForward(self) -> MutableSequence[bool]: ...
    @DrawTextFrame.setter
    def DrawTextFrame(self) -> MutableSequence[bool]: ...
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self) -> MutableSequence[float]: ...
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self) -> MutableSequence[float]: ...
    @FixedExtensionLength.setter
    def FixedExtensionLength(self) -> MutableSequence[float]: ...
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self) -> MutableSequence[bool]: ...
    @Font.setter
    def Font(self) -> MutableSequence[Font]: ...
    @FontIndex.setter
    def FontIndex(self) -> MutableSequence[int]: ...
    @ForceArrowPosition.setter
    def ForceArrowPosition(self) -> MutableSequence[ForceArrow]: ...
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self) -> MutableSequence[bool]: ...
    @ForceDimLine.setter
    def ForceDimLine(self) -> MutableSequence[bool]: ...
    @ForceTextPosition.setter
    def ForceTextPosition(self) -> MutableSequence[ForceText]: ...
    @FormatWidth.setter
    def FormatWidth(self) -> MutableSequence[float]: ...
    @LeaderArrowBlockId.setter
    def LeaderArrowBlockId(self) -> MutableSequence[Guid]: ...
    @LeaderArrowSize.setter
    def LeaderArrowSize(self) -> MutableSequence[float]: ...
    @LeaderArrowType.setter
    def LeaderArrowType(self) -> MutableSequence[ArrowType]: ...
    @LeaderCurveStyle.setter
    def LeaderCurveStyle(self) -> MutableSequence[LeaderCurveStyle]: ...
    @LeaderTextHorizontalAlignment.setter
    def LeaderTextHorizontalAlignment(self) -> MutableSequence[TextHorizontalAlignment]: ...
    @LengthFactor.setter
    def LengthFactor(self) -> MutableSequence[float]: ...
    @LengthResolution.setter
    def LengthResolution(self) -> MutableSequence[int]: ...
    @LengthRoundoff.setter
    def LengthRoundoff(self) -> MutableSequence[float]: ...
    @MaskColor.setter
    def MaskColor(self) -> MutableSequence[Color]: ...
    @MaskColorSource.setter
    def MaskColorSource(self) -> MutableSequence[MaskType]: ...
    @MaskEnabled.setter
    def MaskEnabled(self) -> MutableSequence[bool]: ...
    @MaskFrame.setter
    def MaskFrame(self) -> MutableSequence[MaskFrame]: ...
    @MaskOffset.setter
    def MaskOffset(self) -> MutableSequence[float]: ...
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self) -> MutableSequence[bool]: ...
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self) -> MutableSequence[DimensionStyle]: ...
    @PlainText.setter
    def PlainText(self) -> MutableSequence[str]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @Prefix.setter
    def Prefix(self) -> MutableSequence[str]: ...
    @RadiusPoint.setter
    def RadiusPoint(self) -> MutableSequence[Point2d]: ...
    @RichText.setter
    def RichText(self) -> MutableSequence[str]: ...
    @Suffix.setter
    def Suffix(self) -> MutableSequence[str]: ...
    @SuppressExtension1.setter
    def SuppressExtension1(self) -> MutableSequence[bool]: ...
    @SuppressExtension2.setter
    def SuppressExtension2(self) -> MutableSequence[bool]: ...
    @Text.setter
    def Text(self) -> MutableSequence[str]: ...
    @TextAngleType.setter
    def TextAngleType(self) -> MutableSequence[LeaderContentAngleStyle]: ...
    @TextFit.setter
    def TextFit(self) -> MutableSequence[TextFit]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextHeight.setter
    def TextHeight(self) -> MutableSequence[float]: ...
    @TextIsWrapped.setter
    def TextIsWrapped(self) -> MutableSequence[bool]: ...
    @TextLocation.setter
    def TextLocation(self) -> MutableSequence[TextLocation]: ...
    @TextOrientation.setter
    def TextOrientation(self) -> MutableSequence[TextOrientation]: ...
    @TextPosition.setter
    def TextPosition(self) -> MutableSequence[Point2d]: ...
    @TextRotation.setter
    def TextRotation(self) -> MutableSequence[float]: ...
    @TextRotationDegrees.setter
    def TextRotationDegrees(self) -> MutableSequence[float]: ...
    @TextRotationRadians.setter
    def TextRotationRadians(self) -> MutableSequence[float]: ...
    @ToleranceFormat.setter
    def ToleranceFormat(self) -> MutableSequence[ToleranceDisplayFormat]: ...
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self) -> MutableSequence[float]: ...
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self) -> MutableSequence[float]: ...
    @ToleranceResolution.setter
    def ToleranceResolution(self) -> MutableSequence[int]: ...
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self) -> MutableSequence[float]: ...
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self) -> MutableSequence[bool]: ...
    @ZeroSuppression.setter
    def ZeroSuppression(self) -> MutableSequence[ZeroSuppression]: ...
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetBold(self, set_on: bool) -> bool: ...
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    def SetItalic(self, set_on: bool) -> bool: ...
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    def SetUnderline(self, set_on: bool) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    def WrapText(self) -> None: ...


class RailType(Enum):
    DistanceFromEdge = 0
    RollingBall = 1
    DistanceBetweenRails = 2


class Ray3d:
    def __init__(self, position: Point3d, direction: Vector3d): ...
    def EpsilonEquals(self, other: Ray3d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, ray: Ray3d) -> bool: ...
    @property
    def Direction(self) -> Vector3d: ...
    @property
    def Position(self) -> Point3d: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def __eq__(a: Ray3d, b: Ray3d) -> bool: ...
    def __ne__(a: Ray3d, b: Ray3d) -> bool: ...
    def PointAt(self, t: float) -> Point3d: ...
    def ToString(self) -> str: ...


class Rectangle3d:
    @overload
    def __init__(self, plane: Plane, width: float, height: float): ...
    @overload
    def __init__(self, plane: Plane, width: Interval, height: Interval): ...
    @overload
    def __init__(self, plane: Plane, cornerA: Point3d, cornerB: Point3d): ...
    @overload
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, point: Point3d, includeInterior: bool) -> Point3d: ...
    @overload
    def Contains(self, pt: Point3d) -> PointContainment: ...
    @overload
    def Contains(self, x: float, y: float) -> PointContainment: ...
    def Corner(self, index: int) -> Point3d: ...
    @overload
    @staticmethod
    def CreateFromPolyline(polyline: Iterable[Point3d]) -> Rectangle3d: ...
    @overload
    @staticmethod
    def CreateFromPolyline(polyline: Iterable[Point3d]) -> Tuple[Rectangle3d, float, float]: ...
    def EpsilonEquals(self, other: Rectangle3d, epsilon: float) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Area(self) -> float: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Circumference(self) -> float: ...
    @property
    def Height(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Unset() -> Rectangle3d: ...
    @property
    def Width(self) -> float: ...
    @property
    def X(self) -> Interval: ...
    @property
    def Y(self) -> Interval: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def MakeIncreasing(self) -> None: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAt(self, x: float, y: float) -> Point3d: ...
    @overload
    def RecenterPlane(self, origin: Point3d) -> None: ...
    @overload
    def RecenterPlane(self, index: int) -> None: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @X.setter
    def X(self) -> MutableSequence[Interval]: ...
    @Y.setter
    def Y(self) -> MutableSequence[Interval]: ...
    def ToNurbsCurve(self) -> NurbsCurve: ...
    def ToPolyline(self) -> Polyline: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...


class ReduceMeshParameters:
    def __init__(self): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Accuracy(self) -> int: ...
    @property
    def AllowDistortion(self) -> bool: ...
    @property
    def CancelToken(self) -> CancellationToken: ...
    @property
    def DesiredPolygonCount(self) -> int: ...
    @property
    def Error(self) -> str: ...
    @property
    def FaceTags(self) -> Iterable[int]: ...
    @property
    def LockedComponents(self) -> Iterable[ComponentIndex]: ...
    @property
    def NormalizeMeshSize(self) -> bool: ...
    @property
    def ProgressReporter(self) -> IProgress: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @Accuracy.setter
    def Accuracy(self) -> MutableSequence[int]: ...
    @AllowDistortion.setter
    def AllowDistortion(self) -> MutableSequence[bool]: ...
    @CancelToken.setter
    def CancelToken(self) -> MutableSequence[CancellationToken]: ...
    @DesiredPolygonCount.setter
    def DesiredPolygonCount(self) -> MutableSequence[int]: ...
    @FaceTags.setter
    def FaceTags(self) -> MutableSequence[Iterable[int]]: ...
    @LockedComponents.setter
    def LockedComponents(self) -> MutableSequence[Iterable[ComponentIndex]]: ...
    @NormalizeMeshSize.setter
    def NormalizeMeshSize(self) -> MutableSequence[bool]: ...
    @ProgressReporter.setter
    def ProgressReporter(self) -> MutableSequence[IProgress]: ...
    def ToString(self) -> str: ...


class RegionContainment(Enum):
    Disjoint = 0
    MutualIntersection = 1
    AInsideB = 2
    BInsideA = 3


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class RevSurface(Surface):
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(revoluteCurve: Curve, axisOfRevolution: Line) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revoluteLine: Line, axisOfRevolution: Line) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revolutePolyline: Polyline, axisOfRevolution: Line) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revoluteCurve: Curve, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revoluteLine: Line, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revolutePolyline: Polyline, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @staticmethod
    def CreateFromCone(cone: Cone) -> RevSurface: ...
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder) -> RevSurface: ...
    @staticmethod
    def CreateFromSphere(sphere: Sphere) -> RevSurface: ...
    @staticmethod
    def CreateFromTorus(torus: Torus) -> RevSurface: ...
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Degree(self, direction: int) -> int: ...
    def Dispose(self) -> None: ...
    def Domain(self, direction: int) -> Interval: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @property
    def Angle(self) -> Interval: ...
    @property
    def Axis(self) -> Line: ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    def IsAtSeam(self, u: float, v: float) -> int: ...
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    def SpanCount(self, direction: int) -> int: ...
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    def ToBrep(self) -> Brep: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


class RTree:
    def __init__(self): ...
    def Clear(self) -> None: ...
    @staticmethod
    def CreateFromPointArray(points: Iterable[Point3d]) -> RTree: ...
    @staticmethod
    def CreateMeshFaceTree(mesh: Mesh) -> RTree: ...
    @staticmethod
    def CreatePointCloudTree(cloud: PointCloud) -> RTree: ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Count(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    def Insert(self, point: Point3d, elementId: int) -> bool: ...
    @overload
    def Insert(self, point: Point3d, elementId: IntPtr) -> bool: ...
    @overload
    def Insert(self, box: BoundingBox, elementId: int) -> bool: ...
    @overload
    def Insert(self, box: BoundingBox, elementId: IntPtr) -> bool: ...
    @overload
    def Insert(self, point: Point2d, elementId: int) -> bool: ...
    @overload
    def Insert(self, point: Point2d, elementId: IntPtr) -> bool: ...
    @staticmethod
    def Point3dClosestPoints(hayPoints: Iterable[Point3d], needlePts: Iterable[Point3d], limitDistance: float) -> Iterable[Iterable[int]]: ...
    @staticmethod
    def Point3dKNeighbors(hayPoints: Iterable[Point3d], needlePts: Iterable[Point3d], amount: int) -> Iterable[Iterable[int]]: ...
    @staticmethod
    def PointCloudClosestPoints(pointcloud: PointCloud, needlePts: Iterable[Point3d], limitDistance: float) -> Iterable[Iterable[int]]: ...
    @staticmethod
    def PointCloudKNeighbors(pointcloud: PointCloud, needlePts: Iterable[Point3d], amount: int) -> Iterable[Iterable[int]]: ...
    @overload
    def Remove(self, box: BoundingBox, elementId: IntPtr) -> bool: ...
    @overload
    def Remove(self, box: BoundingBox, elementId: int) -> bool: ...
    @overload
    def Remove(self, point: Point3d, elementId: IntPtr) -> bool: ...
    @overload
    def Remove(self, point: Point3d, elementId: int) -> bool: ...
    @overload
    def Remove(self, point: Point2d, elementId: int) -> bool: ...
    @overload
    def Search(self, box: BoundingBox, callback: EventHandler) -> bool: ...
    @overload
    def Search(self, sphere: Sphere, callback: EventHandler) -> bool: ...
    @overload
    def Search(self, sphere: Sphere, callback: EventHandler, tag: Object) -> bool: ...
    @overload
    def Search(self, box: BoundingBox, callback: EventHandler, tag: Object) -> bool: ...
    @staticmethod
    def SearchOverlaps(treeA: RTree, treeB: RTree, tolerance: float, callback: EventHandler) -> bool: ...
    def ToString(self) -> str: ...


class RTreeEventArgs:
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Cancel(self) -> bool: ...
    @property
    def Id(self) -> int: ...
    @property
    def IdB(self) -> int: ...
    @property
    def IdBPtr(self) -> IntPtr: ...
    @property
    def IdPtr(self) -> IntPtr: ...
    @property
    def SearchBoundingBox(self) -> BoundingBox: ...
    @property
    def SearchSphere(self) -> Sphere: ...
    @property
    def Tag(self) -> Object: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @Cancel.setter
    def Cancel(self) -> MutableSequence[bool]: ...
    @SearchBoundingBox.setter
    def SearchBoundingBox(self) -> MutableSequence[BoundingBox]: ...
    @SearchSphere.setter
    def SearchSphere(self) -> MutableSequence[Sphere]: ...
    @Tag.setter
    def Tag(self) -> MutableSequence[Object]: ...
    def ToString(self) -> str: ...


class ShrinkDisableSide(Enum):
    ShrinkAllSides = 0
    DoNotShrinkWestSide = 1
    DoNotShrinkSouthSide = 2
    DoNotShrinkEastSide = 4
    DoNotShrinkNorthSide = 8


class ShutLiningCurveInfo:
    def __init__(self, curve: Curve, radius: float, profile: int, pull: bool, isBump: bool, curveIntervals: Iterable[Interval], enabled: bool): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def CurveIntervals(self) -> ReadOnlyCollection: ...
    @property
    def Enabled(self) -> bool: ...
    @property
    def IsBump(self) -> bool: ...
    @property
    def Profile(self) -> int: ...
    @property
    def Pull(self) -> bool: ...
    @property
    def Radius(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


class SideFill(Enum):
    SideUnset = 0
    SideSurface = 1
    SideVoid = 2
    OtherSurface = 3


from ..DocObjects import ViewportInfo
class Silhouette:
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, perspectiveCameraLocation: Point3d, tolerance: float, angleToleranceRadians: float) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, parallelCameraDirection: Vector3d, tolerance: float, angleToleranceRadians: float) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, viewport: ViewportInfo, tolerance: float, angleToleranceRadians: float) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, perspectiveCameraLocation: Point3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Plane], cancelToken: CancellationToken) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, parallelCameraDirection: Vector3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Plane], cancelToken: CancellationToken) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, viewport: ViewportInfo, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Plane], cancelToken: CancellationToken) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def ComputeDraftCurve(geometry: GeometryBase, draftAngle: float, pullDirection: Vector3d, tolerance: float, angleToleranceRadians: float) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def ComputeDraftCurve(geometry: GeometryBase, draftAngle: float, pullDirection: Vector3d, tolerance: float, angleToleranceRadians: float, cancelToken: CancellationToken) -> Iterable[Silhouette]: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def GeometryComponentIndex(self) -> ComponentIndex: ...
    @property
    def SilhouetteType(self) -> SilhouetteType: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


class SilhouetteType(Enum):
    # None = 0
    Projecting = 1
    TangentProjects = 2
    Tangent = 4
    Crease = 8
    Boundary = 16
    NonSilhouetteCrease = 256
    NonSilhouetteTangent = 512
    NonSilhouetteSeam = 1024
    SectionCut = 4096
    MiscellaneousFeature = 8192
    DraftCurve = 32768


class SmoothingCoordinateSystem(Enum):
    World = 0
    CPlane = 1
    Object = 2


class SpaceMorph:
    def Equals(self, obj: Object) -> bool: ...
    @property
    def PreserveStructure(self) -> bool: ...
    @property
    def QuickPreview(self) -> bool: ...
    @property
    def Tolerance(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @staticmethod
    def IsMorphable(geometry: GeometryBase) -> bool: ...
    @overload
    def Morph(self, geometry: GeometryBase) -> bool: ...
    @overload
    def Morph(self, plane: Plane) -> Tuple[bool, Plane]: ...
    def MorphPoint(self, point: Point3d) -> Point3d: ...
    @PreserveStructure.setter
    def PreserveStructure(self) -> MutableSequence[bool]: ...
    @QuickPreview.setter
    def QuickPreview(self) -> MutableSequence[bool]: ...
    @Tolerance.setter
    def Tolerance(self) -> MutableSequence[float]: ...
    def ToString(self) -> str: ...


class Sphere:
    @overload
    def __init__(self, center: Point3d, radius: float): ...
    @overload
    def __init__(self, equatorialPlane: Plane, radius: float): ...
    def ClosestParameter(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    def EpsilonEquals(self, other: Sphere, epsilon: float) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @staticmethod
    def FitSphereToPoints(points: Iterable[Point3d]) -> Sphere: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Diameter(self) -> float: ...
    @property
    def EquatorialPlane(self) -> Plane: ...
    @property
    def EquitorialPlane(self) -> Plane: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def NorthPole(self) -> Point3d: ...
    @property
    def Radius(self) -> float: ...
    @property
    def SouthPole(self) -> Point3d: ...
    @property
    def Unset() -> Sphere: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def LatitudeDegrees(self, degrees: float) -> Circle: ...
    def LatitudeRadians(self, radians: float) -> Circle: ...
    def LongitudeDegrees(self, degrees: float) -> Circle: ...
    def LongitudeRadians(self, radians: float) -> Circle: ...
    def NormalAt(self, longitudeRadians: float, latitudeRadians: float) -> Vector3d: ...
    def PointAt(self, longitudeRadians: float, latitudeRadians: float) -> Point3d: ...
    @overload
    def Rotate(self, angleRadians: float, axisOfRotation: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, axisOfRotation: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @Center.setter
    def Center(self) -> MutableSequence[Point3d]: ...
    @Diameter.setter
    def Diameter(self) -> MutableSequence[float]: ...
    @EquatorialPlane.setter
    def EquatorialPlane(self) -> MutableSequence[Plane]: ...
    @EquitorialPlane.setter
    def EquitorialPlane(self) -> MutableSequence[Plane]: ...
    @Radius.setter
    def Radius(self) -> MutableSequence[float]: ...
    def ToBrep(self) -> Brep: ...
    def ToNurbsSurface(self) -> NurbsSurface: ...
    def ToRevSurface(self) -> RevSurface: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    def Translate(self, delta: Vector3d) -> bool: ...


class SquishDeformation(Enum):
    Free = 0
    StretchMostly = 1
    StretchOnly = 2
    CompressMostly = 3
    CompressOnly = 4
    Custom = 5


class Squisher:
    def __init__(self): ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Get2dMesh(self) -> Mesh: ...
    def Get3dMesh(self) -> Mesh: ...
    def GetHashCode(self) -> int: ...
    def GetMesh2dEdges(self) -> Iterable[Line]: ...
    def GetMesh3dEdges(self) -> Iterable[Line]: ...
    def GetType(self) -> Type: ...
    @staticmethod
    def Is2dPatternSquished(geometry: GeometryBase) -> bool: ...
    @staticmethod
    def SquishBack2dMarks(squishedGeometry: GeometryBase, marks: Iterable[GeometryBase]) -> Iterable[GeometryBase]: ...
    def SquishCurve(self, curve: Curve) -> PolylineCurve: ...
    @overload
    def SquishMesh(self, sp: SquishParameters, mesh3d: Mesh) -> Mesh: ...
    @overload
    def SquishMesh(self, sp: SquishParameters, mesh3d: Mesh, marks: Iterable[GeometryBase], squished_marks_out: List) -> Mesh: ...
    def SquishPoint(self, point: Point3d) -> Tuple[bool, Point3d]: ...
    @overload
    def SquishSurface(self, sp: SquishParameters, surface: Surface) -> Brep: ...
    @overload
    def SquishSurface(self, sp: SquishParameters, surface: Surface, marks: Iterable[GeometryBase], squished_marks_out: List) -> Brep: ...
    def SquishTextDot(self, textDot: TextDot) -> TextDot: ...
    def ToString(self) -> str: ...


class SquishFlatteningAlgorithm(Enum):
    Geometric = 0
    PhysicalStress = 1


class SquishParameters:
    def __init__(self): ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AbsoluteLimit(self) -> float: ...
    @property
    def Algorithm(self) -> SquishFlatteningAlgorithm: ...
    @property
    def BoundaryCompressConstant(self) -> float: ...
    @property
    def BoundaryStretchConstant(self) -> float: ...
    @property
    def Default() -> SquishParameters: ...
    @property
    def InteriorCompressConstant(self) -> float: ...
    @property
    def InteriorStretchConstant(self) -> float: ...
    @property
    def PreserveTopology(self) -> bool: ...
    @property
    def SaveMapping(self) -> bool: ...
    def GetHashCode(self) -> int: ...
    def GetSpringConstants(self) -> Tuple[bool, float, float]: ...
    def GetType(self) -> Type: ...
    @AbsoluteLimit.setter
    def AbsoluteLimit(self) -> MutableSequence[float]: ...
    @Algorithm.setter
    def Algorithm(self) -> MutableSequence[SquishFlatteningAlgorithm]: ...
    @BoundaryCompressConstant.setter
    def BoundaryCompressConstant(self) -> MutableSequence[float]: ...
    @BoundaryStretchConstant.setter
    def BoundaryStretchConstant(self) -> MutableSequence[float]: ...
    @InteriorCompressConstant.setter
    def InteriorCompressConstant(self) -> MutableSequence[float]: ...
    @InteriorStretchConstant.setter
    def InteriorStretchConstant(self) -> MutableSequence[float]: ...
    @PreserveTopology.setter
    def PreserveTopology(self) -> MutableSequence[bool]: ...
    @SaveMapping.setter
    def SaveMapping(self) -> MutableSequence[bool]: ...
    def SetDeformation(self, deformation: SquishDeformation, bPreserveBoundary: bool, boundaryStretchConstant: float, boundaryCompressConstant: float, interiorStretchConstant: float, interiorCompressConstant: float) -> None: ...
    def SetSpringConstants(self, boundaryBias: float, deformationBias: float) -> None: ...
    def ToString(self) -> str: ...


from .Collections import SubDFaceList
from .Collections import SubDVertexList
from .Collections import SubDEdgeList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class SubD(GeometryBase):
    def __init__(self): ...
    def ClearEvaluationCache(self) -> None: ...
    def ComponentFromComponentIndex(self, componentIndex: ComponentIndex) -> SubDComponent: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, circumferenceFaceCount: UInt32, heightFaceCount: UInt32, endCapStyle: SubDEndCapStyle, endCapEdgeTag: SubDEdgeTag, radiusLocation: SubDComponentLocation) -> SubD: ...
    @staticmethod
    def CreateFromLoft(curves: Iterable[NurbsCurve], closed: bool, addCorners: bool, addCreases: bool, divisions: int) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromMesh(mesh: Mesh) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromMesh(mesh: Mesh, options: SubDCreationOptions) -> SubD: ...
    @staticmethod
    def CreateFromSurface(surface: Surface, method: SubDFromSurfaceMethods, corners: bool) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: NurbsCurve, rail2: NurbsCurve, shapes: Iterable[NurbsCurve], closed: bool, addCorners: bool) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: NurbsCurve, shapes: Iterable[NurbsCurve], closed: bool, addCorners: bool, roadlikeFrame: bool, roadlikeNormal: Vector3d) -> SubD: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def Edges(self) -> SubDEdgeList: ...
    @property
    def Empty() -> SubD: ...
    @property
    def Faces(self) -> SubDFaceList: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @property
    def Vertices(self) -> SubDVertexList: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def InterpolateSurfacePoints(self, surfacePoints: Iterable[Point3d]) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @staticmethod
    def JoinSubDs(subdsToJoin: Iterable[SubD], tolerance: float, joinedEdgesAreCreases: bool) -> Iterable[SubD]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float) -> bool: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...
    def Offset(self, distance: float, solidify: bool) -> SubD: ...
    def PackFaces(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def Subdivide(self, count: int) -> bool: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToBrep(self, options: SubDToBrepOptions) -> Brep: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    def UpdateAllTagsAndSectorCoefficients(self) -> UInt32: ...


class SubDAutomaticMeshToSubDContext(Enum):
    Unset = 0
    Rhino5BoxModeTSpline = 1
    FBXMeshWithDivisionLevels = 2


class SubDChainType(Enum):
    Unset = 0
    MixedTag = 1
    EqualEdgeTag = 2
    EqualEdgeAndVertexTag = 3
    EqualEdgeTagAndOrdinary = 4
    EqualEdgeAndVertexTagAndOrdinary = 5


class SubDComponent:
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Id(self) -> UInt32: ...
    @property
    def IsDamaged(self) -> bool: ...
    @property
    def IsDeleted(self) -> bool: ...
    @property
    def IsHidden(self) -> bool: ...
    @property
    def IsHighlighted(self) -> bool: ...
    @property
    def IsLocked(self) -> bool: ...
    @property
    def IsSelected(self) -> bool: ...
    @property
    def ParentSubD(self) -> SubD: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def ToString(self) -> str: ...


class SubDComponentLocation(Enum):
    Unset = 0
    ControlNet = 1
    Surface = 2


class SubDCreationOptions:
    def __init__(self): ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def ConcaveCornerTest(self) -> ConcaveCornerOption: ...
    @property
    def ConvexCornersAndInteriorCreases() -> SubDCreationOptions: ...
    @property
    def ConvexCornerTest(self) -> ConvexCornerOption: ...
    @property
    def InteriorCreases() -> SubDCreationOptions: ...
    @property
    def InteriorCreaseTest(self) -> InteriorCreaseOption: ...
    @property
    def InterpolateMeshVertices(self) -> bool: ...
    @property
    def MaximumConvexCornerAngleRadians(self) -> float: ...
    @property
    def MaximumConvexCornerEdgeCount(self) -> UInt32: ...
    @property
    def MinimumConcaveCornerAngleRadians(self) -> float: ...
    @property
    def MinimumConcaveCornerEdgeCount(self) -> UInt32: ...
    @property
    def Smooth() -> SubDCreationOptions: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @ConcaveCornerTest.setter
    def ConcaveCornerTest(self) -> MutableSequence[ConcaveCornerOption]: ...
    @ConvexCornerTest.setter
    def ConvexCornerTest(self) -> MutableSequence[ConvexCornerOption]: ...
    @InteriorCreaseTest.setter
    def InteriorCreaseTest(self) -> MutableSequence[InteriorCreaseOption]: ...
    @InterpolateMeshVertices.setter
    def InterpolateMeshVertices(self) -> MutableSequence[bool]: ...
    @MaximumConvexCornerAngleRadians.setter
    def MaximumConvexCornerAngleRadians(self) -> MutableSequence[float]: ...
    @MaximumConvexCornerEdgeCount.setter
    def MaximumConvexCornerEdgeCount(self) -> MutableSequence[UInt32]: ...
    @MinimumConcaveCornerAngleRadians.setter
    def MinimumConcaveCornerAngleRadians(self) -> MutableSequence[float]: ...
    @MinimumConcaveCornerEdgeCount.setter
    def MinimumConcaveCornerEdgeCount(self) -> MutableSequence[UInt32]: ...
    def ToString(self) -> str: ...


class SubDDisplayParameters:
    def __init__(self): ...
    @staticmethod
    def AbsoluteDisplayDensityFromSubD(adaptiveSubDDisplayDensity: UInt32, subd: SubD) -> UInt32: ...
    @staticmethod
    def AbsoluteDisplayDensityFromSubDFaceCount(adaptiveSubDDisplayDensity: UInt32, subDFaceCount: UInt32) -> UInt32: ...
    @staticmethod
    def ClampDisplayDensity(displayDensity: UInt32) -> UInt32: ...
    @staticmethod
    def Coarse() -> SubDDisplayParameters: ...
    @staticmethod
    def CreateFromAbsoluteDisplayDensity(absoluteSubDDisplayDensity: UInt32) -> SubDDisplayParameters: ...
    @staticmethod
    def CreateFromDisplayDensity(adaptiveSubDDisplayDensity: UInt32) -> SubDDisplayParameters: ...
    @staticmethod
    def CreateFromMeshDensity(normalizedMeshDensity: float) -> SubDDisplayParameters: ...
    @staticmethod
    def Default() -> SubDDisplayParameters: ...
    def DisplayDensity(self, subd: SubD) -> UInt32: ...
    def Dispose(self) -> None: ...
    @staticmethod
    def Empty() -> SubDDisplayParameters: ...
    def Equals(self, obj: Object) -> bool: ...
    @staticmethod
    def ExtraCoarse() -> SubDDisplayParameters: ...
    @staticmethod
    def ExtraFine() -> SubDDisplayParameters: ...
    @staticmethod
    def Fine() -> SubDDisplayParameters: ...
    @property
    def AdaptiveDisplayMeshQuadMaximum() -> UInt32: ...
    @property
    def DisplayDensityIsAbsolute(self) -> bool: ...
    @property
    def DisplayDensityIsAdaptive(self) -> bool: ...
    @property
    def MeshLocation(self) -> SubDComponentLocation: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @staticmethod
    def Medium() -> SubDDisplayParameters: ...
    @MeshLocation.setter
    def MeshLocation(self) -> MutableSequence[SubDComponentLocation]: ...
    def SetAbsoluteDisplayDensity(self, absoluteDisplayDensity: UInt32) -> None: ...
    def SetAdaptiveDisplayDensity(self, adaptiveDisplayDensity: UInt32) -> None: ...
    def ToString(self) -> str: ...


class SubDEdge(SubDComponent):
    def Equals(self, obj: Object) -> bool: ...
    def FaceAt(self, index: int) -> SubDFace: ...
    @property
    def ControlNetLine(self) -> Line: ...
    @property
    def FaceCount(self) -> int: ...
    @property
    def Id(self) -> UInt32: ...
    @property
    def IsDamaged(self) -> bool: ...
    @property
    def IsDeleted(self) -> bool: ...
    @property
    def IsHidden(self) -> bool: ...
    @property
    def IsHighlighted(self) -> bool: ...
    @property
    def IsLocked(self) -> bool: ...
    @property
    def IsSelected(self) -> bool: ...
    @property
    def ParentSubD(self) -> SubD: ...
    @property
    def Tag(self) -> SubDEdgeTag: ...
    @property
    def VertexFrom(self) -> SubDVertex: ...
    @property
    def VertexTo(self) -> SubDVertex: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @Tag.setter
    def Tag(self) -> MutableSequence[SubDEdgeTag]: ...
    def ToNurbsCurve(self, clampEnds: bool) -> NurbsCurve: ...
    def ToString(self) -> str: ...


class SubDEdgeTag(Enum):
    Unset = 0
    Smooth = 1
    Crease = 2
    SmoothX = 4


class SubDEndCapStyle(Enum):
    Unset = 0
    # None = 1
    Triangles = 2
    Quads = 3
    Ngon = 4


class SubDFace(SubDComponent):
    def ComponentIndex(self) -> ComponentIndex: ...
    def EdgeAt(self, index: int) -> SubDEdge: ...
    def EdgeDirectionMatchesFaceOrientation(self, index: int) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def EdgeCount(self) -> int: ...
    @property
    def Id(self) -> UInt32: ...
    @property
    def IsDamaged(self) -> bool: ...
    @property
    def IsDeleted(self) -> bool: ...
    @property
    def IsHidden(self) -> bool: ...
    @property
    def IsHighlighted(self) -> bool: ...
    @property
    def IsLocked(self) -> bool: ...
    @property
    def IsSelected(self) -> bool: ...
    @property
    def LimitSurfaceCenterPoint(self) -> Point3d: ...
    @property
    def ParentSubD(self) -> SubD: ...
    @property
    def PerFaceColor(self) -> Color: ...
    @property
    def VertexCount(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @PerFaceColor.setter
    def PerFaceColor(self) -> MutableSequence[Color]: ...
    def ToString(self) -> str: ...
    def VertexAt(self, index: int) -> SubDVertex: ...


class SubDFriendlyKnotType(Enum):
    Unset = 0
    UnclampedUniform = 1
    ClampedUniform = 2
    ClampedPiecewiseUniform = 4
    Unfriendly = 127


class SubDFromSurfaceMethods(Enum):
    Unset = 0
    SubDFriendlyFit = 1
    FromNurbsControlNet = 2


class SubDHashType(Enum):
    Unset = 0
    TopologyAndEdgeCreases = 1
    Geometry = 2
    Topology = 3


class SubDPatchStyle(Enum):
    Unset = 0
    Automatic = 1
    SingleFace = 2
    TriangleFan = 3
    QuadOrTriangleFan = 4
    Triangulated = 5


class SubDToBrepOptions:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, packFaces: bool, vertexProcess: ExtraordinaryVertexProcessOption): ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Default() -> SubDToBrepOptions: ...
    @property
    def DefaultPacked() -> SubDToBrepOptions: ...
    @property
    def DefaultUnpacked() -> SubDToBrepOptions: ...
    @property
    def ExtraordinaryVertexProcess(self) -> ExtraordinaryVertexProcessOption: ...
    @property
    def PackFaces(self) -> bool: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @ExtraordinaryVertexProcess.setter
    def ExtraordinaryVertexProcess(self) -> MutableSequence[ExtraordinaryVertexProcessOption]: ...
    @PackFaces.setter
    def PackFaces(self) -> MutableSequence[bool]: ...
    def ToString(self) -> str: ...


class SubDVertex(SubDComponent):
    def EdgeAt(self, index: int) -> SubDEdge: ...
    def Equals(self, obj: Object) -> bool: ...
    def FaceAt(self, index: int) -> SubDFace: ...
    @property
    def ControlNetPoint(self) -> Point3d: ...
    @property
    def EdgeCount(self) -> int: ...
    @property
    def Edges(self) -> Iterable[SubDEdge]: ...
    @property
    def FaceCount(self) -> int: ...
    @property
    def Id(self) -> UInt32: ...
    @property
    def IsDamaged(self) -> bool: ...
    @property
    def IsDeleted(self) -> bool: ...
    @property
    def IsHidden(self) -> bool: ...
    @property
    def IsHighlighted(self) -> bool: ...
    @property
    def IsLocked(self) -> bool: ...
    @property
    def IsSelected(self) -> bool: ...
    @property
    def Next(self) -> SubDVertex: ...
    @property
    def ParentSubD(self) -> SubD: ...
    @property
    def Previous(self) -> SubDVertex: ...
    @property
    def Tag(self) -> SubDVertexTag: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @ControlNetPoint.setter
    def ControlNetPoint(self) -> MutableSequence[Point3d]: ...
    @Tag.setter
    def Tag(self) -> MutableSequence[SubDVertexTag]: ...
    def SurfacePoint(self) -> Point3d: ...
    def ToString(self) -> str: ...


class SubDVertexFacetType(Enum):
    Unset = 0
    Tri = 3
    Quad = 4
    Ngon = 5
    Mixed = 255


class SubDVertexTag(Enum):
    Unset = 0
    Smooth = 1
    Crease = 2
    Corner = 3
    Dart = 4


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class SumSurface(Surface):
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(curveA: Curve, curveB: Curve) -> SumSurface: ...
    @overload
    @staticmethod
    def Create(curve: Curve, extrusionDirection: Vector3d) -> SumSurface: ...
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Degree(self, direction: int) -> int: ...
    def Dispose(self) -> None: ...
    def Domain(self, direction: int) -> Interval: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    def IsAtSeam(self, u: float, v: float) -> int: ...
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    def SpanCount(self, direction: int) -> int: ...
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    def ToBrep(self) -> Brep: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Surface(GeometryBase):
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @staticmethod
    def CreateExtrusion(profile: Curve, direction: Vector3d) -> Surface: ...
    @staticmethod
    def CreateExtrusionToPoint(profile: Curve, apexPoint: Point3d) -> Surface: ...
    @overload
    @staticmethod
    def CreatePeriodicSurface(surface: Surface, direction: int) -> Surface: ...
    @overload
    @staticmethod
    def CreatePeriodicSurface(surface: Surface, direction: int, bSmooth: bool) -> Surface: ...
    @overload
    @staticmethod
    def CreateRollingBallFillet(surfaceA: Surface, surfaceB: Surface, radius: float, tolerance: float) -> Iterable[Surface]: ...
    @overload
    @staticmethod
    def CreateRollingBallFillet(surfaceA: Surface, flipA: bool, surfaceB: Surface, flipB: bool, radius: float, tolerance: float) -> Iterable[Surface]: ...
    @overload
    @staticmethod
    def CreateRollingBallFillet(surfaceA: Surface, uvA: Point2d, surfaceB: Surface, uvB: Point2d, radius: float, tolerance: float) -> Iterable[Surface]: ...
    @staticmethod
    def CreateSoftEditSurface(surface: Surface, uv: Point2d, delta: Vector3d, uLength: float, vLength: float, tolerance: float, fixEnds: bool) -> Surface: ...
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Degree(self, direction: int) -> int: ...
    def Dispose(self) -> None: ...
    def Domain(self, direction: int) -> Interval: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    def IsAtSeam(self, u: float, v: float) -> int: ...
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    def SpanCount(self, direction: int) -> int: ...
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    def ToBrep(self) -> Brep: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


class SurfaceCurvature:
    def Direction(self, direction: int) -> Vector3d: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Gaussian(self) -> float: ...
    @property
    def Mean(self) -> float: ...
    @property
    def Normal(self) -> Vector3d: ...
    @property
    def Point(self) -> Point3d: ...
    @property
    def UVPoint(self) -> Point2d: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def Kappa(self, direction: int) -> float: ...
    def OsculatingCircle(self, direction: int) -> Circle: ...
    def ToString(self) -> str: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class SurfaceProxy(Surface):
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Degree(self, direction: int) -> int: ...
    def Dispose(self) -> None: ...
    def Domain(self, direction: int) -> Interval: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def HasNurbsForm(self) -> int: ...
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    def IsAtSeam(self, u: float, v: float) -> int: ...
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    def SpanCount(self, direction: int) -> int: ...
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    def ToBrep(self) -> Brep: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


class SweepBlend(Enum):
    Local = 0
    Global = 1


class SweepFrame(Enum):
    Freeform = 0
    Roadlike = 1


class SweepMiter(Enum):
    # None = 0
    Trimmed = 1
    Untrimmed = 2


class SweepOneRail:
    def __init__(self): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AngleToleranceRadians(self) -> float: ...
    @property
    def ClosedSweep(self) -> bool: ...
    @property
    def GlobalShapeBlending(self) -> bool: ...
    @property
    def IsFreeform(self) -> bool: ...
    @property
    def IsRoadlike(self) -> bool: ...
    @property
    def IsRoadlikeFront(self) -> bool: ...
    @property
    def IsRoadlikeTop(self) -> bool: ...
    @property
    def IsRoadlineRight(self) -> bool: ...
    @property
    def MiterType(self) -> int: ...
    @property
    def SweepTolerance(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSections: Iterable[Curve]) -> Iterable[Brep]: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSection: Curve) -> Iterable[Brep]: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSection: Curve, crossSectionParameter: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSections: Iterable[Curve], crossSectionParameters: Iterable[float]) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSections: Iterable[Curve], rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSection: Curve, rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSections: Iterable[Curve], crossSectionParameters: Iterable[float], rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSection: Curve, crossSectionParameter: float, rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSection: Curve, refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSections: Iterable[Curve], refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSections: Iterable[Curve], crossSectionParameters: Iterable[float], refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSection: Curve, crossSectionParameter: float, refitTolerance: float) -> Iterable[Brep]: ...
    @AngleToleranceRadians.setter
    def AngleToleranceRadians(self) -> MutableSequence[float]: ...
    @ClosedSweep.setter
    def ClosedSweep(self) -> MutableSequence[bool]: ...
    @GlobalShapeBlending.setter
    def GlobalShapeBlending(self) -> MutableSequence[bool]: ...
    @MiterType.setter
    def MiterType(self) -> MutableSequence[int]: ...
    @SweepTolerance.setter
    def SweepTolerance(self) -> MutableSequence[float]: ...
    def SetRoadlikeUpDirection(self, up: Vector3d) -> None: ...
    def SetToRoadlikeFront(self) -> None: ...
    def SetToRoadlikeRight(self) -> None: ...
    def SetToRoadlikeTop(self) -> None: ...
    def ToString(self) -> str: ...


class SweepRebuild(Enum):
    # None = 0
    Rebuild = 1
    Refit = 2


class SweepTwoRail:
    def __init__(self): ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def AngleToleranceRadians(self) -> float: ...
    @property
    def AutoAdjust(self) -> bool: ...
    @property
    def ClosedSweep(self) -> bool: ...
    @property
    def MaintainHeight(self) -> bool: ...
    @property
    def SweepTolerance(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSection: Curve) -> Iterable[Brep]: ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve]) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSection: Curve, rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSection: Curve, refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], refitTolerance: float) -> Iterable[Brep]: ...
    @AngleToleranceRadians.setter
    def AngleToleranceRadians(self) -> MutableSequence[float]: ...
    @AutoAdjust.setter
    def AutoAdjust(self) -> MutableSequence[bool]: ...
    @ClosedSweep.setter
    def ClosedSweep(self) -> MutableSequence[bool]: ...
    @MaintainHeight.setter
    def MaintainHeight(self) -> MutableSequence[bool]: ...
    @SweepTolerance.setter
    def SweepTolerance(self) -> MutableSequence[float]: ...
    def ToString(self) -> str: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class TextDot(GeometryBase):
    def __init__(self, text: str, location: Point3d): ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def FontFace(self) -> str: ...
    @property
    def FontHeight(self) -> int: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def Point(self) -> Point3d: ...
    @property
    def SecondaryText(self) -> str: ...
    @property
    def Text(self) -> str: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @FontFace.setter
    def FontFace(self) -> MutableSequence[str]: ...
    @FontHeight.setter
    def FontHeight(self) -> MutableSequence[int]: ...
    @Point.setter
    def Point(self) -> MutableSequence[Point3d]: ...
    @SecondaryText.setter
    def SecondaryText(self) -> MutableSequence[str]: ...
    @Text.setter
    def Text(self) -> MutableSequence[str]: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


from ..DocObjects import DimensionStyle
from ..DocObjects import TextHorizontalAlignment
from ..DocObjects import TextVerticalAlignment
from ..DocObjects import TextOrientation
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import LengthDisplay
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class TextEntity(AnnotationBase):
    def __init__(self): ...
    def ClearPropertyOverrides(self) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    @staticmethod
    def Create(text: str, plane: Plane, style: DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> TextEntity: ...
    def CreateCurves(self, dimstyle: DimensionStyle, bAllowOpen: bool, smallCapsScale: float, spacing: float) -> Iterable[Curve]: ...
    def CreateExtrusions(self, dimstyle: DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> Iterable[Extrusion]: ...
    def CreatePolySurfaces(self, dimstyle: DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> Iterable[Brep]: ...
    def CreateSurfaces(self, dimstyle: DimensionStyle, smallCapsScale: float, spacing: float) -> Iterable[Brep]: ...
    @staticmethod
    def CreateWithRichText(richTextString: str, plane: Plane, style: DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> TextEntity: ...
    def DataCRC(self, currentRemainder: UInt32) -> UInt32: ...
    def Dispose(self) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def EnsurePrivateCopy(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    def Explode(self) -> Iterable[Curve]: ...
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def DecimalSeparator(self) -> Char: ...
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @property
    def DimensionScale(self) -> float: ...
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @property
    def DimensionStyleId(self) -> Guid: ...
    @property
    def Disposed(self) -> bool: ...
    @property
    def DrawForward(self) -> bool: ...
    @property
    def DrawTextFrame(self) -> bool: ...
    @property
    def FirstCharFont(self) -> Font: ...
    @property
    def Font(self) -> Font: ...
    @property
    def FontIndex(self) -> int: ...
    @property
    def FormatWidth(self) -> float: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @property
    def HasUserData(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Justification(self) -> TextJustification: ...
    @property
    def MaskColor(self) -> Color: ...
    @property
    def MaskColorSource(self) -> MaskType: ...
    @property
    def MaskEnabled(self) -> bool: ...
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @property
    def MaskOffset(self) -> float: ...
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @property
    def PlainText(self) -> str: ...
    @property
    def PlainTextWithFields(self) -> str: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def RichText(self) -> str: ...
    @property
    def Text(self) -> str: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @property
    def TextHeight(self) -> float: ...
    @property
    def TextHorizontalAlignment(self) -> TextHorizontalAlignment: ...
    @property
    def TextIsWrapped(self) -> bool: ...
    @property
    def TextModelWidth(self) -> float: ...
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @property
    def TextRotationDegrees(self) -> float: ...
    @property
    def TextRotationRadians(self) -> float: ...
    @property
    def TextVerticalAlignment(self) -> TextVerticalAlignment: ...
    @property
    def UserData(self) -> UserDataList: ...
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    def GetHashCode(self) -> int: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    def GetTextTransform(self, textscale: float, dimstyle: DimensionStyle) -> Transform: ...
    def GetType(self) -> Type: ...
    def GetUserString(self, key: str) -> str: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def IsAllBold(self) -> bool: ...
    def IsAllItalic(self) -> bool: ...
    def IsAllUnderlined(self) -> bool: ...
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    def MakeDeformable(self) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DecimalSeparator.setter
    def DecimalSeparator(self) -> MutableSequence[Char]: ...
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self) -> MutableSequence[LengthDisplay]: ...
    @DimensionScale.setter
    def DimensionScale(self) -> MutableSequence[float]: ...
    @DimensionStyleId.setter
    def DimensionStyleId(self) -> MutableSequence[Guid]: ...
    @DrawForward.setter
    def DrawForward(self) -> MutableSequence[bool]: ...
    @DrawTextFrame.setter
    def DrawTextFrame(self) -> MutableSequence[bool]: ...
    @Font.setter
    def Font(self) -> MutableSequence[Font]: ...
    @FontIndex.setter
    def FontIndex(self) -> MutableSequence[int]: ...
    @FormatWidth.setter
    def FormatWidth(self) -> MutableSequence[float]: ...
    @Justification.setter
    def Justification(self) -> MutableSequence[TextJustification]: ...
    @MaskColor.setter
    def MaskColor(self) -> MutableSequence[Color]: ...
    @MaskColorSource.setter
    def MaskColorSource(self) -> MutableSequence[MaskType]: ...
    @MaskEnabled.setter
    def MaskEnabled(self) -> MutableSequence[bool]: ...
    @MaskFrame.setter
    def MaskFrame(self) -> MutableSequence[MaskFrame]: ...
    @MaskOffset.setter
    def MaskOffset(self) -> MutableSequence[float]: ...
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self) -> MutableSequence[bool]: ...
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self) -> MutableSequence[DimensionStyle]: ...
    @PlainText.setter
    def PlainText(self) -> MutableSequence[str]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    @RichText.setter
    def RichText(self) -> MutableSequence[str]: ...
    @Text.setter
    def Text(self) -> MutableSequence[str]: ...
    @TextFormula.setter
    def TextFormula(self) -> MutableSequence[str]: ...
    @TextHeight.setter
    def TextHeight(self) -> MutableSequence[float]: ...
    @TextHorizontalAlignment.setter
    def TextHorizontalAlignment(self) -> MutableSequence[TextHorizontalAlignment]: ...
    @TextIsWrapped.setter
    def TextIsWrapped(self) -> MutableSequence[bool]: ...
    @TextOrientation.setter
    def TextOrientation(self) -> MutableSequence[TextOrientation]: ...
    @TextRotationDegrees.setter
    def TextRotationDegrees(self) -> MutableSequence[float]: ...
    @TextRotationRadians.setter
    def TextRotationRadians(self) -> MutableSequence[float]: ...
    @TextVerticalAlignment.setter
    def TextVerticalAlignment(self) -> MutableSequence[TextVerticalAlignment]: ...
    def SetBold(self, set_on: bool) -> bool: ...
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    def SetItalic(self, set_on: bool) -> bool: ...
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    def SetUnderline(self, set_on: bool) -> bool: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def ToJSON(self, options: SerializationOptions) -> str: ...
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Transform(self, transform: Transform, style: DimensionStyle) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    def WrapText(self) -> None: ...


class TextJustification(Enum):
    # None = 0
    Left = 1
    Center = 2
    Right = 4
    Bottom = 65536
    BottomLeft = 65537
    BottomCenter = 65538
    BottomRight = 65540
    Middle = 131072
    MiddleLeft = 131073
    MiddleCenter = 131074
    MiddleRight = 131076
    Top = 262144
    TopLeft = 262145
    TopCenter = 262146
    TopRight = 262148


class TextRunType(Enum):
    # None = 0
    Text = 1
    Newline = 2
    Paragraph = 3
    Column = 4
    Field = 5
    Fontdef = 6
    Header = 7


class TextureCoordinateOption(Enum):
    Unset = 0
    # None = 1
    Automatic = 2
    Packed = 3
    CopyMapping = 4
    CopyCoordinates = 5


class Torus:
    def __init__(self, basePlane: Plane, majorRadius: float, minorRadius: float): ...
    def EpsilonEquals(self, other: Torus, epsilon: float) -> bool: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def MajorRadius(self) -> float: ...
    @property
    def MinorRadius(self) -> float: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Unset() -> Torus: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @MajorRadius.setter
    def MajorRadius(self) -> MutableSequence[float]: ...
    @MinorRadius.setter
    def MinorRadius(self) -> MutableSequence[float]: ...
    @Plane.setter
    def Plane(self) -> MutableSequence[Plane]: ...
    def ToNurbsSurface(self) -> NurbsSurface: ...
    def ToRevSurface(self) -> RevSurface: ...
    def ToString(self) -> str: ...


class Transform:
    @overload
    def __init__(self, diagonalValue: float): ...
    @overload
    def __init__(self, value: Transform): ...
    def Affineize(self) -> None: ...
    @overload
    @staticmethod
    def ChangeBasis(plane0: Plane, plane1: Plane) -> Transform: ...
    @overload
    @staticmethod
    def ChangeBasis(initialBasisX: Vector3d, initialBasisY: Vector3d, initialBasisZ: Vector3d, finalBasisX: Vector3d, finalBasisY: Vector3d, finalBasisZ: Vector3d) -> Transform: ...
    def Clone(self) -> Transform: ...
    def CompareTo(self, other: Transform) -> int: ...
    @overload
    def DecomposeAffine(self) -> Tuple[bool, Vector3d, Transform]: ...
    @overload
    def DecomposeAffine(self) -> Tuple[bool, Transform, Vector3d]: ...
    @overload
    def DecomposeAffine(self) -> Tuple[bool, Vector3d, Transform, Transform, Vector3d]: ...
    def DecomposeRigid(self, tolerance: float) -> Tuple[TransformRigidType, Vector3d, Transform]: ...
    def DecomposeSimilarity(self, tolerance: float) -> Tuple[TransformSimilarityType, Vector3d, float, Transform]: ...
    def DecomposeSymmetric(self) -> Tuple[bool, Transform, Vector3d]: ...
    @overload
    @staticmethod
    def Diagonal(diagonal: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def Diagonal(d0: float, d1: float, d2: float) -> Transform: ...
    @overload
    def Equals(self, other: Transform) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Determinant(self) -> float: ...
    @property
    def Identity() -> Transform: ...
    @property
    def IsAffine(self) -> bool: ...
    @property
    def IsIdentity(self) -> bool: ...
    @property
    def IsLinear(self) -> bool: ...
    @property
    def IsRotation(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def IsZero4x4(self) -> bool: ...
    @property
    def IsZeroTransformation(self) -> bool: ...
    @property
    def Item(self) -> Sequence[int]: ...
    @property
    def M00(self) -> float: ...
    @property
    def M01(self) -> float: ...
    @property
    def M02(self) -> float: ...
    @property
    def M03(self) -> float: ...
    @property
    def M10(self) -> float: ...
    @property
    def M11(self) -> float: ...
    @property
    def M12(self) -> float: ...
    @property
    def M13(self) -> float: ...
    @property
    def M20(self) -> float: ...
    @property
    def M21(self) -> float: ...
    @property
    def M22(self) -> float: ...
    @property
    def M23(self) -> float: ...
    @property
    def M30(self) -> float: ...
    @property
    def M31(self) -> float: ...
    @property
    def M32(self) -> float: ...
    @property
    def M33(self) -> float: ...
    @property
    def RigidType(self) -> TransformRigidType: ...
    @property
    def SimilarityType(self) -> TransformSimilarityType: ...
    @property
    def Unset() -> Transform: ...
    @property
    def ZeroTransformation() -> Transform: ...
    def GetEulerZYZ(self) -> Tuple[bool, float, float, float]: ...
    def GetHashCode(self) -> int: ...
    def GetQuaternion(self) -> Tuple[bool, Quaternion]: ...
    def GetType(self) -> Type: ...
    def GetYawPitchRoll(self) -> Tuple[bool, float, float, float]: ...
    def IsRigid(self, tolerance: float) -> TransformRigidType: ...
    def IsSimilarity(self, tolerance: float) -> TransformSimilarityType: ...
    def IsZeroTransformationWithTolerance(self, zeroTolerance: float) -> bool: ...
    def Linearize(self) -> None: ...
    @overload
    @staticmethod
    def Mirror(mirrorPlane: Plane) -> Transform: ...
    @overload
    @staticmethod
    def Mirror(pointOnMirrorPlane: Point3d, normalToMirrorPlane: Vector3d) -> Transform: ...
    @staticmethod
    def Multiply(a: Transform, b: Transform) -> Transform: ...
    def __eq__(a: Transform, b: Transform) -> bool: ...
    def __ne__(a: Transform, b: Transform) -> bool: ...
    @overload
    def __mul__(a: Transform, b: Transform) -> Transform: ...
    @overload
    def __mul__(m: Transform, v: Vector3d) -> Vector3d: ...
    @overload
    def __mul__(m: Transform, p: Point3d) -> Point3d: ...
    def Orthogonalize(self, tolerance: float) -> bool: ...
    @staticmethod
    def PlanarProjection(plane: Plane) -> Transform: ...
    @staticmethod
    def PlaneToPlane(plane0: Plane, plane1: Plane) -> Transform: ...
    @staticmethod
    def ProjectAlong(plane: Plane, direction: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(angleRadians: float, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(startDirection: Vector3d, endDirection: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(sinAngle: float, cosAngle: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(x0: Vector3d, y0: Vector3d, z0: Vector3d, x1: Vector3d, y1: Vector3d, z1: Vector3d) -> Transform: ...
    @staticmethod
    def RotationZYX(yaw: float, pitch: float, roll: float) -> Transform: ...
    @staticmethod
    def RotationZYZ(alpha: float, beta: float, gamma: float) -> Transform: ...
    @overload
    @staticmethod
    def Scale(anchor: Point3d, scaleFactor: float) -> Transform: ...
    @overload
    @staticmethod
    def Scale(plane: Plane, xScaleFactor: float, yScaleFactor: float, zScaleFactor: float) -> Transform: ...
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @M00.setter
    def M00(self) -> MutableSequence[float]: ...
    @M01.setter
    def M01(self) -> MutableSequence[float]: ...
    @M02.setter
    def M02(self) -> MutableSequence[float]: ...
    @M03.setter
    def M03(self) -> MutableSequence[float]: ...
    @M10.setter
    def M10(self) -> MutableSequence[float]: ...
    @M11.setter
    def M11(self) -> MutableSequence[float]: ...
    @M12.setter
    def M12(self) -> MutableSequence[float]: ...
    @M13.setter
    def M13(self) -> MutableSequence[float]: ...
    @M20.setter
    def M20(self) -> MutableSequence[float]: ...
    @M21.setter
    def M21(self) -> MutableSequence[float]: ...
    @M22.setter
    def M22(self) -> MutableSequence[float]: ...
    @M23.setter
    def M23(self) -> MutableSequence[float]: ...
    @M30.setter
    def M30(self) -> MutableSequence[float]: ...
    @M31.setter
    def M31(self) -> MutableSequence[float]: ...
    @M32.setter
    def M32(self) -> MutableSequence[float]: ...
    @M33.setter
    def M33(self) -> MutableSequence[float]: ...
    @staticmethod
    def Shear(plane: Plane, x: Vector3d, y: Vector3d, z: Vector3d) -> Transform: ...
    def ToFloatArray(self, rowDominant: bool) -> Iterable[Single]: ...
    def ToString(self) -> str: ...
    def TransformBoundingBox(self, bbox: BoundingBox) -> BoundingBox: ...
    def TransformList(self, points: Iterable[Point3d]) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def Translation(motion: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def Translation(dx: float, dy: float, dz: float) -> Transform: ...
    def Transpose(self) -> Transform: ...
    def TryGetInverse(self) -> Tuple[bool, Transform]: ...


class TransformRigidType(Enum):
    NotRigid = 0
    Rigid = 1
    RigidReversing = -1


class TransformSimilarityType(Enum):
    NotSimilarity = 0
    OrientationPreserving = 1
    OrientationReversing = -1


class Triangle3d:
    def __init__(self, a: Point3d, b: Point3d, c: Point3d): ...
    def BarycentricCoordsAt(self, point: Point3d) -> Tuple[Point2d, float]: ...
    def ClosestParameterOnBoundary(self, point: Point3d) -> float: ...
    def ClosestPointOnBoundary(self, point: Point3d) -> Point3d: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def A(self) -> Point3d: ...
    @property
    def AB(self) -> Line: ...
    @property
    def AltitudeA(self) -> Line: ...
    @property
    def AltitudeB(self) -> Line: ...
    @property
    def AltitudeC(self) -> Line: ...
    @property
    def AngleA(self) -> float: ...
    @property
    def AngleB(self) -> float: ...
    @property
    def AngleC(self) -> float: ...
    @property
    def Area(self) -> float: ...
    @property
    def AreaCenter(self) -> Point3d: ...
    @property
    def B(self) -> Point3d: ...
    @property
    def BC(self) -> Line: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def C(self) -> Point3d: ...
    @property
    def CA(self) -> Line: ...
    @property
    def Circumcenter(self) -> Point3d: ...
    @property
    def Circumcircle(self) -> Circle: ...
    @property
    def MedianA(self) -> Line: ...
    @property
    def MedianB(self) -> Line: ...
    @property
    def MedianC(self) -> Line: ...
    @property
    def Orthocenter(self) -> Point3d: ...
    @property
    def Perimeter(self) -> float: ...
    @property
    def PerpendicularAB(self) -> Line: ...
    @property
    def PerpendicularBC(self) -> Line: ...
    @property
    def PerpendicularCA(self) -> Line: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def PointAlongBoundary(self, t: float) -> Point3d: ...
    def PointAtBarycentricCoords(self, coords: Point2d) -> Point3d: ...
    def PointOnInterior(self, u: float, v: float) -> Point3d: ...
    def ToMesh(self) -> Mesh: ...
    def ToPolyline(self) -> Polyline: ...
    def ToString(self) -> str: ...
    def Transform(self, transform: Transform) -> Triangle3d: ...
    def WithA(self, a: Point3d) -> Triangle3d: ...
    def WithB(self, b: Point3d) -> Triangle3d: ...
    def WithC(self, c: Point3d) -> Triangle3d: ...


class Unroller:
    @overload
    def __init__(self, surface: Surface): ...
    @overload
    def __init__(self, brep: Brep): ...
    @overload
    def AddFollowingGeometry(self, curves: Iterable[Curve]) -> None: ...
    @overload
    def AddFollowingGeometry(self, curve: Curve) -> None: ...
    @overload
    def AddFollowingGeometry(self, points: Iterable[Point3d]) -> None: ...
    @overload
    def AddFollowingGeometry(self, point: Point3d) -> None: ...
    @overload
    def AddFollowingGeometry(self, point: Point) -> None: ...
    @overload
    def AddFollowingGeometry(self, dots: Iterable[TextDot]) -> None: ...
    @overload
    def AddFollowingGeometry(self, dot: TextDot) -> None: ...
    @overload
    def AddFollowingGeometry(self, dotLocations: Iterable[Point3d], dotText: Iterable[str]) -> None: ...
    @overload
    def AddFollowingGeometry(self, dotLocation: Point3d, dotText: str) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def FollowingGeometryIndex(self, curve: Curve) -> int: ...
    @overload
    def FollowingGeometryIndex(self, dot: TextDot) -> int: ...
    @property
    def AbsoluteTolerance(self) -> float: ...
    @property
    def ExplodeOutput(self) -> bool: ...
    @property
    def ExplodeSpacing(self) -> float: ...
    @property
    def RelativeTolerance(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    def PerformUnroll(self, flatbreps: List) -> int: ...
    @overload
    def PerformUnroll(self) -> Tuple[Iterable[Brep], Iterable[Curve], Iterable[Point3d], Iterable[TextDot]]: ...
    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self) -> MutableSequence[float]: ...
    @ExplodeOutput.setter
    def ExplodeOutput(self) -> MutableSequence[bool]: ...
    @ExplodeSpacing.setter
    def ExplodeSpacing(self) -> MutableSequence[float]: ...
    @RelativeTolerance.setter
    def RelativeTolerance(self) -> MutableSequence[float]: ...
    def ToString(self) -> str: ...


class Vector2d:
    def __init__(self, x: float, y: float): ...
    @staticmethod
    def Add(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    def CompareTo(self, other: Vector2d) -> int: ...
    @staticmethod
    def Divide(vector: Vector2d, t: float) -> Vector2d: ...
    def EpsilonEquals(self, other: Vector2d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, vector: Vector2d) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Length(self) -> float: ...
    @property
    def SquareLength(self) -> float: ...
    @property
    def Unset() -> Vector2d: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @property
    def Zero() -> Vector2d: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    def IsTiny(self) -> bool: ...
    @overload
    def IsTiny(self, tolerance: float) -> bool: ...
    @overload
    @staticmethod
    def Multiply(vector1: Vector2d, vector2: Vector2d) -> float: ...
    @overload
    @staticmethod
    def Multiply(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    @staticmethod
    def Multiply(t: float, vector: Vector2d) -> Vector2d: ...
    @staticmethod
    def Negate(vector: Vector2d) -> Vector2d: ...
    def __add__(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    def __truediv__(vector: Vector2d, t: float) -> Vector2d: ...
    def __eq__(a: Vector2d, b: Vector2d) -> bool: ...
    def __gt__(a: Vector2d, b: Vector2d) -> bool: ...
    def __ge__(a: Vector2d, b: Vector2d) -> bool: ...
    def __ne__(a: Vector2d, b: Vector2d) -> bool: ...
    def __lt__(a: Vector2d, b: Vector2d) -> bool: ...
    def __le__(a: Vector2d, b: Vector2d) -> bool: ...
    @overload
    def __rmul__(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    def __mul__(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    def __mul__(vector1: Vector2d, vector2: Vector2d) -> float: ...
    def __sub__(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    def __neg__(vector: Vector2d) -> Vector2d: ...
    def Rotate(self, angleRadians: float) -> bool: ...
    @X.setter
    def X(self) -> MutableSequence[float]: ...
    @Y.setter
    def Y(self) -> MutableSequence[float]: ...
    @staticmethod
    def Subtract(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Unitize(self) -> bool: ...


class Vector2f:
    def __init__(self, x: Single, y: Single): ...
    def CompareTo(self, other: Vector2f) -> int: ...
    def EpsilonEquals(self, other: Vector2f, epsilon: Single) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, vector: Vector2f) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def SquareLength(self) -> Single: ...
    @property
    def X(self) -> Single: ...
    @property
    def Y(self) -> Single: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @staticmethod
    def Multiply(point1: Vector2f, point2: Vector2f) -> float: ...
    def __add__(a: Vector2f, b: Vector2f) -> Vector2f: ...
    def __eq__(a: Vector2f, b: Vector2f) -> bool: ...
    def __gt__(a: Vector2f, b: Vector2f) -> bool: ...
    def __ge__(a: Vector2f, b: Vector2f) -> bool: ...
    def __ne__(a: Vector2f, b: Vector2f) -> bool: ...
    def __lt__(a: Vector2f, b: Vector2f) -> bool: ...
    def __le__(a: Vector2f, b: Vector2f) -> bool: ...
    def __mul__(point1: Vector2f, point2: Vector2f) -> float: ...
    def __sub__(a: Vector2f, b: Vector2f) -> Vector2f: ...
    @X.setter
    def X(self) -> MutableSequence[Single]: ...
    @Y.setter
    def Y(self) -> MutableSequence[Single]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...


class Vector3d:
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, vector: Vector3f): ...
    @overload
    def __init__(self, vector: Vector3d): ...
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @staticmethod
    def Add(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    @staticmethod
    def AreOrthogonal(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    @staticmethod
    def AreOrthonormal(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    @staticmethod
    def AreRighthanded(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    def CompareTo(self, other: Vector3d) -> int: ...
    @staticmethod
    def CrossProduct(a: Vector3d, b: Vector3d) -> Vector3d: ...
    @staticmethod
    def Divide(vector: Vector3d, t: float) -> Vector3d: ...
    def EpsilonEquals(self, other: Vector3d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, vector: Vector3d) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @property
    def IsUnitVector(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def Item(self) -> Sequence[int]: ...
    @property
    def Length(self) -> float: ...
    @property
    def MaximumCoordinate(self) -> float: ...
    @property
    def MinimumCoordinate(self) -> float: ...
    @property
    def SquareLength(self) -> float: ...
    @property
    def Unset() -> Vector3d: ...
    @property
    def X(self) -> float: ...
    @property
    def XAxis() -> Vector3d: ...
    @property
    def Y(self) -> float: ...
    @property
    def YAxis() -> Vector3d: ...
    @property
    def Z(self) -> float: ...
    @property
    def ZAxis() -> Vector3d: ...
    @property
    def Zero() -> Vector3d: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    def IsParallelTo(self, other: Vector3d) -> int: ...
    @overload
    def IsParallelTo(self, other: Vector3d, angleTolerance: float) -> int: ...
    @overload
    def IsPerpendicularTo(self, other: Vector3d) -> bool: ...
    @overload
    def IsPerpendicularTo(self, other: Vector3d, angleTolerance: float) -> bool: ...
    @overload
    def IsTiny(self) -> bool: ...
    @overload
    def IsTiny(self, tolerance: float) -> bool: ...
    @overload
    @staticmethod
    def Multiply(vector: Vector3d, t: float) -> Vector3d: ...
    @overload
    @staticmethod
    def Multiply(t: float, vector: Vector3d) -> Vector3d: ...
    @overload
    @staticmethod
    def Multiply(vector1: Vector3d, vector2: Vector3d) -> float: ...
    @staticmethod
    def Negate(vector: Vector3d) -> Vector3d: ...
    def __add__(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    def __truediv__(vector: Vector3d, t: float) -> Vector3d: ...
    def __eq__(a: Vector3d, b: Vector3d) -> bool: ...
    def __gt__(a: Vector3d, b: Vector3d) -> bool: ...
    def __ge__(a: Vector3d, b: Vector3d) -> bool: ...
    def op_Implicit(vector: Vector3f) -> Vector3d: ...
    def __ne__(a: Vector3d, b: Vector3d) -> bool: ...
    def __lt__(a: Vector3d, b: Vector3d) -> bool: ...
    def __le__(a: Vector3d, b: Vector3d) -> bool: ...
    @overload
    def __mul__(vector1: Vector3d, vector2: Vector3d) -> float: ...
    @overload
    def __rmul__(vector: Vector3d, t: float) -> Vector3d: ...
    @overload
    def __mul__(vector: Vector3d, t: float) -> Vector3d: ...
    def __sub__(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    def __neg__(vector: Vector3d) -> Vector3d: ...
    def PerpendicularTo(self, other: Vector3d) -> bool: ...
    def Reverse(self) -> bool: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d) -> bool: ...
    @Item.setter
    def Item(self) -> MutableSequence[int]: ...
    @X.setter
    def X(self) -> MutableSequence[float]: ...
    @Y.setter
    def Y(self) -> MutableSequence[float]: ...
    @Z.setter
    def Z(self) -> MutableSequence[float]: ...
    @staticmethod
    def Subtract(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Transform(self, transformation: Transform) -> None: ...
    def Unitize(self) -> bool: ...
    @overload
    @staticmethod
    def VectorAngle(a: Vector3d, b: Vector3d) -> float: ...
    @overload
    @staticmethod
    def VectorAngle(a: Vector3d, b: Vector3d, plane: Plane) -> float: ...
    @overload
    @staticmethod
    def VectorAngle(v1: Vector3d, v2: Vector3d, vNormal: Vector3d) -> float: ...


class Vector3f:
    def __init__(self, x: Single, y: Single, z: Single): ...
    @overload
    @staticmethod
    def Add(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    @overload
    @staticmethod
    def Add(point: Point3f, vector: Vector3f) -> Point3f: ...
    def CompareTo(self, other: Vector3f) -> int: ...
    @staticmethod
    def CrossProduct(a: Vector3f, b: Vector3f) -> Vector3f: ...
    @overload
    @staticmethod
    def Divide(vector: Vector3f, t: float) -> Vector3f: ...
    @overload
    @staticmethod
    def Divide(vector: Vector3f, t: Single) -> Vector3f: ...
    def EpsilonEquals(self, other: Vector3f, epsilon: Single) -> bool: ...
    @overload
    def Equals(self, vector: Vector3f) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @property
    def IsUnitVector(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def Length(self) -> Single: ...
    @property
    def SquareLength(self) -> Single: ...
    @property
    def Unset() -> Vector3f: ...
    @property
    def X(self) -> Single: ...
    @property
    def XAxis() -> Vector3f: ...
    @property
    def Y(self) -> Single: ...
    @property
    def YAxis() -> Vector3f: ...
    @property
    def Z(self) -> Single: ...
    @property
    def ZAxis() -> Vector3f: ...
    @property
    def Zero() -> Vector3f: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    @overload
    @staticmethod
    def Multiply(t: Single, vector: Vector3f) -> Vector3f: ...
    @overload
    @staticmethod
    def Multiply(vector: Vector3f, t: Single) -> Vector3f: ...
    @overload
    @staticmethod
    def Multiply(point1: Vector3f, point2: Vector3f) -> float: ...
    @staticmethod
    def Negate(vector: Vector3f) -> Vector3f: ...
    @overload
    def __add__(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    @overload
    def __radd__(vector: Vector3f, point: Point3f) -> Point3f: ...
    @overload
    def __truediv__(vector: Vector3f, t: Single) -> Vector3f: ...
    @overload
    def __truediv__(vector: Vector3f, t: float) -> Vector3f: ...
    def __eq__(a: Vector3f, b: Vector3f) -> bool: ...
    def op_Explicit(vector: Vector3d) -> Vector3f: ...
    def __gt__(a: Vector3f, b: Vector3f) -> bool: ...
    def __ge__(a: Vector3f, b: Vector3f) -> bool: ...
    def __ne__(a: Vector3f, b: Vector3f) -> bool: ...
    def __lt__(a: Vector3f, b: Vector3f) -> bool: ...
    def __le__(a: Vector3f, b: Vector3f) -> bool: ...
    @overload
    def __rmul__(vector: Vector3f, t: Single) -> Vector3f: ...
    @overload
    def __mul__(vector: Vector3f, t: Single) -> Vector3f: ...
    @overload
    def __mul__(point1: Vector3f, point2: Vector3f) -> float: ...
    def __sub__(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    def __neg__(vector: Vector3f) -> Vector3f: ...
    def PerpendicularTo(self, other: Vector3f) -> bool: ...
    def Reverse(self) -> bool: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3f) -> bool: ...
    @X.setter
    def X(self) -> MutableSequence[Single]: ...
    @Y.setter
    def Y(self) -> MutableSequence[Single]: ...
    @Z.setter
    def Z(self) -> MutableSequence[Single]: ...
    @staticmethod
    def Subtract(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Transform(self, transformation: Transform) -> None: ...
    def Unitize(self) -> bool: ...


class Visibility(Enum):
    Unset = 0
    Visible = 1
    Hidden = 2
    Duplicate = 3


class Visibility(Enum):
    Unset = 0
    Visible = 1
    Hidden = 2
    Duplicate = 3
    Projecting = 4
    Clipped = 5


class VolumeMassProperties:
    def CentroidCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    def CentroidCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Iterable[GeometryBase]) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Iterable[GeometryBase], volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool, relativeTolerance: float, absoluteTolerance: float) -> VolumeMassProperties: ...
    def Dispose(self) -> None: ...
    def Equals(self, obj: Object) -> bool: ...
    @property
    def Centroid(self) -> Point3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @property
    def CentroidError(self) -> Vector3d: ...
    @property
    def Volume(self) -> float: ...
    @property
    def VolumeError(self) -> float: ...
    @property
    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...
    def GetHashCode(self) -> int: ...
    def GetType(self) -> Type: ...
    def Sum(self, summand: VolumeMassProperties) -> bool: ...
    def ToString(self) -> str: ...
    def WorldCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    def WorldCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
