from typing import overload, Any, Tuple, Iterable, Iterator, Sequence, MutableSequence
from enum import Enum
from System import *
from System.Drawing import *

import Collections
import Intersect
import MeshRefinements
import Morphs

__all__ = ['Collections', 'Intersect', 'MeshRefinements', 'Morphs']


from ..DocObjects import DimensionStyle
from ..DocObjects import AngleDisplayFormat
from ..DocObjects import ZeroSuppression
from ..DocObjects import ViewportInfo
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ArrowType
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class AngularDimension(Dimension):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, arc: Arc, offset: float): ...
    @overload
    def __init__(self, plane: Plane, horizontal: Vector3d, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d): ...
    @overload
    def __init__(self, line1: Line, pointOnLine1: Point3d, line2: Line, pointOnLine2: Point3d, pointOnAngularDimensionArc: Point3d, bSetExtensionPoints: bool): ...
    @overload
    def __init__(self, plane: Plane, horizontal: Vector3d, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d): ...
    @overload
    def AdjustFromPoints(self, plane: Plane, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d) -> bool: ...
    @overload
    def AdjustFromPoints(self, plane: Plane, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d) -> bool: ...
    @overload
    def ClearPropertyOverrides(self) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(dimStyle: DimensionStyle, line1: Line, pointOnLine1: Point3d, line2: Line, pointOnLine2: Point3d, pointOnAngularDimensionArc: Point3d, bSetExtensionPoints: bool) -> AngularDimension: ...
    @overload
    @staticmethod
    def Create(dimStyle: DimensionStyle, plane: Plane, horizontal: Vector3d, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d) -> AngularDimension: ...
    @overload
    @staticmethod
    def Create(dimStyle: DimensionStyle, plane: Plane, horizontal: Vector3d, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d) -> AngularDimension: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Explode(self) -> Iterable[GeometryBase]: ...
    @overload
    @property
    def AlternateBelowLine(self) -> bool: ...
    @overload
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def AltLengthFactor(self) -> float: ...
    @overload
    @property
    def AltLengthResolution(self) -> int: ...
    @overload
    @property
    def AltLengthRoundoff(self) -> float: ...
    @overload
    @property
    def AltPrefix(self) -> str: ...
    @overload
    @property
    def AltSuffix(self) -> str: ...
    @overload
    @property
    def AltToleranceResolution(self) -> int: ...
    @overload
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @overload
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    @property
    def AngleFormat(self) -> AngleDisplayFormat: ...
    @overload
    @property
    def AngleResolution(self) -> int: ...
    @overload
    @property
    def AngleRoundoff(self) -> float: ...
    @overload
    @property
    def AngleZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @overload
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @overload
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @overload
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @overload
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @overload
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @overload
    @property
    def ArrowPoint1(self) -> Point2d: ...
    @overload
    @property
    def ArrowPoint2(self) -> Point2d: ...
    @overload
    @property
    def ArrowSize(self) -> float: ...
    @overload
    @property
    def BaselineSpacing(self) -> float: ...
    @overload
    @property
    def CentermarkSize(self) -> float: ...
    @overload
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @overload
    @property
    def CenterPoint(self) -> Point2d: ...
    @overload
    @property
    def DecimalSeparator(self) -> Char: ...
    @overload
    @property
    def DefPoint1(self) -> Point2d: ...
    @overload
    @property
    def DefPoint2(self) -> Point2d: ...
    @overload
    @property
    def DetailMeasured(self) -> Guid: ...
    @overload
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def DimensionLineExtension(self) -> float: ...
    @overload
    @property
    def DimensionScale(self) -> float: ...
    @overload
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def DimensionStyleId(self) -> Guid: ...
    @overload
    @property
    def DimlinePoint(self) -> Point2d: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def DistanceScale(self) -> float: ...
    @overload
    @property
    def DrawForward(self) -> bool: ...
    @overload
    @property
    def DrawTextFrame(self) -> bool: ...
    @overload
    @property
    def ExtensionLineExtension(self) -> float: ...
    @overload
    @property
    def ExtensionLineOffset(self) -> float: ...
    @overload
    @property
    def FirstCharFont(self) -> Font: ...
    @overload
    @property
    def FixedExtensionLength(self) -> float: ...
    @overload
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @overload
    @property
    def Font(self) -> Font: ...
    @overload
    @property
    def FontIndex(self) -> int: ...
    @overload
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @overload
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @overload
    @property
    def ForceDimLine(self) -> bool: ...
    @overload
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @overload
    @property
    def FormatWidth(self) -> float: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def LengthFactor(self) -> float: ...
    @overload
    @property
    def LengthResolution(self) -> int: ...
    @overload
    @property
    def LengthRoundoff(self) -> float: ...
    @overload
    @property
    def MaskColor(self) -> Color: ...
    @overload
    @property
    def MaskColorSource(self) -> MaskType: ...
    @overload
    @property
    def MaskEnabled(self) -> bool: ...
    @overload
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @overload
    @property
    def MaskOffset(self) -> float: ...
    @overload
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @overload
    @property
    def NumericValue(self) -> float: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def PlainText(self) -> str: ...
    @overload
    @property
    def PlainTextWithFields(self) -> str: ...
    @overload
    @property
    def PlainUserText(self) -> str: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Prefix(self) -> str: ...
    @overload
    @property
    def RichText(self) -> str: ...
    @overload
    @property
    def Suffix(self) -> str: ...
    @overload
    @property
    def SuppressExtension1(self) -> bool: ...
    @overload
    @property
    def SuppressExtension2(self) -> bool: ...
    @overload
    @property
    def Text(self) -> str: ...
    @overload
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @overload
    @property
    def TextFit(self) -> TextFit: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @overload
    @property
    def TextHeight(self) -> float: ...
    @overload
    @property
    def TextIsWrapped(self) -> bool: ...
    @overload
    @property
    def TextLocation(self) -> TextLocation: ...
    @overload
    @property
    def TextModelWidth(self) -> float: ...
    @overload
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @overload
    @property
    def TextPosition(self) -> Point2d: ...
    @overload
    @property
    def TextRotation(self) -> float: ...
    @overload
    @property
    def TextRotationDegrees(self) -> float: ...
    @overload
    @property
    def TextRotationRadians(self) -> float: ...
    @overload
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @overload
    @property
    def ToleranceHeightScale(self) -> float: ...
    @overload
    @property
    def ToleranceLowerValue(self) -> float: ...
    @overload
    @property
    def ToleranceResolution(self) -> int: ...
    @overload
    @property
    def ToleranceUpperValue(self) -> float: ...
    @overload
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d]: ...
    @overload
    def GetAngleDisplayText(self, style: DimensionStyle) -> str: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    @overload
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Iterable[Line], Iterable[Arc]]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    @overload
    def GetTextRectangle(self) -> Tuple[bool, Iterable[Point3d]]: ...
    @overload
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsAllBold(self) -> bool: ...
    @overload
    def IsAllItalic(self) -> bool: ...
    @overload
    def IsAllUnderlined(self) -> bool: ...
    @overload
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @AlternateBelowLine.setter
    def AlternateBelowLine(self, value: bool) -> None: ...
    @overload
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @AltLengthFactor.setter
    def AltLengthFactor(self, value: float) -> None: ...
    @overload
    @AltLengthResolution.setter
    def AltLengthResolution(self, value: int) -> None: ...
    @overload
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self, value: float) -> None: ...
    @overload
    @AltPrefix.setter
    def AltPrefix(self, value: str) -> None: ...
    @overload
    @AltSuffix.setter
    def AltSuffix(self, value: str) -> None: ...
    @overload
    @AltToleranceResolution.setter
    def AltToleranceResolution(self, value: int) -> None: ...
    @overload
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self, value: bool) -> None: ...
    @overload
    @AltZeroSuppression.setter
    def AltZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    @AngleFormat.setter
    def AngleFormat(self, value: AngleDisplayFormat) -> None: ...
    @overload
    @AngleResolution.setter
    def AngleResolution(self, value: int) -> None: ...
    @overload
    @AngleRoundoff.setter
    def AngleRoundoff(self, value: float) -> None: ...
    @overload
    @AngleZeroSuppression.setter
    def AngleZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    @ArrowBlockId1.setter
    def ArrowBlockId1(self, value: Guid) -> None: ...
    @overload
    @ArrowBlockId2.setter
    def ArrowBlockId2(self, value: Guid) -> None: ...
    @overload
    @ArrowFit.setter
    def ArrowFit(self, value: ArrowFit) -> None: ...
    @overload
    @ArrowheadType1.setter
    def ArrowheadType1(self, value: ArrowType) -> None: ...
    @overload
    @ArrowheadType2.setter
    def ArrowheadType2(self, value: ArrowType) -> None: ...
    @overload
    @ArrowSize.setter
    def ArrowSize(self, value: float) -> None: ...
    @overload
    @BaselineSpacing.setter
    def BaselineSpacing(self, value: float) -> None: ...
    @overload
    @CentermarkSize.setter
    def CentermarkSize(self, value: float) -> None: ...
    @overload
    @CentermarkStyle.setter
    def CentermarkStyle(self, value: CenterMarkStyle) -> None: ...
    @overload
    @CenterPoint.setter
    def CenterPoint(self, value: Point2d) -> None: ...
    @overload
    @DecimalSeparator.setter
    def DecimalSeparator(self, value: Char) -> None: ...
    @overload
    @DefPoint1.setter
    def DefPoint1(self, value: Point2d) -> None: ...
    @overload
    @DefPoint2.setter
    def DefPoint2(self, value: Point2d) -> None: ...
    @overload
    @DetailMeasured.setter
    def DetailMeasured(self, value: Guid) -> None: ...
    @overload
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DimensionLineExtension.setter
    def DimensionLineExtension(self, value: float) -> None: ...
    @overload
    @DimensionScale.setter
    def DimensionScale(self, value: float) -> None: ...
    @overload
    @DimensionStyleId.setter
    def DimensionStyleId(self, value: Guid) -> None: ...
    @overload
    @DimlinePoint.setter
    def DimlinePoint(self, value: Point2d) -> None: ...
    @overload
    @DistanceScale.setter
    def DistanceScale(self, value: float) -> None: ...
    @overload
    @DrawForward.setter
    def DrawForward(self, value: bool) -> None: ...
    @overload
    @DrawTextFrame.setter
    def DrawTextFrame(self, value: bool) -> None: ...
    @overload
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self, value: float) -> None: ...
    @overload
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self, value: float) -> None: ...
    @overload
    @FixedExtensionLength.setter
    def FixedExtensionLength(self, value: float) -> None: ...
    @overload
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self, value: bool) -> None: ...
    @overload
    @Font.setter
    def Font(self, value: Font) -> None: ...
    @overload
    @FontIndex.setter
    def FontIndex(self, value: int) -> None: ...
    @overload
    @ForceArrowPosition.setter
    def ForceArrowPosition(self, value: ForceArrow) -> None: ...
    @overload
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self, value: bool) -> None: ...
    @overload
    @ForceDimLine.setter
    def ForceDimLine(self, value: bool) -> None: ...
    @overload
    @ForceTextPosition.setter
    def ForceTextPosition(self, value: ForceText) -> None: ...
    @overload
    @FormatWidth.setter
    def FormatWidth(self, value: float) -> None: ...
    @overload
    @LengthFactor.setter
    def LengthFactor(self, value: float) -> None: ...
    @overload
    @LengthResolution.setter
    def LengthResolution(self, value: int) -> None: ...
    @overload
    @LengthRoundoff.setter
    def LengthRoundoff(self, value: float) -> None: ...
    @overload
    @MaskColor.setter
    def MaskColor(self, value: Color) -> None: ...
    @overload
    @MaskColorSource.setter
    def MaskColorSource(self, value: MaskType) -> None: ...
    @overload
    @MaskEnabled.setter
    def MaskEnabled(self, value: bool) -> None: ...
    @overload
    @MaskFrame.setter
    def MaskFrame(self, value: MaskFrame) -> None: ...
    @overload
    @MaskOffset.setter
    def MaskOffset(self, value: float) -> None: ...
    @overload
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self, value: bool) -> None: ...
    @overload
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self, value: DimensionStyle) -> None: ...
    @overload
    @PlainText.setter
    def PlainText(self, value: str) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @Prefix.setter
    def Prefix(self, value: str) -> None: ...
    @overload
    @RichText.setter
    def RichText(self, value: str) -> None: ...
    @overload
    @Suffix.setter
    def Suffix(self, value: str) -> None: ...
    @overload
    @SuppressExtension1.setter
    def SuppressExtension1(self, value: bool) -> None: ...
    @overload
    @SuppressExtension2.setter
    def SuppressExtension2(self, value: bool) -> None: ...
    @overload
    @Text.setter
    def Text(self, value: str) -> None: ...
    @overload
    @TextAngleType.setter
    def TextAngleType(self, value: LeaderContentAngleStyle) -> None: ...
    @overload
    @TextFit.setter
    def TextFit(self, value: TextFit) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextHeight.setter
    def TextHeight(self, value: float) -> None: ...
    @overload
    @TextIsWrapped.setter
    def TextIsWrapped(self, value: bool) -> None: ...
    @overload
    @TextLocation.setter
    def TextLocation(self, value: TextLocation) -> None: ...
    @overload
    @TextOrientation.setter
    def TextOrientation(self, value: TextOrientation) -> None: ...
    @overload
    @TextPosition.setter
    def TextPosition(self, value: Point2d) -> None: ...
    @overload
    @TextRotation.setter
    def TextRotation(self, value: float) -> None: ...
    @overload
    @TextRotationDegrees.setter
    def TextRotationDegrees(self, value: float) -> None: ...
    @overload
    @TextRotationRadians.setter
    def TextRotationRadians(self, value: float) -> None: ...
    @overload
    @ToleranceFormat.setter
    def ToleranceFormat(self, value: ToleranceDisplayFormat) -> None: ...
    @overload
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self, value: float) -> None: ...
    @overload
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self, value: float) -> None: ...
    @overload
    @ToleranceResolution.setter
    def ToleranceResolution(self, value: int) -> None: ...
    @overload
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self, value: float) -> None: ...
    @overload
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self, value: bool) -> None: ...
    @overload
    @ZeroSuppression.setter
    def ZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetBold(self, set_on: bool) -> bool: ...
    @overload
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    @overload
    def SetItalic(self, set_on: bool) -> bool: ...
    @overload
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    @overload
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    @overload
    def SetUnderline(self, set_on: bool) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    @overload
    def WrapText(self) -> None: ...


from ..DocObjects import Field
from ..DocObjects import DimensionStyle
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..Display import RhinoViewport
from ..DocObjects import Font
from ..DocObjects import LengthDisplay
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class AnnotationBase(GeometryBase):
    @overload
    def ClearPropertyOverrides(self) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @staticmethod
    def FirstCharProperties(rtf_str: str, bold: bool, italic: bool, underline: bool, facename: str) -> Tuple[bool, bool, bool, bool, str]: ...
    @overload
    @staticmethod
    def FormatRtfString(rtf_in: str, clear_bold: bool, set_bold: bool, clear_italic: bool, set_italic: bool, clear_underline: bool, set_underline: bool, clear_facename: bool, set_facename: bool, facename: str) -> str: ...
    @overload
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @overload
    @property
    def DecimalSeparator(self) -> Char: ...
    @overload
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def DimensionScale(self) -> float: ...
    @overload
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def DimensionStyleId(self) -> Guid: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def DrawForward(self) -> bool: ...
    @overload
    @property
    def DrawTextFrame(self) -> bool: ...
    @overload
    @property
    def FirstCharFont(self) -> Font: ...
    @overload
    @property
    def Font(self) -> Font: ...
    @overload
    @property
    def FontIndex(self) -> int: ...
    @overload
    @property
    def FormatWidth(self) -> float: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def MaskColor(self) -> Color: ...
    @overload
    @property
    def MaskColorSource(self) -> MaskType: ...
    @overload
    @property
    def MaskEnabled(self) -> bool: ...
    @overload
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @overload
    @property
    def MaskOffset(self) -> float: ...
    @overload
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def PlainText(self) -> str: ...
    @overload
    @property
    def PlainTextWithFields(self) -> str: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def RichText(self) -> str: ...
    @overload
    @property
    def Text(self) -> str: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @overload
    @property
    def TextHeight(self) -> float: ...
    @overload
    @property
    def TextIsWrapped(self) -> bool: ...
    @overload
    @property
    def TextModelWidth(self) -> float: ...
    @overload
    @property
    def TextRotationDegrees(self) -> float: ...
    @overload
    @property
    def TextRotationRadians(self) -> float: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    @staticmethod
    def GetDimensionScale(doc: RhinoDoc, dimstyle: DimensionStyle, vport: RhinoViewport) -> float: ...
    @overload
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsAllBold(self) -> bool: ...
    @overload
    def IsAllItalic(self) -> bool: ...
    @overload
    def IsAllUnderlined(self) -> bool: ...
    @overload
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    @staticmethod
    def PlainTextToRtf(str: str) -> str: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DecimalSeparator.setter
    def DecimalSeparator(self, value: Char) -> None: ...
    @overload
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DimensionScale.setter
    def DimensionScale(self, value: float) -> None: ...
    @overload
    @DimensionStyleId.setter
    def DimensionStyleId(self, value: Guid) -> None: ...
    @overload
    @DrawForward.setter
    def DrawForward(self, value: bool) -> None: ...
    @overload
    @DrawTextFrame.setter
    def DrawTextFrame(self, value: bool) -> None: ...
    @overload
    @Font.setter
    def Font(self, value: Font) -> None: ...
    @overload
    @FontIndex.setter
    def FontIndex(self, value: int) -> None: ...
    @overload
    @FormatWidth.setter
    def FormatWidth(self, value: float) -> None: ...
    @overload
    @MaskColor.setter
    def MaskColor(self, value: Color) -> None: ...
    @overload
    @MaskColorSource.setter
    def MaskColorSource(self, value: MaskType) -> None: ...
    @overload
    @MaskEnabled.setter
    def MaskEnabled(self, value: bool) -> None: ...
    @overload
    @MaskFrame.setter
    def MaskFrame(self, value: MaskFrame) -> None: ...
    @overload
    @MaskOffset.setter
    def MaskOffset(self, value: float) -> None: ...
    @overload
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self, value: bool) -> None: ...
    @overload
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self, value: DimensionStyle) -> None: ...
    @overload
    @PlainText.setter
    def PlainText(self, value: str) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @RichText.setter
    def RichText(self, value: str) -> None: ...
    @overload
    @Text.setter
    def Text(self, value: str) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextHeight.setter
    def TextHeight(self, value: float) -> None: ...
    @overload
    @TextIsWrapped.setter
    def TextIsWrapped(self, value: bool) -> None: ...
    @overload
    @TextRotationDegrees.setter
    def TextRotationDegrees(self, value: float) -> None: ...
    @overload
    @TextRotationRadians.setter
    def TextRotationRadians(self, value: float) -> None: ...
    @overload
    def SetBold(self, set_on: bool) -> bool: ...
    @overload
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    @overload
    def SetItalic(self, set_on: bool) -> bool: ...
    @overload
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    @overload
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    @overload
    def SetUnderline(self, set_on: bool) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def WrapText(self) -> None: ...


class AnnotationType(Enum):
    Unset = 0
    Aligned = 1
    Angular = 2
    Diameter = 3
    Radius = 4
    Rotated = 5
    Ordinate = 6
    ArcLen = 7
    CenterMark = 8
    Text = 9
    Leader = 10
    Angular3pt = 11


class Arc:
    @overload
    def __init__(self, circle: Circle, angleRadians: float): ...
    @overload
    def __init__(self, circle: Circle, angleIntervalRadians: Interval): ...
    @overload
    def __init__(self, plane: Plane, radius: float, angleRadians: float): ...
    @overload
    def __init__(self, center: Point3d, radius: float, angleRadians: float): ...
    @overload
    def __init__(self, startPoint: Point3d, pointOnInterior: Point3d, endPoint: Point3d): ...
    @overload
    def __init__(self, pointA: Point3d, tangentA: Vector3d, pointB: Point3d): ...
    @overload
    def __init__(self, plane: Plane, center: Point3d, radius: float, angleRadians: float): ...
    @overload
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def EpsilonEquals(self, other: Arc, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: Arc) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Angle(self) -> float: ...
    @overload
    @property
    def AngleDegrees(self) -> float: ...
    @overload
    @property
    def AngleDomain(self) -> Interval: ...
    @overload
    @property
    def Center(self) -> Point3d: ...
    @overload
    @property
    def Circumference(self) -> float: ...
    @overload
    @property
    def Diameter(self) -> float: ...
    @overload
    @property
    def EndAngle(self) -> float: ...
    @overload
    @property
    def EndAngleDegrees(self) -> float: ...
    @overload
    @property
    def EndPoint(self) -> Point3d: ...
    @overload
    @property
    def IsCircle(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Length(self) -> float: ...
    @overload
    @property
    def MidPoint(self) -> Point3d: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Radius(self) -> float: ...
    @overload
    @property
    def StartAngle(self) -> float: ...
    @overload
    @property
    def StartAngleDegrees(self) -> float: ...
    @overload
    @property
    def StartPoint(self) -> Point3d: ...
    @overload
    @property
    def Unset() -> Arc: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def __eq__(a: Arc, b: Arc) -> bool: ...
    @overload
    def __ne__(a: Arc, b: Arc) -> bool: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    @Angle.setter
    def Angle(self, value: float) -> None: ...
    @overload
    @AngleDegrees.setter
    def AngleDegrees(self, value: float) -> None: ...
    @overload
    @AngleDomain.setter
    def AngleDomain(self, value: Interval) -> None: ...
    @overload
    @Center.setter
    def Center(self, value: Point3d) -> None: ...
    @overload
    @Diameter.setter
    def Diameter(self, value: float) -> None: ...
    @overload
    @EndAngle.setter
    def EndAngle(self, value: float) -> None: ...
    @overload
    @EndAngleDegrees.setter
    def EndAngleDegrees(self, value: float) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @Radius.setter
    def Radius(self, value: float) -> None: ...
    @overload
    @StartAngle.setter
    def StartAngle(self, value: float) -> None: ...
    @overload
    @StartAngleDegrees.setter
    def StartAngleDegrees(self, value: float) -> None: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> bool: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class ArcCurve(Curve):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: ArcCurve): ...
    @overload
    def __init__(self, arc: Arc): ...
    @overload
    def __init__(self, circle: Circle): ...
    @overload
    def __init__(self, arc: Arc, t0: float, t1: float): ...
    @overload
    def __init__(self, circle: Circle, t0: float, t1: float): ...
    @overload
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    @overload
    def ControlPolygon(self) -> Polyline: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateCurve(self) -> Curve: ...
    @overload
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    @overload
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    @overload
    def FilletSurfaceToCurve(self, face: BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FilletSurfaceToRail(self, faceWithCurve: BrepFace, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: List, out_breps0: List, out_breps1: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FindLocalInflection(self, N: Vector3d, subDomain: Interval, seed: float) -> Tuple[bool, float, float]: ...
    @overload
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def AngleDegrees(self) -> float: ...
    @overload
    @property
    def AngleRadians(self) -> float: ...
    @overload
    @property
    def Arc(self) -> Arc: ...
    @overload
    @property
    def Degree(self) -> int: ...
    @overload
    @property
    def Dimension(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Domain(self) -> Interval: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsCompleteCircle(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsPeriodic(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PointAtEnd(self) -> Point3d: ...
    @overload
    @property
    def PointAtMid(self) -> Point3d: ...
    @overload
    @property
    def PointAtStart(self) -> Point3d: ...
    @overload
    @property
    def Radius(self) -> float: ...
    @overload
    @property
    def SpanCount(self) -> int: ...
    @overload
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @overload
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    @overload
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    @overload
    def GetSubCurves(self) -> Iterable[Curve]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def InflectionPoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    @overload
    def MakeClosed(self, tolerance: float) -> bool: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    @overload
    def MaxCurvaturePoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    @overload
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetTangentToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, length: float) -> Point3d: ...
    @overload
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float, loose: bool) -> Curve: ...
    @overload
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    @overload
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def Reparameterize(self) -> Curve: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, ribbonParameters: RibbonOffsetParameters) -> Tuple[Curve, Iterable[Curve], Iterable[Curve], Iterable[Brep]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Domain.setter
    def Domain(self, value: Interval) -> None: ...
    @overload
    def SetEndPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetStartPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    @overload
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def SpanVector(self) -> Iterable[float]: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    @overload
    def TorsionAt(self, t: float) -> float: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class AreaMassProperties:
    @overload
    def CentroidCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    def CentroidCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    @staticmethod
    def Compute(closedPlanarCurve: Curve) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(hatch: Hatch) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Iterable[GeometryBase]) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(closedPlanarCurve: Curve, planarTolerance: float) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Iterable[GeometryBase], area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool, relativeTolerance: float, absoluteTolerance: float) -> AreaMassProperties: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Area(self) -> float: ...
    @overload
    @property
    def AreaError(self) -> float: ...
    @overload
    @property
    def Centroid(self) -> Point3d: ...
    @overload
    @property
    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def CentroidError(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesProductMoments(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def WorldCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    def WorldCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...


from ..DocObjects import ArrowType
class Arrowhead:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, arrowType: ArrowType, blockId: Guid): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ArrowType(self) -> ArrowType: ...
    @overload
    @property
    def BlockId(self) -> Guid: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class Attenuation(Enum):
    Constant = 0
    Linear = 1
    InverseSquared = 2


class BezierCurve:
    @overload
    def __init__(self, controlPoints: Iterable[Point2d]): ...
    @overload
    def __init__(self, controlPoints: Iterable[Point3d]): ...
    @overload
    def __init__(self, controlPoints: Iterable[Point4d]): ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    @staticmethod
    def CreateBeziers(sourceCurve: Curve) -> Iterable[BezierCurve]: ...
    @overload
    @staticmethod
    def CreateCubicBeziers(sourceCurve: Curve, distanceTolerance: float, kinkTolerance: float) -> Iterable[BezierCurve]: ...
    @overload
    @staticmethod
    def CreateLoftedBezier(points: Iterable[Point3d]) -> BezierCurve: ...
    @overload
    @staticmethod
    def CreateLoftedBezier(points: Iterable[Point2d]) -> BezierCurve: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ControlVertexCount(self) -> int: ...
    @overload
    @property
    def Dimension(self) -> int: ...
    @overload
    @property
    def IsRational(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetControlVertex2d(self, index: int) -> Point2d: ...
    @overload
    def GetControlVertex3d(self, index: int) -> Point3d: ...
    @overload
    def GetControlVertex4d(self, index: int) -> Point4d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IncreaseDegree(self, desiredDegree: int) -> bool: ...
    @overload
    def MakeNonRational(self) -> bool: ...
    @overload
    def MakeRational(self) -> bool: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def Split(self, t: float) -> Tuple[bool, BezierCurve, BezierCurve]: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToString(self) -> str: ...


class BezierSurface:
    @overload
    def ControlVertexCount(self, direction: int) -> int: ...
    @overload
    @staticmethod
    def CreateLoftedBezier(curves: Iterable[BezierCurve]) -> BezierSurface: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Dimension(self) -> int: ...
    @overload
    @property
    def IsRational(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetControlVertex2d(self, i: int, j: int) -> Point2d: ...
    @overload
    def GetControlVertex3d(self, i: int, j: int) -> Point3d: ...
    @overload
    def GetControlVertex4d(self, i: int, j: int) -> Point4d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def MakeNonRational(self) -> bool: ...
    @overload
    def MakeRational(self) -> bool: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Reverse(self, direction: int) -> BezierSurface: ...
    @overload
    def Split(self, direction: int, t: float) -> Tuple[bool, BezierSurface, BezierSurface]: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Transpose(self) -> BezierSurface: ...


class BlendContinuity(Enum):
    Position = 0
    Tangency = 1
    Curvature = 2


class BlendType(Enum):
    Chamfer = 0
    Fillet = 1
    Blend = 2


class BoundingBox:
    @overload
    def __init__(self, points: Iterable[Point3d]): ...
    @overload
    def __init__(self, min: Point3d, max: Point3d): ...
    @overload
    def __init__(self, points: Iterable[Point3d], xform: Transform): ...
    @overload
    def __init__(self, minX: float, minY: float, minZ: float, maxX: float, maxY: float, maxZ: float): ...
    @overload
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, point: Point3d, includeInterior: bool) -> Point3d: ...
    @overload
    def Contains(self, point: Point3d) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox, strict: bool) -> bool: ...
    @overload
    def Contains(self, point: Point3d, strict: bool) -> bool: ...
    @overload
    def Corner(self, minX: bool, minY: bool, minZ: bool) -> Point3d: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def FurthestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    @property
    def Area(self) -> float: ...
    @overload
    @property
    def Center(self) -> Point3d: ...
    @overload
    @property
    def Diagonal(self) -> Vector3d: ...
    @overload
    @property
    def Empty() -> BoundingBox: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Max(self) -> Point3d: ...
    @overload
    @property
    def Min(self) -> Point3d: ...
    @overload
    @property
    def Unset() -> BoundingBox: ...
    @overload
    @property
    def Volume(self) -> float: ...
    @overload
    def GetCorners(self) -> Iterable[Point3d]: ...
    @overload
    def GetEdges(self) -> Iterable[Line]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Inflate(self, amount: float) -> None: ...
    @overload
    def Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None: ...
    @overload
    @staticmethod
    def Intersection(a: BoundingBox, b: BoundingBox) -> BoundingBox: ...
    @overload
    def IsDegenerate(self, tolerance: float) -> int: ...
    @overload
    def MakeValid(self) -> bool: ...
    @overload
    def PointAt(self, tx: float, ty: float, tz: float) -> Point3d: ...
    @overload
    @Max.setter
    def Max(self, value: Point3d) -> None: ...
    @overload
    @Min.setter
    def Min(self, value: Point3d) -> None: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Union(self, other: BoundingBox) -> None: ...
    @overload
    def Union(self, point: Point3d) -> None: ...
    @overload
    @staticmethod
    def Union(a: BoundingBox, b: BoundingBox) -> BoundingBox: ...
    @overload
    @staticmethod
    def Union(box: BoundingBox, point: Point3d) -> BoundingBox: ...


class Box:
    @overload
    def __init__(self, other: Box): ...
    @overload
    def __init__(self, bbox: BoundingBox): ...
    @overload
    def __init__(self, basePlane: Plane, points: Iterable[Point3d]): ...
    @overload
    def __init__(self, basePlane: Plane, geometry: GeometryBase): ...
    @overload
    def __init__(self, basePlane: Plane, boundingbox: BoundingBox): ...
    @overload
    def __init__(self, basePlane: Plane, xSize: Interval, ySize: Interval, zSize: Interval): ...
    @overload
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def Contains(self, box: BoundingBox) -> bool: ...
    @overload
    def Contains(self, point: Point3d) -> bool: ...
    @overload
    def Contains(self, box: Box) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox, strict: bool) -> bool: ...
    @overload
    def Contains(self, box: Box, strict: bool) -> bool: ...
    @overload
    def Contains(self, point: Point3d, strict: bool) -> bool: ...
    @overload
    def EpsilonEquals(self, other: Box, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def FurthestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    @property
    def Area(self) -> float: ...
    @overload
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def Center(self) -> Point3d: ...
    @overload
    @property
    def Empty() -> Box: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Unset() -> Box: ...
    @overload
    @property
    def Volume(self) -> float: ...
    @overload
    @property
    def X(self) -> Interval: ...
    @overload
    @property
    def Y(self) -> Interval: ...
    @overload
    @property
    def Z(self) -> Interval: ...
    @overload
    def GetCorners(self) -> Iterable[Point3d]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Inflate(self, amount: float) -> None: ...
    @overload
    def Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None: ...
    @overload
    def MakeValid(self) -> bool: ...
    @overload
    def PointAt(self, x: float, y: float, z: float) -> Point3d: ...
    @overload
    def RepositionBasePlane(self, origin: Point3d) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @X.setter
    def X(self, value: Interval) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: Interval) -> None: ...
    @overload
    @Z.setter
    def Z(self, value: Interval) -> None: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToExtrusion(self) -> Extrusion: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Union(self, point: Point3d) -> None: ...


from ..Collections import CurveList
from ..ApplicationSettings import CurvatureAnalysisSettingsState
from .Collections import BrepVertexList
from .Collections import BrepSurfaceList
from .Collections import BrepEdgeList
from .Collections import BrepTrimList
from .Collections import BrepLoopList
from .Collections import BrepFaceList
from .Collections import BrepCurveList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Brep(GeometryBase):
    @overload
    def __init__(self): ...
    @overload
    def AddEdgeCurve(self, curve: Curve) -> int: ...
    @overload
    def AddSurface(self, surface: Surface) -> int: ...
    @overload
    def AddTrimCurve(self, curve: Curve) -> int: ...
    @overload
    def Append(self, other: Brep) -> None: ...
    @overload
    def CapPlanarHoles(self, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def ChangeSeam(face: BrepFace, direction: int, parameter: float, tolerance: float) -> Brep: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, Point3d, ComponentIndex, float, float, Vector3d]: ...
    @overload
    def Compact(self) -> None: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def CopyTrimCurves(trimSource: BrepFace, surfaceSource: Surface, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateBaseballSphere(center: Point3d, radius: float, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateBlendShape(face0: BrepFace, edge0: BrepEdge, t0: float, rev0: bool, continuity0: BlendContinuity, face1: BrepFace, edge1: BrepEdge, t1: float, rev1: bool, continuity1: BlendContinuity) -> Curve: ...
    @overload
    @staticmethod
    def CreateBlendSurface(face0: BrepFace, edge0: BrepEdge, domain0: Interval, rev0: bool, continuity0: BlendContinuity, face1: BrepFace, edge1: BrepEdge, domain1: Interval, rev1: bool, continuity1: BlendContinuity) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float, manifoldOnly: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstBrep: Brep, secondBrep: Brep, tolerance: float, manifoldOnly: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifferenceWithIndexMap(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float, manifoldOnly: bool) -> Tuple[Iterable[Brep], Iterable[int]]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float, manifoldOnly: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstBrep: Brep, secondBrep: Brep, tolerance: float, manifoldOnly: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanSplit(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanSplit(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(breps: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(breps: Iterable[Brep], tolerance: float, manifoldOnly: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(breps: Iterable[Brep], tolerance: float, manifoldOnly: bool) -> Tuple[Iterable[Brep], Iterable[Point3d], Iterable[Point3d], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def CreateChamferSurface(face0: BrepFace, uv0: Point2d, radius0: float, face1: BrepFace, uv1: Point2d, radius1: float, extend: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateChamferSurface(face0: BrepFace, uv0: Point2d, radius0: float, face1: BrepFace, uv1: Point2d, radius1: float, trim: bool, extend: bool, tolerance: float) -> Tuple[Iterable[Brep], Iterable[Brep], Iterable[Brep]]: ...
    @overload
    @staticmethod
    def CreateContourCurves(brepToContour: Brep, sectionPlane: Plane) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateContourCurves(brepToContour: Brep, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateCurvatureAnalysisMesh(brep: Brep, state: CurvatureAnalysisSettingsState) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def CreateDevelopableLoft(rail0: NurbsCurve, rail1: NurbsCurve, fixedRulings: Iterable[Point2d]) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateDevelopableLoft(crv0: Curve, crv1: Curve, reverse0: bool, reverse1: bool, density: int) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateEdgeSurface(curves: Iterable[Curve]) -> Brep: ...
    @overload
    @staticmethod
    def CreateFilletEdges(brep: Brep, edgeIndices: Iterable[int], startRadii: Iterable[float], endRadii: Iterable[float], blendType: BlendType, railType: RailType, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFilletEdges(brep: Brep, edgeIndices: Iterable[int], startRadii: Iterable[float], endRadii: Iterable[float], blendType: BlendType, railType: RailType, setbackFillets: bool, tolerance: float, angleTolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFilletEdgesVariableRadius(brep: Brep, edgeIndices: Iterable[int], edgeDistances: IDictionary, blendType: BlendType, railType: RailType, setbackFillets: bool, tolerance: float, angleTolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFilletSurface(face0: BrepFace, uv0: Point2d, face1: BrepFace, uv1: Point2d, radius: float, extend: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFilletSurface(face0: BrepFace, uv0: Point2d, face1: BrepFace, uv1: Point2d, radius: float, trim: bool, extend: bool, tolerance: float) -> Tuple[Iterable[Brep], Iterable[Brep], Iterable[Brep]]: ...
    @overload
    @staticmethod
    def CreateFromBox(corners: Iterable[Point3d]) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromBox(box: BoundingBox) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromBox(box: Box) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone, capBottom: bool) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromCornerPoints(corner1: Point3d, corner2: Point3d, corner3: Point3d, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromCornerPoints(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, capBottom: bool, capTop: bool) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromJoinedEdges(brep0: Brep, edgeIndex0: int, brep1: Brep, edgeIndex1: int, joinTolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromLoft(curves: Iterable[Curve], start: Point3d, end: Point3d, loftType: LoftType, closed: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromLoft(curves: Iterable[Curve], start: Point3d, end: Point3d, StartTangent: bool, EndTangent: bool, StartTrim: BrepTrim, EndTrim: BrepTrim, loftType: LoftType, closed: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromLoftRebuild(curves: Iterable[Curve], start: Point3d, end: Point3d, loftType: LoftType, closed: bool, rebuildPointCount: int) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromLoftRefit(curves: Iterable[Curve], start: Point3d, end: Point3d, loftType: LoftType, closed: bool, refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromMesh(mesh: Mesh, trimmedTriangles: bool) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromOffsetFace(face: BrepFace, offsetDistance: float, offsetTolerance: float, bothSides: bool, createSolid: bool) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromRevSurface(surface: RevSurface, capStart: bool, capEnd: bool) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromSphere(sphere: Sphere) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromSurface(surface: Surface) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail: Curve, shape: Curve, closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail: Curve, shapes: Iterable[Curve], closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Iterable[Curve], closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shape: Curve, closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Iterable[Curve], start: Point3d, end: Point3d, closed: bool, tolerance: float, rebuild: SweepRebuild, rebuildPointCount: int, refitTolerance: float, preserveHeight: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Iterable[Curve], start: Point3d, end: Point3d, closed: bool, tolerance: float, rebuild: SweepRebuild, rebuildPointCount: int, refitTolerance: float, preserveHeight: bool, autoAdjust: bool) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail: Curve, shapes: Iterable[Curve], startPoint: Point3d, endPoint: Point3d, frameType: SweepFrame, roadlikeNormal: Vector3d, closed: bool, blendType: SweepBlend, miterType: SweepMiter, tolerance: float, rebuildType: SweepRebuild, rebuildPointCount: int, refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweepInParts(rail1: Curve, rail2: Curve, shapes: Iterable[Curve], rail_params: Iterable[Point2d], closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweepSegmented(rail: Curve, shapes: Iterable[Curve], closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweepSegmented(rail: Curve, shape: Curve, closed: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweepSegmented(rail: Curve, shapes: Iterable[Curve], startPoint: Point3d, endPoint: Point3d, frameType: SweepFrame, roadlikeNormal: Vector3d, closed: bool, blendType: SweepBlend, miterType: SweepMiter, tolerance: float, rebuildType: SweepRebuild, rebuildPointCount: int, refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromTaperedExtrude(curveToExtrude: Curve, distance: float, direction: Vector3d, basePoint: Point3d, draftAngleRadians: float, cornerType: ExtrudeCornerType, tolerance: float, angleToleranceRadians: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromTaperedExtrudeWithRef(curve: Curve, direction: Vector3d, distance: float, draftAngle: float, plane: Plane, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateFromTorus(torus: Torus) -> Brep: ...
    @overload
    @staticmethod
    def CreateOffsetBrep(brep: Brep, distance: float, solid: bool, extend: bool, tolerance: float) -> Tuple[Iterable[Brep], Iterable[Brep], Iterable[Brep]]: ...
    @overload
    @staticmethod
    def CreateOffsetBrep(brep: Brep, distance: float, solid: bool, extend: bool, shrink: bool, tolerance: float) -> Tuple[Iterable[Brep], Iterable[Brep], Iterable[Brep]]: ...
    @overload
    @staticmethod
    def CreatePatch(geometry: Iterable[GeometryBase], startingSurface: Surface, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreatePatch(geometry: Iterable[GeometryBase], uSpans: int, vSpans: int, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreatePatch(geometry: Iterable[GeometryBase], startingSurface: Surface, uSpans: int, vSpans: int, trim: bool, tangency: bool, pointSpacing: float, flexibility: float, surfacePull: float, fixEdges: Iterable[bool], tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreatePipe(rail: Curve, radius: float, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePipe(rail: Curve, railRadiiParameters: Iterable[float], radii: Iterable[float], localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarBreps(inputLoops: Iterable[Curve], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarBreps(inputLoops: CurveList, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarBreps(inputLoop: Curve, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarDifference(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarIntersection(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarUnion(breps: Iterable[Brep], plane: Plane, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarUnion(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateQuadSphere(sphere: Sphere) -> Brep: ...
    @overload
    @staticmethod
    def CreateShell(brep: Brep, facesToRemove: Iterable[int], distance: float, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateSolid(breps: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateThickPipe(rail: Curve, radius0: float, radius1: float, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateThickPipe(rail: Curve, railRadiiParameters: Iterable[float], radii0: Iterable[float], radii1: Iterable[float], localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CreateTrimmedPlane(plane: Plane, curve: Curve) -> Brep: ...
    @overload
    @staticmethod
    def CreateTrimmedPlane(plane: Plane, curves: Iterable[Curve]) -> Brep: ...
    @overload
    @staticmethod
    def CreateTrimmedSurface(trimSource: BrepFace, surfaceSource: Surface, tolerance: float) -> Brep: ...
    @overload
    def CullUnused2dCurves(self) -> bool: ...
    @overload
    def CullUnused3dCurves(self) -> bool: ...
    @overload
    def CullUnusedEdges(self) -> bool: ...
    @overload
    def CullUnusedFaces(self) -> bool: ...
    @overload
    def CullUnusedLoops(self) -> bool: ...
    @overload
    def CullUnusedSurfaces(self) -> bool: ...
    @overload
    def CullUnusedTrims(self) -> bool: ...
    @overload
    def CullUnusedVertices(self) -> bool: ...
    @overload
    @staticmethod
    def CutUpSurface(surface: Surface, curves: Iterable[Curve], useEdgeCurves: bool, tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def CutUpSurface(surface: Surface, curves: Iterable[Curve], flip: bool, fitTolerance: float, keepTolerance: float) -> Iterable[Brep]: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def DestroyRegionTopology(self) -> None: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateBrep(self) -> Brep: ...
    @overload
    def DuplicateEdgeCurves(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateEdgeCurves(self, nakedOnly: bool) -> Iterable[Curve]: ...
    @overload
    def DuplicateNakedEdgeCurves(self, nakedOuter: bool, nakedInner: bool) -> Iterable[Curve]: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def DuplicateSubBrep(self, faceIndices: Iterable[int]) -> Brep: ...
    @overload
    def DuplicateVertices(self) -> Iterable[Point3d]: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @staticmethod
    def ExtendBrepFacesToConnect(Face0: BrepFace, edgeIndex0: int, Face1: BrepFace, edgeIndex1: int, tol: float, angleTol: float) -> Tuple[bool, Brep, Brep]: ...
    @overload
    @staticmethod
    def ExtendBrepFacesToConnect(Face0: BrepFace, f0_sel_pt: Point3d, Face1: BrepFace, f1_sel_pt: Point3d, tol: float, angleTol: float) -> Tuple[bool, Brep, Brep]: ...
    @overload
    def FindCoincidentBrepComponents(self, point: Point3d, tolerance: float) -> Tuple[Iterable[int], Iterable[int], Iterable[int]]: ...
    @overload
    def Flip(self) -> None: ...
    @overload
    @property
    def Curves2D(self) -> BrepCurveList: ...
    @overload
    @property
    def Curves3D(self) -> BrepCurveList: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Edges(self) -> BrepEdgeList: ...
    @overload
    @property
    def Faces(self) -> BrepFaceList: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasRegionTopology(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsManifold(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsSurface(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Loops(self) -> BrepLoopList: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def SolidOrientation(self) -> BrepSolidOrientation: ...
    @overload
    @property
    def Surfaces(self) -> BrepSurfaceList: ...
    @overload
    @property
    def Trims(self) -> BrepTrimList: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def Vertices(self) -> BrepVertexList: ...
    @overload
    def GetArea(self) -> float: ...
    @overload
    def GetArea(self, relativeTolerance: float, absoluteTolerance: float) -> float: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConnectedComponents(self) -> Iterable[Brep]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPointInside(self, tolerance: float) -> Tuple[bool, Point3d]: ...
    @overload
    def GetRegions(self) -> Iterable[BrepRegion]: ...
    @overload
    def GetTangentConnectedComponents(self, angleTolerance: float, includeMeshes: bool) -> Iterable[Brep]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def GetVolume(self) -> float: ...
    @overload
    def GetVolume(self, relativeTolerance: float, absoluteTolerance: float) -> float: ...
    @overload
    def GetWireframe(self, density: int) -> Iterable[Curve]: ...
    @overload
    def InsetFaces(self, faceIndices: Iterable[int], distance: float, loose: bool, ignoreSeams: bool, creaseCorners: bool, tolerance: float, angleTolerance: float) -> Brep: ...
    @overload
    def IsBox(self) -> bool: ...
    @overload
    def IsBox(self, tolerance: float) -> bool: ...
    @overload
    def IsDuplicate(self, other: Brep, tolerance: float) -> bool: ...
    @overload
    def IsPointInside(self, point: Point3d, tolerance: float, strictlyIn: bool) -> bool: ...
    @overload
    def IsValidGeometry(self) -> Tuple[bool, str]: ...
    @overload
    def IsValidTolerancesAndFlags(self) -> Tuple[bool, str]: ...
    @overload
    def IsValidTopology(self) -> Tuple[bool, str]: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def Join(self, otherBrep: Brep, tolerance: float, compact: bool) -> bool: ...
    @overload
    @staticmethod
    def JoinBreps(brepsToJoin: Iterable[Brep], tolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def JoinBreps(brepsToJoin: Iterable[Brep], tolerance: float, angleTolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def JoinBreps(brepsToJoin: Iterable[Brep], tolerance: float, angleTolerance: float) -> Tuple[Iterable[Brep], List]: ...
    @overload
    def JoinEdges(self, edgeIndex0: int, edgeIndex1: int, joinTolerance: float, compact: bool) -> bool: ...
    @overload
    def JoinNakedEdges(self, tolerance: float) -> int: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MakeValidForV2(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    @staticmethod
    def MergeBreps(brepsToMerge: Iterable[Brep], tolerance: float) -> Brep: ...
    @overload
    def MergeCoplanarFaces(self, tolerance: float) -> bool: ...
    @overload
    def MergeCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def MergeCoplanarFaces(self, faceIndex: int, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def MergeCoplanarFaces(self, faceIndex0: int, faceIndex1: int, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    @staticmethod
    def MergeSurfaces(surface0: Surface, surface1: Surface, tolerance: float, angleToleranceRadians: float) -> Brep: ...
    @overload
    @staticmethod
    def MergeSurfaces(brep0: Brep, brep1: Brep, tolerance: float, angleToleranceRadians: float) -> Brep: ...
    @overload
    @staticmethod
    def MergeSurfaces(brep0: Brep, brep1: Brep, tolerance: float, angleToleranceRadians: float, point0: Point2d, point1: Point2d, roundness: float, smooth: bool) -> Brep: ...
    @overload
    def PushPullExtend(self, faceIndex: int, transform: Transform, tolerance: float) -> Brep: ...
    @overload
    def RebuildTrimsForV2(self, face: BrepFace, nurbsSurface: NurbsSurface) -> None: ...
    @overload
    def RemoveFins(self) -> bool: ...
    @overload
    def RemoveHoles(self, tolerance: float) -> Brep: ...
    @overload
    def RemoveHoles(self, loops: Iterable[ComponentIndex], tolerance: float) -> Brep: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetTolerancesBoxesAndFlags(self) -> None: ...
    @overload
    def SetTolerancesBoxesAndFlags(self, bLazy: bool, bSetVertexTolerances: bool, bSetEdgeTolerances: bool, bSetTrimTolerances: bool, bSetTrimIsoFlags: bool, bSetTrimTypeFlags: bool, bSetLoopTypeFlags: bool, bSetTrimBoxes: bool) -> None: ...
    @overload
    def SetTrimIsoFlags(self) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def SetVertices(self) -> None: ...
    @overload
    def Split(self, cutters: Iterable[Brep], intersectionTolerance: float) -> Iterable[Brep]: ...
    @overload
    def Split(self, cutter: Brep, intersectionTolerance: float) -> Iterable[Brep]: ...
    @overload
    def Split(self, cutters: Iterable[Curve], intersectionTolerance: float) -> Iterable[Brep]: ...
    @overload
    def Split(self, cutter: Brep, intersectionTolerance: float) -> Tuple[Iterable[Brep], bool]: ...
    @overload
    def Split(self, cutters: Iterable[GeometryBase], normal: Vector3d, planView: bool, intersectionTolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def SplitDisjointPieces(brep: Brep) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def SplitDisjointPieces(brep: Brep) -> Tuple[Iterable[Brep], List]: ...
    @overload
    def Standardize(self) -> None: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def TransformComponent(self, components: Iterable[ComponentIndex], xform: Transform, tolerance: float, timeLimit: float, useMultipleThreads: bool) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, cutter: Plane, intersectionTolerance: float) -> Iterable[Brep]: ...
    @overload
    def Trim(self, cutter: Brep, intersectionTolerance: float) -> Iterable[Brep]: ...
    @overload
    @staticmethod
    def TryConvertBrep(geometry: GeometryBase) -> Brep: ...
    @overload
    def UnjoinEdges(self, edgesToUnjoin: Iterable[int]) -> Iterable[Brep]: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class BrepEdge(CurveProxy):
    @overload
    def AdjacentFaces(self) -> Iterable[int]: ...
    @overload
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def ConcavityAt(self, t: float, tolerance: float) -> Concavity: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    @overload
    def ControlPolygon(self) -> Polyline: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateCurve(self) -> Curve: ...
    @overload
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    @overload
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    @overload
    def FilletSurfaceToCurve(self, face: BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FilletSurfaceToRail(self, faceWithCurve: BrepFace, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: List, out_breps0: List, out_breps1: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FindLocalInflection(self, N: Vector3d, subDomain: Interval, seed: float) -> Tuple[bool, float, float]: ...
    @overload
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Brep(self) -> Brep: ...
    @overload
    @property
    def Degree(self) -> int: ...
    @overload
    @property
    def Dimension(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Domain(self) -> Interval: ...
    @overload
    @property
    def EdgeCurve(self) -> Curve: ...
    @overload
    @property
    def EdgeCurveIndex(self) -> int: ...
    @overload
    @property
    def EdgeIndex(self) -> int: ...
    @overload
    @property
    def EndVertex(self) -> BrepVertex: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsPeriodic(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PointAtEnd(self) -> Point3d: ...
    @overload
    @property
    def PointAtMid(self) -> Point3d: ...
    @overload
    @property
    def PointAtStart(self) -> Point3d: ...
    @overload
    @property
    def ProxyBrepSubDEdgeId(self) -> int: ...
    @overload
    @property
    def ProxyCurveIsReversed(self) -> bool: ...
    @overload
    @property
    def SpanCount(self) -> int: ...
    @overload
    @property
    def StartVertex(self) -> BrepVertex: ...
    @overload
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @overload
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @overload
    @property
    def Tolerance(self) -> float: ...
    @overload
    @property
    def TrimCount(self) -> int: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def Valence(self) -> EdgeAdjacency: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    @overload
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetEdgeParameter(self, trimIndex: int, trimParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    @overload
    def GetSubCurves(self) -> Iterable[Curve]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def InflectionPoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    @overload
    def IsSmoothManifoldEdge(self, angleToleranceRadians: float) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    @overload
    def MakeClosed(self, tolerance: float) -> bool: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    @overload
    def MaxCurvaturePoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    @overload
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetTangentToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, length: float) -> Point3d: ...
    @overload
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float, loose: bool) -> Curve: ...
    @overload
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    @overload
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def Reparameterize(self) -> Curve: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, ribbonParameters: RibbonOffsetParameters) -> Tuple[Curve, Iterable[Curve], Iterable[Curve], Iterable[Brep]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Domain.setter
    def Domain(self, value: Interval) -> None: ...
    @overload
    @Tolerance.setter
    def Tolerance(self, value: float) -> None: ...
    @overload
    def SetEdgeCurve(self, curve3dIndex: int) -> bool: ...
    @overload
    def SetEdgeCurve(self, curve3dIndex: int, subDomain: Interval) -> bool: ...
    @overload
    def SetEndPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetStartPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    @overload
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def SpanVector(self) -> Iterable[float]: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    @overload
    def TorsionAt(self, t: float) -> float: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TrimIndices(self) -> Iterable[int]: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class BrepEdgeFilletDistance:
    @overload
    def __init__(self, edgeParameter: float, filletDistance: float): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def EdgeParameter(self) -> float: ...
    @overload
    @property
    def FilletDistance(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


from .Collections import BrepLoopList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class BrepFace(SurfaceProxy):
    @overload
    def AdjacentEdges(self) -> Iterable[int]: ...
    @overload
    def AdjacentFaces(self) -> Iterable[int]: ...
    @overload
    def ChangeSurface(self, surfaceIndex: int) -> bool: ...
    @overload
    def ClearMaterialChannelIndex(self) -> None: ...
    @overload
    def ClearPackId(self) -> None: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def CreateExtrusion(self, pathCurve: Curve, cap: bool) -> Brep: ...
    @overload
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def Degree(self, direction: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @overload
    def DraftAnglePoint(self, testPoint: Point2d, testAngle: float, pullDirection: Vector3d, edge: bool) -> Tuple[bool, Point3d, float]: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateFace(self, duplicateMeshes: bool) -> Brep: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def DuplicateSurface(self) -> Surface: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    @overload
    def FilletSurfaceToCurve(self, curve: Curve, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FilletSurfaceToRail(self, curveOnFace: Curve, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: List, out_breps0: List, out_breps1: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    @overload
    def FitCurveToSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], divideIntoSections: bool, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[Iterable[Curve], Curve, Curve]: ...
    @overload
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Brep(self) -> Brep: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def FaceIndex(self) -> int: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def Id(self) -> Guid: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsSurface(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Loops(self) -> BrepLoopList: ...
    @overload
    @property
    def MaterialChannelIndex(self) -> int: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def OrientationIsReversed(self) -> bool: ...
    @overload
    @property
    def OuterLoop(self) -> BrepLoop: ...
    @overload
    @property
    def PackId(self) -> int: ...
    @overload
    @property
    def PerFaceColor(self) -> Color: ...
    @overload
    @property
    def ProxyBrepSubDFaceId(self) -> int: ...
    @overload
    @property
    def SurfaceIndex(self) -> int: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetMesh(self, meshType: MeshType) -> Mesh: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    @overload
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    @overload
    def IsAtSeam(self, u: float, v: float) -> int: ...
    @overload
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    @overload
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    @overload
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    @overload
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPointOnFace(self, u: float, v: float) -> PointFaceRelation: ...
    @overload
    def IsPointOnFace(self, u: float, v: float, tolerance: float) -> PointFaceRelation: ...
    @overload
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def PullPointsToFace(self, points: Iterable[Point3d], tolerance: float) -> Iterable[Point3d]: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    @overload
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    def RebuildEdges(self, tolerance: float, rebuildSharedEdges: bool, rebuildVertices: bool) -> bool: ...
    @overload
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def RefitSimplySplitSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, knotAdditionMode: RefitTrimKnotMode, numInsertKnots: int, Knots: Iterable[float], sectionMode: RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Point3d, outputSurface: bool, outputCurve: bool, numSections: int, lowerSurface: List, upperSurface: List, edgeCurve: List, FitMeasurement: float, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[bool, int, float, Curve, Curve]: ...
    @overload
    def RefitSplit(self, curve: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], bMeetCurve: bool, divideIntoSections: bool, srfLower: List, srfUpper: List, edgeCurve: List, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[int, Curve, Curve]: ...
    @overload
    def RefitTrim(self, edge: BrepEdge, knots: Iterable[float], tolerance: float, bSections: bool, fitQuality: float) -> Tuple[Iterable[Surface], float]: ...
    @overload
    def RemoveHoles(self, tolerance: float) -> Brep: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Id.setter
    def Id(self, value: Guid) -> None: ...
    @overload
    @MaterialChannelIndex.setter
    def MaterialChannelIndex(self, value: int) -> None: ...
    @overload
    @OrientationIsReversed.setter
    def OrientationIsReversed(self, value: bool) -> None: ...
    @overload
    @PerFaceColor.setter
    def PerFaceColor(self, value: Color) -> None: ...
    @overload
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    @overload
    def SetMesh(self, meshType: MeshType, mesh: Mesh) -> bool: ...
    @overload
    def SetPackId(self, packId: int) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def ShrinkFace(self, disableSide: ShrinkDisableSide) -> bool: ...
    @overload
    def ShrinkSurfaceToEdge(self) -> bool: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    @overload
    def SpanCount(self, direction: int) -> int: ...
    @overload
    def Split(self, curves: Iterable[Curve], tolerance: float) -> Brep: ...
    @overload
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    @overload
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TrimAwareIsoCurve(self, direction: int, constantParameter: float) -> Iterable[Curve]: ...
    @overload
    def TrimAwareIsoIntervals(self, direction: int, constantParameter: float) -> Iterable[Interval]: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def UnderlyingSurface(self) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


from .Collections import BrepTrimList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class BrepLoop(GeometryBase):
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Brep(self) -> Brep: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Face(self) -> BrepFace: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsSurfaceBoundary(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def LoopIndex(self) -> int: ...
    @overload
    @property
    def LoopType(self) -> BrepLoopType: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def Trims(self) -> BrepTrimList: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def To2dCurve(self) -> Curve: ...
    @overload
    def To3dCurve(self) -> Curve: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class BrepLoopType(Enum):
    Unknown = 0
    Outer = 1
    Inner = 2
    Slit = 3
    CurveOnSurface = 4
    PointOnSurface = 5


from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
from ..Runtime import CommonObject
class BrepRegion(CommonObject):
    @overload
    def BoundaryBrep(self) -> Brep: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def Brep(self) -> Brep: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def Index(self) -> int: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsFinite(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    def GetFaceSides(self) -> Iterable[BrepRegionFaceSide]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...


from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
from ..Runtime import CommonObject
class BrepRegionFaceSide(CommonObject):
    @overload
    def Dispose(self) -> None: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Brep(self) -> Brep: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Face(self) -> BrepFace: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Region(self) -> BrepRegion: ...
    @overload
    @property
    def SurfaceNormalPointsIntoRegion(self) -> bool: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...


class BrepSolidOrientation(Enum):
    # None = 0
    Outward = 1
    Unknown = 2
    Inward = -1


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class BrepTrim(CurveProxy):
    @overload
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    @overload
    def ControlPolygon(self) -> Polyline: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateCurve(self) -> Curve: ...
    @overload
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    @overload
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    @overload
    def FilletSurfaceToCurve(self, face: BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FilletSurfaceToRail(self, faceWithCurve: BrepFace, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: List, out_breps0: List, out_breps1: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FindLocalInflection(self, N: Vector3d, subDomain: Interval, seed: float) -> Tuple[bool, float, float]: ...
    @overload
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Brep(self) -> Brep: ...
    @overload
    @property
    def Degree(self) -> int: ...
    @overload
    @property
    def Dimension(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Domain(self) -> Interval: ...
    @overload
    @property
    def Edge(self) -> BrepEdge: ...
    @overload
    @property
    def EndVertex(self) -> BrepVertex: ...
    @overload
    @property
    def Face(self) -> BrepFace: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsoStatus(self) -> IsoStatus: ...
    @overload
    @property
    def IsPeriodic(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Loop(self) -> BrepLoop: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PointAtEnd(self) -> Point3d: ...
    @overload
    @property
    def PointAtMid(self) -> Point3d: ...
    @overload
    @property
    def PointAtStart(self) -> Point3d: ...
    @overload
    @property
    def ProxyCurveIsReversed(self) -> bool: ...
    @overload
    @property
    def SpanCount(self) -> int: ...
    @overload
    @property
    def StartVertex(self) -> BrepVertex: ...
    @overload
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @overload
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @overload
    @property
    def TrimCurve(self) -> Curve: ...
    @overload
    @property
    def TrimCurveIndex(self) -> int: ...
    @overload
    @property
    def TrimIndex(self) -> int: ...
    @overload
    @property
    def TrimType(self) -> BrepTrimType: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    @overload
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    @overload
    def GetSubCurves(self) -> Iterable[Curve]: ...
    @overload
    def GetTolerances(self) -> Tuple[float, float]: ...
    @overload
    def GetTrimParameter(self, edgeParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def InflectionPoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPolyline(self) -> bool: ...
    @overload
    def IsReversed(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    @overload
    def MakeClosed(self, tolerance: float) -> bool: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    @overload
    def MaxCurvaturePoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    @overload
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetTangentToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, length: float) -> Point3d: ...
    @overload
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float, loose: bool) -> Curve: ...
    @overload
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    @overload
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def Reparameterize(self) -> Curve: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, ribbonParameters: RibbonOffsetParameters) -> Tuple[Curve, Iterable[Curve], Iterable[Curve], Iterable[Brep]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Domain.setter
    def Domain(self, value: Interval) -> None: ...
    @overload
    @IsoStatus.setter
    def IsoStatus(self, value: IsoStatus) -> None: ...
    @overload
    @TrimType.setter
    def TrimType(self, value: BrepTrimType) -> None: ...
    @overload
    def SetEndPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetStartPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetTolerances(self, toleranceU: float, toleranceV: float) -> None: ...
    @overload
    def SetTrimCurve(self, curve2dIndex: int) -> bool: ...
    @overload
    def SetTrimCurve(self, curve2dIndex: int, subDomain: Interval) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    @overload
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def SpanVector(self) -> Iterable[float]: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    @overload
    def TorsionAt(self, t: float) -> float: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class BrepTrimType(Enum):
    Unknown = 0
    Boundary = 1
    Mated = 2
    Seam = 3
    Singular = 4
    CurveOnSurface = 5
    PointOnSurface = 6
    Slit = 7


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class BrepVertex(Point):
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EdgeIndices(self) -> Iterable[int]: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Brep(self) -> Brep: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Location(self) -> Point3d: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ProxyBrepSubDVertexId(self) -> int: ...
    @overload
    @property
    def Tolerance(self) -> float: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def VertexIndex(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Location.setter
    def Location(self, value: Point3d) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


from ..DocObjects import DimensionStyle
from ..DocObjects import ViewportInfo
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ArrowType
from ..DocObjects import ZeroSuppression
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Centermark(Dimension):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, plane: Plane, centerPoint: Point3d, radius: float): ...
    @overload
    def __init__(self, plane: Plane, curve: Curve, curveParameter: float): ...
    @overload
    def AdjustFromPoints(self, plane: Plane, centerPoint: Point3d) -> bool: ...
    @overload
    def ClearPropertyOverrides(self) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(dimStyle: DimensionStyle, plane: Plane, centerPoint: Point3d, radius: float) -> Centermark: ...
    @overload
    @staticmethod
    def Create(dimStyle: DimensionStyle, plane: Plane, curve: Curve, curveParameter: float) -> Centermark: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Explode(self) -> Iterable[GeometryBase]: ...
    @overload
    @property
    def AlternateBelowLine(self) -> bool: ...
    @overload
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def AltLengthFactor(self) -> float: ...
    @overload
    @property
    def AltLengthResolution(self) -> int: ...
    @overload
    @property
    def AltLengthRoundoff(self) -> float: ...
    @overload
    @property
    def AltPrefix(self) -> str: ...
    @overload
    @property
    def AltSuffix(self) -> str: ...
    @overload
    @property
    def AltToleranceResolution(self) -> int: ...
    @overload
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @overload
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @overload
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @overload
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @overload
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @overload
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @overload
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @overload
    @property
    def ArrowSize(self) -> float: ...
    @overload
    @property
    def BaselineSpacing(self) -> float: ...
    @overload
    @property
    def CentermarkSize(self) -> float: ...
    @overload
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @overload
    @property
    def DecimalSeparator(self) -> Char: ...
    @overload
    @property
    def DetailMeasured(self) -> Guid: ...
    @overload
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def DimensionLineExtension(self) -> float: ...
    @overload
    @property
    def DimensionScale(self) -> float: ...
    @overload
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def DimensionStyleId(self) -> Guid: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def DistanceScale(self) -> float: ...
    @overload
    @property
    def DrawForward(self) -> bool: ...
    @overload
    @property
    def DrawTextFrame(self) -> bool: ...
    @overload
    @property
    def ExtensionLineExtension(self) -> float: ...
    @overload
    @property
    def ExtensionLineOffset(self) -> float: ...
    @overload
    @property
    def FirstCharFont(self) -> Font: ...
    @overload
    @property
    def FixedExtensionLength(self) -> float: ...
    @overload
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @overload
    @property
    def Font(self) -> Font: ...
    @overload
    @property
    def FontIndex(self) -> int: ...
    @overload
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @overload
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @overload
    @property
    def ForceDimLine(self) -> bool: ...
    @overload
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @overload
    @property
    def FormatWidth(self) -> float: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def LengthFactor(self) -> float: ...
    @overload
    @property
    def LengthResolution(self) -> int: ...
    @overload
    @property
    def LengthRoundoff(self) -> float: ...
    @overload
    @property
    def MaskColor(self) -> Color: ...
    @overload
    @property
    def MaskColorSource(self) -> MaskType: ...
    @overload
    @property
    def MaskEnabled(self) -> bool: ...
    @overload
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @overload
    @property
    def MaskOffset(self) -> float: ...
    @overload
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @overload
    @property
    def NumericValue(self) -> float: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def PlainText(self) -> str: ...
    @overload
    @property
    def PlainTextWithFields(self) -> str: ...
    @overload
    @property
    def PlainUserText(self) -> str: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Prefix(self) -> str: ...
    @overload
    @property
    def Radius(self) -> float: ...
    @overload
    @property
    def RichText(self) -> str: ...
    @overload
    @property
    def Suffix(self) -> str: ...
    @overload
    @property
    def SuppressExtension1(self) -> bool: ...
    @overload
    @property
    def SuppressExtension2(self) -> bool: ...
    @overload
    @property
    def Text(self) -> str: ...
    @overload
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @overload
    @property
    def TextFit(self) -> TextFit: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @overload
    @property
    def TextHeight(self) -> float: ...
    @overload
    @property
    def TextIsWrapped(self) -> bool: ...
    @overload
    @property
    def TextLocation(self) -> TextLocation: ...
    @overload
    @property
    def TextModelWidth(self) -> float: ...
    @overload
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @overload
    @property
    def TextPosition(self) -> Point2d: ...
    @overload
    @property
    def TextRotation(self) -> float: ...
    @overload
    @property
    def TextRotationDegrees(self) -> float: ...
    @overload
    @property
    def TextRotationRadians(self) -> float: ...
    @overload
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @overload
    @property
    def ToleranceHeightScale(self) -> float: ...
    @overload
    @property
    def ToleranceLowerValue(self) -> float: ...
    @overload
    @property
    def ToleranceResolution(self) -> int: ...
    @overload
    @property
    def ToleranceUpperValue(self) -> float: ...
    @overload
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    @overload
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsAllBold(self) -> bool: ...
    @overload
    def IsAllItalic(self) -> bool: ...
    @overload
    def IsAllUnderlined(self) -> bool: ...
    @overload
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @AlternateBelowLine.setter
    def AlternateBelowLine(self, value: bool) -> None: ...
    @overload
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @AltLengthFactor.setter
    def AltLengthFactor(self, value: float) -> None: ...
    @overload
    @AltLengthResolution.setter
    def AltLengthResolution(self, value: int) -> None: ...
    @overload
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self, value: float) -> None: ...
    @overload
    @AltPrefix.setter
    def AltPrefix(self, value: str) -> None: ...
    @overload
    @AltSuffix.setter
    def AltSuffix(self, value: str) -> None: ...
    @overload
    @AltToleranceResolution.setter
    def AltToleranceResolution(self, value: int) -> None: ...
    @overload
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self, value: bool) -> None: ...
    @overload
    @AltZeroSuppression.setter
    def AltZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    @ArrowBlockId1.setter
    def ArrowBlockId1(self, value: Guid) -> None: ...
    @overload
    @ArrowBlockId2.setter
    def ArrowBlockId2(self, value: Guid) -> None: ...
    @overload
    @ArrowFit.setter
    def ArrowFit(self, value: ArrowFit) -> None: ...
    @overload
    @ArrowheadType1.setter
    def ArrowheadType1(self, value: ArrowType) -> None: ...
    @overload
    @ArrowheadType2.setter
    def ArrowheadType2(self, value: ArrowType) -> None: ...
    @overload
    @ArrowSize.setter
    def ArrowSize(self, value: float) -> None: ...
    @overload
    @BaselineSpacing.setter
    def BaselineSpacing(self, value: float) -> None: ...
    @overload
    @CentermarkSize.setter
    def CentermarkSize(self, value: float) -> None: ...
    @overload
    @CentermarkStyle.setter
    def CentermarkStyle(self, value: CenterMarkStyle) -> None: ...
    @overload
    @DecimalSeparator.setter
    def DecimalSeparator(self, value: Char) -> None: ...
    @overload
    @DetailMeasured.setter
    def DetailMeasured(self, value: Guid) -> None: ...
    @overload
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DimensionLineExtension.setter
    def DimensionLineExtension(self, value: float) -> None: ...
    @overload
    @DimensionScale.setter
    def DimensionScale(self, value: float) -> None: ...
    @overload
    @DimensionStyleId.setter
    def DimensionStyleId(self, value: Guid) -> None: ...
    @overload
    @DistanceScale.setter
    def DistanceScale(self, value: float) -> None: ...
    @overload
    @DrawForward.setter
    def DrawForward(self, value: bool) -> None: ...
    @overload
    @DrawTextFrame.setter
    def DrawTextFrame(self, value: bool) -> None: ...
    @overload
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self, value: float) -> None: ...
    @overload
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self, value: float) -> None: ...
    @overload
    @FixedExtensionLength.setter
    def FixedExtensionLength(self, value: float) -> None: ...
    @overload
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self, value: bool) -> None: ...
    @overload
    @Font.setter
    def Font(self, value: Font) -> None: ...
    @overload
    @FontIndex.setter
    def FontIndex(self, value: int) -> None: ...
    @overload
    @ForceArrowPosition.setter
    def ForceArrowPosition(self, value: ForceArrow) -> None: ...
    @overload
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self, value: bool) -> None: ...
    @overload
    @ForceDimLine.setter
    def ForceDimLine(self, value: bool) -> None: ...
    @overload
    @ForceTextPosition.setter
    def ForceTextPosition(self, value: ForceText) -> None: ...
    @overload
    @FormatWidth.setter
    def FormatWidth(self, value: float) -> None: ...
    @overload
    @LengthFactor.setter
    def LengthFactor(self, value: float) -> None: ...
    @overload
    @LengthResolution.setter
    def LengthResolution(self, value: int) -> None: ...
    @overload
    @LengthRoundoff.setter
    def LengthRoundoff(self, value: float) -> None: ...
    @overload
    @MaskColor.setter
    def MaskColor(self, value: Color) -> None: ...
    @overload
    @MaskColorSource.setter
    def MaskColorSource(self, value: MaskType) -> None: ...
    @overload
    @MaskEnabled.setter
    def MaskEnabled(self, value: bool) -> None: ...
    @overload
    @MaskFrame.setter
    def MaskFrame(self, value: MaskFrame) -> None: ...
    @overload
    @MaskOffset.setter
    def MaskOffset(self, value: float) -> None: ...
    @overload
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self, value: bool) -> None: ...
    @overload
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self, value: DimensionStyle) -> None: ...
    @overload
    @PlainText.setter
    def PlainText(self, value: str) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @Prefix.setter
    def Prefix(self, value: str) -> None: ...
    @overload
    @Radius.setter
    def Radius(self, value: float) -> None: ...
    @overload
    @RichText.setter
    def RichText(self, value: str) -> None: ...
    @overload
    @Suffix.setter
    def Suffix(self, value: str) -> None: ...
    @overload
    @SuppressExtension1.setter
    def SuppressExtension1(self, value: bool) -> None: ...
    @overload
    @SuppressExtension2.setter
    def SuppressExtension2(self, value: bool) -> None: ...
    @overload
    @Text.setter
    def Text(self, value: str) -> None: ...
    @overload
    @TextAngleType.setter
    def TextAngleType(self, value: LeaderContentAngleStyle) -> None: ...
    @overload
    @TextFit.setter
    def TextFit(self, value: TextFit) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextHeight.setter
    def TextHeight(self, value: float) -> None: ...
    @overload
    @TextIsWrapped.setter
    def TextIsWrapped(self, value: bool) -> None: ...
    @overload
    @TextLocation.setter
    def TextLocation(self, value: TextLocation) -> None: ...
    @overload
    @TextOrientation.setter
    def TextOrientation(self, value: TextOrientation) -> None: ...
    @overload
    @TextPosition.setter
    def TextPosition(self, value: Point2d) -> None: ...
    @overload
    @TextRotation.setter
    def TextRotation(self, value: float) -> None: ...
    @overload
    @TextRotationDegrees.setter
    def TextRotationDegrees(self, value: float) -> None: ...
    @overload
    @TextRotationRadians.setter
    def TextRotationRadians(self, value: float) -> None: ...
    @overload
    @ToleranceFormat.setter
    def ToleranceFormat(self, value: ToleranceDisplayFormat) -> None: ...
    @overload
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self, value: float) -> None: ...
    @overload
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self, value: float) -> None: ...
    @overload
    @ToleranceResolution.setter
    def ToleranceResolution(self, value: int) -> None: ...
    @overload
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self, value: float) -> None: ...
    @overload
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self, value: bool) -> None: ...
    @overload
    @ZeroSuppression.setter
    def ZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetBold(self, set_on: bool) -> bool: ...
    @overload
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    @overload
    def SetItalic(self, set_on: bool) -> bool: ...
    @overload
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    @overload
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    @overload
    def SetUnderline(self, set_on: bool) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    @overload
    def WrapText(self) -> None: ...


class Circle:
    @overload
    def __init__(self, radius: float): ...
    @overload
    def __init__(self, arc: Arc): ...
    @overload
    def __init__(self, plane: Plane, radius: float): ...
    @overload
    def __init__(self, center: Point3d, radius: float): ...
    @overload
    def __init__(self, point1: Point3d, point2: Point3d, point3: Point3d): ...
    @overload
    def __init__(self, plane: Plane, center: Point3d, radius: float): ...
    @overload
    def __init__(self, startPoint: Point3d, tangentAtP: Vector3d, pointOnCircle: Point3d): ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def DerivativeAt(self, derivative: int, t: float) -> Vector3d: ...
    @overload
    def EpsilonEquals(self, other: Circle, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def Center(self) -> Point3d: ...
    @overload
    @property
    def Circumference(self) -> float: ...
    @overload
    @property
    def Diameter(self) -> float: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Normal(self) -> Vector3d: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Radius(self) -> float: ...
    @overload
    @property
    def Unset() -> Circle: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IsInPlane(self, plane: Plane, tolerance: float) -> bool: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d, point: Point3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d, point: Point3d) -> bool: ...
    @overload
    @Center.setter
    def Center(self, value: Point3d) -> None: ...
    @overload
    @Circumference.setter
    def Circumference(self, value: float) -> None: ...
    @overload
    @Diameter.setter
    def Diameter(self, value: float) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @Radius.setter
    def Radius(self, value: float) -> None: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, delta: Vector3d) -> bool: ...
    @overload
    @staticmethod
    def TryFitCircleToPoints(points: Iterable[Point3d]) -> Tuple[bool, Circle]: ...
    @overload
    @staticmethod
    def TryFitCircleTT(c1: Curve, c2: Curve, t1: float, t2: float) -> Circle: ...
    @overload
    @staticmethod
    def TryFitCircleTTT(c1: Curve, c2: Curve, c3: Curve, t1: float, t2: float, t3: float) -> Circle: ...
    @overload
    @staticmethod
    def TrySmallestEnclosingCircle(points: Iterable[Point2d], tolerance: float) -> Tuple[bool, Circle, Iterable[int]]: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class ClippingPlaneSurface(PlaneSurface):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, plane: Plane): ...
    @overload
    def __init__(self, planeSurface: PlaneSurface): ...
    @overload
    def AddClipViewportId(self, viewportId: Guid) -> bool: ...
    @overload
    def ClearClipParticipationLists(self) -> None: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def Degree(self, direction: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    @overload
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    @overload
    def FitCurveToSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], divideIntoSections: bool, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[Iterable[Curve], Curve, Curve]: ...
    @overload
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ParticipationListsEnabled(self) -> bool: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def PlaneDepth(self) -> float: ...
    @overload
    @property
    def PlaneDepthEnabled(self) -> bool: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetClipParticipation(self) -> Tuple[Iterable[Any], Iterable[Any], bool]: ...
    @overload
    def GetExtents(self, direction: int) -> Interval: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    @overload
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    @overload
    def IsAtSeam(self, u: float, v: float) -> int: ...
    @overload
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    @overload
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    @overload
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    @overload
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    @overload
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def RefitSimplySplitSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, knotAdditionMode: RefitTrimKnotMode, numInsertKnots: int, Knots: Iterable[float], sectionMode: RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Point3d, outputSurface: bool, outputCurve: bool, numSections: int, lowerSurface: List, upperSurface: List, edgeCurve: List, FitMeasurement: float, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[bool, int, float, Curve, Curve]: ...
    @overload
    def RefitSplit(self, curve: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], bMeetCurve: bool, divideIntoSections: bool, srfLower: List, srfUpper: List, edgeCurve: List, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[int, Curve, Curve]: ...
    @overload
    def RemoveClipViewportId(self, viewportId: Guid) -> bool: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @ParticipationListsEnabled.setter
    def ParticipationListsEnabled(self, value: bool) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @PlaneDepth.setter
    def PlaneDepth(self, value: float) -> None: ...
    @overload
    @PlaneDepthEnabled.setter
    def PlaneDepthEnabled(self, value: bool) -> None: ...
    @overload
    def SetClipParticipation(self, objectIds: Iterable[Guid], layerIndices: Iterable[int], isExclusionList: bool) -> None: ...
    @overload
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    @overload
    def SetExtents(self, direction: int, extents: Interval, syncDomain: bool) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    @overload
    def SpanCount(self, direction: int) -> int: ...
    @overload
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToMesh(self) -> Mesh: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    @overload
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...
    @overload
    def ViewportIds(self) -> Iterable[Guid]: ...


class ComponentIndex:
    @overload
    def __init__(self, type: ComponentIndexType, index: int): ...
    @overload
    def CompareTo(self, other: ComponentIndex) -> int: ...
    @overload
    def Equals(self, other: ComponentIndex) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ComponentIndexType(self) -> ComponentIndexType: ...
    @overload
    @property
    def Index(self) -> int: ...
    @overload
    @property
    def Unset() -> ComponentIndex: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IsUnset(self) -> bool: ...
    @overload
    def __eq__(a: ComponentIndex, b: ComponentIndex) -> bool: ...
    @overload
    def __gt__(a: ComponentIndex, b: ComponentIndex) -> bool: ...
    @overload
    def __ge__(a: ComponentIndex, b: ComponentIndex) -> bool: ...
    @overload
    def __ne__(a: ComponentIndex, b: ComponentIndex) -> bool: ...
    @overload
    def __lt__(a: ComponentIndex, b: ComponentIndex) -> bool: ...
    @overload
    def __le__(a: ComponentIndex, b: ComponentIndex) -> bool: ...
    @overload
    def ToString(self) -> str: ...


class ComponentIndexType(Enum):
    InvalidType = 0
    BrepVertex = 1
    BrepEdge = 2
    BrepFace = 3
    BrepTrim = 4
    BrepLoop = 5
    MeshVertex = 11
    MeshTopologyVertex = 12
    MeshTopologyEdge = 13
    MeshFace = 14
    MeshNgon = 15
    InstanceDefinitionPart = 21
    PolycurveSegment = 31
    PointCloudPoint = 41
    GroupMember = 51
    ExtrusionBottomProfile = 61
    ExtrusionTopProfile = 62
    ExtrusionWallEdge = 63
    ExtrusionWallSurface = 64
    ExtrusionCapSurface = 65
    ExtrusionPath = 66
    SubdVertex = 71
    SubdEdge = 72
    SubdFace = 73
    DimLinearPoint = 100
    DimRadialPoint = 101
    DimAngularPoint = 102
    DimOrdinatePoint = 103
    DimTextPoint = 104
    NoType = 268435455


class ComponentStatus:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: ComponentStatus) -> bool: ...
    @overload
    @property
    def AllSet() -> ComponentStatus: ...
    @overload
    @property
    def Clear() -> ComponentStatus: ...
    @overload
    @property
    def Damaged() -> ComponentStatus: ...
    @overload
    @property
    def Hidden() -> ComponentStatus: ...
    @overload
    @property
    def Highlighted() -> ComponentStatus: ...
    @overload
    @property
    def IsClear(self) -> bool: ...
    @overload
    @property
    def IsDamaged(self) -> bool: ...
    @overload
    @property
    def IsHidden(self) -> bool: ...
    @overload
    @property
    def IsHighlighted(self) -> bool: ...
    @overload
    @property
    def IsLocked(self) -> bool: ...
    @overload
    @property
    def IsSelected(self) -> bool: ...
    @overload
    @property
    def IsSelectedPersistent(self) -> bool: ...
    @overload
    @property
    def Locked() -> ComponentStatus: ...
    @overload
    @property
    def Selected() -> ComponentStatus: ...
    @overload
    @property
    def SelectedPersistent() -> ComponentStatus: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def HasAllEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    @overload
    def HasNoEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    @overload
    def HasSomeEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    @overload
    def __add__(a: ComponentStatus, b: ComponentStatus) -> ComponentStatus: ...
    @overload
    def __eq__(a: ComponentStatus, b: ComponentStatus) -> bool: ...
    @overload
    def __ne__(a: ComponentStatus, b: ComponentStatus) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def WithStates(self, additionalStatus: ComponentStatus) -> ComponentStatus: ...


class ConcaveCornerOption(Enum):
    Unset = 0
    # None = 1
    AtMeshCorner = 2


class Concavity(Enum):
    Tangent = 0
    Convex = 1
    Concave = 2
    # None = -1


class Cone:
    @overload
    def __init__(self, plane: Plane, height: float, radius: float): ...
    @overload
    def AngleInDegrees(self) -> float: ...
    @overload
    def AngleInRadians(self) -> float: ...
    @overload
    def EpsilonEquals(self, other: Cone, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ApexPoint(self) -> Point3d: ...
    @overload
    @property
    def Axis(self) -> Vector3d: ...
    @overload
    @property
    def BasePoint(self) -> Point3d: ...
    @overload
    @property
    def Height(self) -> float: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Radius(self) -> float: ...
    @overload
    @property
    def Unset() -> Cone: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @Height.setter
    def Height(self, value: float) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @Radius.setter
    def Radius(self, value: float) -> None: ...
    @overload
    def ToBrep(self, capBottom: bool) -> Brep: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToRevSurface(self) -> RevSurface: ...
    @overload
    def ToString(self) -> str: ...


class ConicSectionType(Enum):
    Unknown = 0
    Circle = 1
    Ellipse = 2
    Hyperbola = 3
    Parabola = 4


class Continuity(Enum):
    # None = 0
    C0_continuous = 1
    C1_continuous = 2
    C2_continuous = 3
    G1_continuous = 4
    G2_continuous = 5
    C0_locus_continuous = 6
    C1_locus_continuous = 7
    C2_locus_continuous = 8
    G1_locus_continuous = 9
    G2_locus_continuous = 10
    Cinfinity_continuous = 11
    Gsmooth_continuous = 12


class ControlPoint:
    @overload
    def __init__(self, pt: Point3d): ...
    @overload
    def __init__(self, pt: Point4d): ...
    @overload
    def __init__(self, euclideanPt: Point3d, weight: float): ...
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    def __init__(self, x: float, y: float, z: float, weight: float): ...
    @overload
    def EpsilonEquals(self, other: ControlPoint, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: ControlPoint) -> bool: ...
    @overload
    @property
    def Location(self) -> Point3d: ...
    @overload
    @property
    def Unset() -> ControlPoint: ...
    @overload
    @property
    def Weight(self) -> float: ...
    @overload
    @property
    def X(self) -> float: ...
    @overload
    @property
    def Y(self) -> float: ...
    @overload
    @property
    def Z(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @Location.setter
    def Location(self, value: Point3d) -> None: ...
    @overload
    @Weight.setter
    def Weight(self, value: float) -> None: ...
    @overload
    @X.setter
    def X(self, value: float) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    @Z.setter
    def Z(self, value: float) -> None: ...
    @overload
    def ToString(self) -> str: ...


class ConvexCornerOption(Enum):
    Unset = 0
    # None = 1
    AtMeshCorner = 2


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Curve(GeometryBase):
    @overload
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    @overload
    def ControlPolygon(self) -> Polyline: ...
    @overload
    @staticmethod
    def CreateArcBlend(startPt: Point3d, startDir: Vector3d, endPt: Point3d, endDir: Vector3d, controlPointLengthRatio: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateArcCornerRectangle(rectangle: Rectangle3d, radius: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateArcLineArcBlend(startPt: Point3d, startDir: Vector3d, endPt: Point3d, endDir: Vector3d, radius: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateBlendCurve(curveA: Curve, curveB: Curve, continuity: BlendContinuity) -> Curve: ...
    @overload
    @staticmethod
    def CreateBlendCurve(curveA: Curve, curveB: Curve, continuity: BlendContinuity, bulgeA: float, bulgeB: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateBlendCurve(curve0: Curve, t0: float, reverse0: bool, continuity0: BlendContinuity, curve1: Curve, t1: float, reverse1: bool, continuity1: BlendContinuity) -> Curve: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(curveA: Curve, subtractors: Iterable[Curve], tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(curveA: Curve, curveB: Curve, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(curveA: Curve, curveB: Curve, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateBooleanRegions(curves: Iterable[Curve], plane: Plane, combineRegions: bool, tolerance: float) -> CurveBooleanRegions: ...
    @overload
    @staticmethod
    def CreateBooleanRegions(curves: Iterable[Curve], plane: Plane, points: Iterable[Point3d], combineRegions: bool, tolerance: float) -> CurveBooleanRegions: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(curves: Iterable[Curve], tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateConicCornerRectangle(rectangle: Rectangle3d, rho: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateControlPointCurve(points: Iterable[Point3d]) -> Curve: ...
    @overload
    @staticmethod
    def CreateControlPointCurve(points: Iterable[Point3d], degree: int) -> Curve: ...
    @overload
    @staticmethod
    def CreateCurve2View(curveA: Curve, curveB: Curve, vectorA: Vector3d, vectorB: Vector3d, tolerance: float, angleTolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateFillet(curve0: Curve, curve1: Curve, radius: float, t0Base: float, t1Base: float) -> Arc: ...
    @overload
    @staticmethod
    def CreateFilletCornersCurve(curve: Curve, radius: float, tolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateFilletCurves(curve0: Curve, point0: Point3d, curve1: Curve, point1: Point3d, radius: float, join: bool, trim: bool, arcExtension: bool, tolerance: float, angleTolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateInterpolatedCurve(points: Iterable[Point3d], degree: int) -> Curve: ...
    @overload
    @staticmethod
    def CreateInterpolatedCurve(points: Iterable[Point3d], degree: int, knots: CurveKnotStyle) -> Curve: ...
    @overload
    @staticmethod
    def CreateInterpolatedCurve(points: Iterable[Point3d], degree: int, knots: CurveKnotStyle, startTangent: Vector3d, endTangent: Vector3d) -> Curve: ...
    @overload
    @staticmethod
    def CreateMatchCurve(curve0: Curve, reverse0: bool, continuity: BlendContinuity, curve1: Curve, reverse1: bool, preserve: PreserveEnd, average: bool) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateMeanCurve(curveA: Curve, curveB: Curve) -> Curve: ...
    @overload
    @staticmethod
    def CreateMeanCurve(curveA: Curve, curveB: Curve, angleToleranceRadians: float) -> Curve: ...
    @overload
    @staticmethod
    def CreatePeriodicCurve(curve: Curve) -> Curve: ...
    @overload
    @staticmethod
    def CreatePeriodicCurve(curve: Curve, smooth: bool) -> Curve: ...
    @overload
    @staticmethod
    def CreateRevisionCloud(points: Iterable[Point3d], angle: float, flip: bool) -> Curve: ...
    @overload
    @staticmethod
    def CreateRevisionCloud(curve: Curve, segmentCount: int, angle: float, flip: bool) -> Curve: ...
    @overload
    @staticmethod
    def CreateSoftEditCurve(curve: Curve, t: float, delta: Vector3d, length: float, fixEnds: bool) -> Curve: ...
    @overload
    @staticmethod
    def CreateTextOutlines(text: str, font: str, textHeight: float, textStyle: int, closeLoops: bool, plane: Plane, smallCapsScale: float, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateTweenCurves(curve0: Curve, curve1: Curve, numCurves: int, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateTweenCurvesWithMatching(curve0: Curve, curve1: Curve, numCurves: int, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateTweenCurvesWithSampling(curve0: Curve, curve1: Curve, numCurves: int, numSamples: int, tolerance: float) -> Iterable[Curve]: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    @staticmethod
    def DoDirectionsMatch(curveA: Curve, curveB: Curve) -> bool: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateCurve(self) -> Curve: ...
    @overload
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    @overload
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    @overload
    def FilletSurfaceToCurve(self, face: BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FilletSurfaceToRail(self, faceWithCurve: BrepFace, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: List, out_breps0: List, out_breps1: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FindLocalInflection(self, N: Vector3d, subDomain: Interval, seed: float) -> Tuple[bool, float, float]: ...
    @overload
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Degree(self) -> int: ...
    @overload
    @property
    def Dimension(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Domain(self) -> Interval: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsPeriodic(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PointAtEnd(self) -> Point3d: ...
    @overload
    @property
    def PointAtMid(self) -> Point3d: ...
    @overload
    @property
    def PointAtStart(self) -> Point3d: ...
    @overload
    @property
    def SpanCount(self) -> int: ...
    @overload
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @overload
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    @overload
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    @overload
    @staticmethod
    def GetDistancesBetweenCurves(curveA: Curve, curveB: Curve, tolerance: float) -> Tuple[bool, float, float, float, float, float, float]: ...
    @overload
    @staticmethod
    def GetFilletPoints(curve0: Curve, curve1: Curve, radius: float, t0Base: float, t1Base: float) -> Tuple[bool, float, float, Plane]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    @overload
    def GetSubCurves(self) -> Iterable[Curve]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def InflectionPoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Iterable[Curve]) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Iterable[Curve], joinTolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Iterable[Curve], joinTolerance: float, preserveDirection: bool) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Iterable[Curve], joinTolerance: float, preserveDirection: bool) -> Tuple[Iterable[Curve], Iterable[int]]: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Iterable[Curve], joinTolerance: float, preserveDirection: bool, simpleJoin: bool) -> Tuple[Iterable[Curve], Iterable[int]]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    @overload
    def MakeClosed(self, tolerance: float) -> bool: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    @staticmethod
    def MakeEndsMeet(curveA: Curve, adjustStartCurveA: bool, curveB: Curve, adjustStartCurveB: bool) -> bool: ...
    @overload
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    @overload
    def MaxCurvaturePoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    @overload
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetTangentToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    @staticmethod
    def PlanarClosedCurveRelationship(curveA: Curve, curveB: Curve, testPlane: Plane, tolerance: float) -> RegionContainment: ...
    @overload
    @staticmethod
    def PlanarCurveCollision(curveA: Curve, curveB: Curve, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, length: float) -> Point3d: ...
    @overload
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    @overload
    @staticmethod
    def ProjectToBrep(curve: Curve, brep: Brep, direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curve: Curve, breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curves: Iterable[Curve], breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curve: Curve, breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Tuple[Iterable[Curve], Iterable[int]]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curves: Iterable[Curve], breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Tuple[Iterable[Curve], Iterable[int], Iterable[int]]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curves: Iterable[Curve], breps: Iterable[Brep], direction: Vector3d, tolerance: float, loose: bool) -> Tuple[Iterable[Curve], Iterable[int], Iterable[int]]: ...
    @overload
    @staticmethod
    def ProjectToMesh(curve: Curve, mesh: Mesh, direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToMesh(curve: Curve, meshes: Iterable[Mesh], direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToMesh(curves: Iterable[Curve], meshes: Iterable[Mesh], direction: Vector3d, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToMesh(curves: Iterable[Curve], meshes: Iterable[Mesh], direction: Vector3d, tolerance: float, loose: bool) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def ProjectToPlane(curve: Curve, plane: Plane) -> Curve: ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def PullToBrepFace(curve: Curve, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def PullToBrepFace(curve: Curve, face: BrepFace, tolerance: float, loose: bool) -> Iterable[Curve]: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float, loose: bool) -> Curve: ...
    @overload
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    @overload
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def Reparameterize(self) -> Curve: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, ribbonParameters: RibbonOffsetParameters) -> Tuple[Curve, Iterable[Curve], Iterable[Curve], Iterable[Brep]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Domain.setter
    def Domain(self, value: Interval) -> None: ...
    @overload
    def SetEndPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetStartPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    @overload
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def SpanVector(self) -> Iterable[float]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    @overload
    def TorsionAt(self, t: float) -> float: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class CurveBooleanRegions:
    @overload
    def BoundaryCount(self, regionIndex: int) -> int: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def PlanarCurveCount(self) -> int: ...
    @overload
    @property
    def PointCount(self) -> int: ...
    @overload
    @property
    def RegionCount(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def PlanarCurve(self, planarCurveIndex: int) -> Curve: ...
    @overload
    def RegionCurves(self, regionIndex: int) -> Iterable[Curve]: ...
    @overload
    def RegionPointIndex(self, pointIndex: int) -> int: ...
    @overload
    def SegmentCount(self, regionIndex: int, boundaryIndex: int) -> int: ...
    @overload
    def SegmentDetails(self, regionIndex: int, boundaryIndex: int, segmmentIndex: int) -> Tuple[int, Interval, bool]: ...
    @overload
    def ToString(self) -> str: ...


class CurveEnd(Enum):
    # None = 0
    Start = 1
    End = 2
    Both = 3


class CurveEvaluationSide(Enum):
    Default = 0
    Above = 1
    Below = -1


class CurveExtensionStyle(Enum):
    Line = 0
    Arc = 1
    Smooth = 2


class CurveKnotStyle(Enum):
    Uniform = 0
    Chord = 1
    ChordSquareRoot = 2
    UniformPeriodic = 3
    ChordPeriodic = 4
    ChordSquareRootPeriodic = 5


class CurveOffsetCornerStyle(Enum):
    # None = 0
    Sharp = 1
    Round = 2
    Smooth = 3
    Chamfer = 4


class CurveOffsetEndStyle(Enum):
    # None = 0
    Flat = 1
    Round = 2


class CurveOrientation(Enum):
    Undefined = 0
    CounterClockwise = 1
    Clockwise = -1


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class CurveProxy(Curve):
    @overload
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    @overload
    def ControlPolygon(self) -> Polyline: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateCurve(self) -> Curve: ...
    @overload
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    @overload
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    @overload
    def FilletSurfaceToCurve(self, face: BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FilletSurfaceToRail(self, faceWithCurve: BrepFace, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: List, out_breps0: List, out_breps1: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FindLocalInflection(self, N: Vector3d, subDomain: Interval, seed: float) -> Tuple[bool, float, float]: ...
    @overload
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Degree(self) -> int: ...
    @overload
    @property
    def Dimension(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Domain(self) -> Interval: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsPeriodic(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PointAtEnd(self) -> Point3d: ...
    @overload
    @property
    def PointAtMid(self) -> Point3d: ...
    @overload
    @property
    def PointAtStart(self) -> Point3d: ...
    @overload
    @property
    def ProxyCurveIsReversed(self) -> bool: ...
    @overload
    @property
    def SpanCount(self) -> int: ...
    @overload
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @overload
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    @overload
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    @overload
    def GetSubCurves(self) -> Iterable[Curve]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def InflectionPoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    @overload
    def MakeClosed(self, tolerance: float) -> bool: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    @overload
    def MaxCurvaturePoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    @overload
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetTangentToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, length: float) -> Point3d: ...
    @overload
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float, loose: bool) -> Curve: ...
    @overload
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    @overload
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def Reparameterize(self) -> Curve: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, ribbonParameters: RibbonOffsetParameters) -> Tuple[Curve, Iterable[Curve], Iterable[Curve], Iterable[Brep]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Domain.setter
    def Domain(self, value: Interval) -> None: ...
    @overload
    def SetEndPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetStartPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    @overload
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def SpanVector(self) -> Iterable[float]: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    @overload
    def TorsionAt(self, t: float) -> float: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class CurveSimplifyOptions(Enum):
    # None = 0
    SplitAtFullyMultipleKnots = 1
    RebuildLines = 2
    RebuildArcs = 4
    RebuildRationals = 8
    AdjustG1 = 16
    Merge = 32
    All = 63


class Cylinder:
    @overload
    def __init__(self, baseCircle: Circle): ...
    @overload
    def __init__(self, baseCircle: Circle, height: float): ...
    @overload
    def CircleAt(self, linearParameter: float) -> Circle: ...
    @overload
    def EpsilonEquals(self, other: Cylinder, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Axis(self) -> Vector3d: ...
    @overload
    @property
    def BasePlane(self) -> Plane: ...
    @overload
    @property
    def Center(self) -> Point3d: ...
    @overload
    @property
    def Height1(self) -> float: ...
    @overload
    @property
    def Height2(self) -> float: ...
    @overload
    @property
    def IsFinite(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Radius(self) -> float: ...
    @overload
    @property
    def TotalHeight(self) -> float: ...
    @overload
    @property
    def Unset() -> Cylinder: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def LineAt(self, angularParameter: float) -> Line: ...
    @overload
    @BasePlane.setter
    def BasePlane(self, value: Plane) -> None: ...
    @overload
    @Height1.setter
    def Height1(self, value: float) -> None: ...
    @overload
    @Height2.setter
    def Height2(self, value: float) -> None: ...
    @overload
    @Radius.setter
    def Radius(self, value: float) -> None: ...
    @overload
    def ToBrep(self, capBottom: bool, capTop: bool) -> Brep: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToRevSurface(self) -> RevSurface: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...


class Density(Enum):
    UnsetDensity = 0
    MinimumDensity = 0
    ExtraCoarseDensity = 1
    MinimumUserInterfaceDensity = 1
    MinimumAdaptiveDensity = 1
    CoarseDensity = 2
    MediumDensity = 3
    DefaultDensity = 4
    FineDensity = 4
    MaximumUserInterfaceDensity = 5
    ExtraFineDensity = 5
    MaximumDensity = 6


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class DetailView(GeometryBase):
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsParallelProjection(self) -> bool: ...
    @overload
    @property
    def IsPerspectiveProjection(self) -> bool: ...
    @overload
    @property
    def IsProjectionLocked(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PageToModelRatio(self) -> float: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @IsParallelProjection.setter
    def IsParallelProjection(self, value: bool) -> None: ...
    @overload
    @IsPerspectiveProjection.setter
    def IsPerspectiveProjection(self, value: bool) -> None: ...
    @overload
    @IsProjectionLocked.setter
    def IsProjectionLocked(self, value: bool) -> None: ...
    @overload
    def SetScale(self, modelLength: float, modelUnits: UnitSystem, pageLength: float, pageUnits: UnitSystem) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class DevelopableSrf:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    @staticmethod
    def GetLocalDevopableRuling(rail0: NurbsCurve, t0: float, dom0: Interval, rail1: NurbsCurve, t1: float, dom1: Interval, t0_out: float, t1_out: float) -> Tuple[int, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def RulingMinTwist(rail0: NurbsCurve, t0: float, rail1: NurbsCurve, t1: float, dom1: Interval, t1_out: float, cos_twist_out: float) -> Tuple[bool, float, float]: ...
    @overload
    @staticmethod
    def RulingMinTwist(rail0: NurbsCurve, t0: float, dom0: Interval, rail1: NurbsCurve, t1: float, dom1: Interval, t0_out: float, t1_out: float, cos_twist_out: float) -> Tuple[bool, float, float, float]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    @staticmethod
    def UntwistRulings(rail0: NurbsCurve, rail1: NurbsCurve, rulings: Iterable[Any]) -> Tuple[bool, Iterable[Any]]: ...


from ..DocObjects import ViewportInfo
from ..DocObjects import DimensionStyle
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ArrowType
from ..DocObjects import ZeroSuppression
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Dimension(AnnotationBase):
    @overload
    def ClearPropertyOverrides(self) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Explode(self) -> Iterable[GeometryBase]: ...
    @overload
    @property
    def AlternateBelowLine(self) -> bool: ...
    @overload
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def AltLengthFactor(self) -> float: ...
    @overload
    @property
    def AltLengthResolution(self) -> int: ...
    @overload
    @property
    def AltLengthRoundoff(self) -> float: ...
    @overload
    @property
    def AltPrefix(self) -> str: ...
    @overload
    @property
    def AltSuffix(self) -> str: ...
    @overload
    @property
    def AltToleranceResolution(self) -> int: ...
    @overload
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @overload
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @overload
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @overload
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @overload
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @overload
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @overload
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @overload
    @property
    def ArrowSize(self) -> float: ...
    @overload
    @property
    def BaselineSpacing(self) -> float: ...
    @overload
    @property
    def CentermarkSize(self) -> float: ...
    @overload
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @overload
    @property
    def DecimalSeparator(self) -> Char: ...
    @overload
    @property
    def DetailMeasured(self) -> Guid: ...
    @overload
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def DimensionLineExtension(self) -> float: ...
    @overload
    @property
    def DimensionScale(self) -> float: ...
    @overload
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def DimensionStyleId(self) -> Guid: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def DistanceScale(self) -> float: ...
    @overload
    @property
    def DrawForward(self) -> bool: ...
    @overload
    @property
    def DrawTextFrame(self) -> bool: ...
    @overload
    @property
    def ExtensionLineExtension(self) -> float: ...
    @overload
    @property
    def ExtensionLineOffset(self) -> float: ...
    @overload
    @property
    def FirstCharFont(self) -> Font: ...
    @overload
    @property
    def FixedExtensionLength(self) -> float: ...
    @overload
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @overload
    @property
    def Font(self) -> Font: ...
    @overload
    @property
    def FontIndex(self) -> int: ...
    @overload
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @overload
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @overload
    @property
    def ForceDimLine(self) -> bool: ...
    @overload
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @overload
    @property
    def FormatWidth(self) -> float: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def LengthFactor(self) -> float: ...
    @overload
    @property
    def LengthResolution(self) -> int: ...
    @overload
    @property
    def LengthRoundoff(self) -> float: ...
    @overload
    @property
    def MaskColor(self) -> Color: ...
    @overload
    @property
    def MaskColorSource(self) -> MaskType: ...
    @overload
    @property
    def MaskEnabled(self) -> bool: ...
    @overload
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @overload
    @property
    def MaskOffset(self) -> float: ...
    @overload
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @overload
    @property
    def NumericValue(self) -> float: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def PlainText(self) -> str: ...
    @overload
    @property
    def PlainTextWithFields(self) -> str: ...
    @overload
    @property
    def PlainUserText(self) -> str: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Prefix(self) -> str: ...
    @overload
    @property
    def RichText(self) -> str: ...
    @overload
    @property
    def Suffix(self) -> str: ...
    @overload
    @property
    def SuppressExtension1(self) -> bool: ...
    @overload
    @property
    def SuppressExtension2(self) -> bool: ...
    @overload
    @property
    def Text(self) -> str: ...
    @overload
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @overload
    @property
    def TextFit(self) -> TextFit: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @overload
    @property
    def TextHeight(self) -> float: ...
    @overload
    @property
    def TextIsWrapped(self) -> bool: ...
    @overload
    @property
    def TextLocation(self) -> TextLocation: ...
    @overload
    @property
    def TextModelWidth(self) -> float: ...
    @overload
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @overload
    @property
    def TextPosition(self) -> Point2d: ...
    @overload
    @property
    def TextRotation(self) -> float: ...
    @overload
    @property
    def TextRotationDegrees(self) -> float: ...
    @overload
    @property
    def TextRotationRadians(self) -> float: ...
    @overload
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @overload
    @property
    def ToleranceHeightScale(self) -> float: ...
    @overload
    @property
    def ToleranceLowerValue(self) -> float: ...
    @overload
    @property
    def ToleranceResolution(self) -> int: ...
    @overload
    @property
    def ToleranceUpperValue(self) -> float: ...
    @overload
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    @overload
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsAllBold(self) -> bool: ...
    @overload
    def IsAllItalic(self) -> bool: ...
    @overload
    def IsAllUnderlined(self) -> bool: ...
    @overload
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @AlternateBelowLine.setter
    def AlternateBelowLine(self, value: bool) -> None: ...
    @overload
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @AltLengthFactor.setter
    def AltLengthFactor(self, value: float) -> None: ...
    @overload
    @AltLengthResolution.setter
    def AltLengthResolution(self, value: int) -> None: ...
    @overload
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self, value: float) -> None: ...
    @overload
    @AltPrefix.setter
    def AltPrefix(self, value: str) -> None: ...
    @overload
    @AltSuffix.setter
    def AltSuffix(self, value: str) -> None: ...
    @overload
    @AltToleranceResolution.setter
    def AltToleranceResolution(self, value: int) -> None: ...
    @overload
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self, value: bool) -> None: ...
    @overload
    @AltZeroSuppression.setter
    def AltZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    @ArrowBlockId1.setter
    def ArrowBlockId1(self, value: Guid) -> None: ...
    @overload
    @ArrowBlockId2.setter
    def ArrowBlockId2(self, value: Guid) -> None: ...
    @overload
    @ArrowFit.setter
    def ArrowFit(self, value: ArrowFit) -> None: ...
    @overload
    @ArrowheadType1.setter
    def ArrowheadType1(self, value: ArrowType) -> None: ...
    @overload
    @ArrowheadType2.setter
    def ArrowheadType2(self, value: ArrowType) -> None: ...
    @overload
    @ArrowSize.setter
    def ArrowSize(self, value: float) -> None: ...
    @overload
    @BaselineSpacing.setter
    def BaselineSpacing(self, value: float) -> None: ...
    @overload
    @CentermarkSize.setter
    def CentermarkSize(self, value: float) -> None: ...
    @overload
    @CentermarkStyle.setter
    def CentermarkStyle(self, value: CenterMarkStyle) -> None: ...
    @overload
    @DecimalSeparator.setter
    def DecimalSeparator(self, value: Char) -> None: ...
    @overload
    @DetailMeasured.setter
    def DetailMeasured(self, value: Guid) -> None: ...
    @overload
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DimensionLineExtension.setter
    def DimensionLineExtension(self, value: float) -> None: ...
    @overload
    @DimensionScale.setter
    def DimensionScale(self, value: float) -> None: ...
    @overload
    @DimensionStyleId.setter
    def DimensionStyleId(self, value: Guid) -> None: ...
    @overload
    @DistanceScale.setter
    def DistanceScale(self, value: float) -> None: ...
    @overload
    @DrawForward.setter
    def DrawForward(self, value: bool) -> None: ...
    @overload
    @DrawTextFrame.setter
    def DrawTextFrame(self, value: bool) -> None: ...
    @overload
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self, value: float) -> None: ...
    @overload
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self, value: float) -> None: ...
    @overload
    @FixedExtensionLength.setter
    def FixedExtensionLength(self, value: float) -> None: ...
    @overload
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self, value: bool) -> None: ...
    @overload
    @Font.setter
    def Font(self, value: Font) -> None: ...
    @overload
    @FontIndex.setter
    def FontIndex(self, value: int) -> None: ...
    @overload
    @ForceArrowPosition.setter
    def ForceArrowPosition(self, value: ForceArrow) -> None: ...
    @overload
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self, value: bool) -> None: ...
    @overload
    @ForceDimLine.setter
    def ForceDimLine(self, value: bool) -> None: ...
    @overload
    @ForceTextPosition.setter
    def ForceTextPosition(self, value: ForceText) -> None: ...
    @overload
    @FormatWidth.setter
    def FormatWidth(self, value: float) -> None: ...
    @overload
    @LengthFactor.setter
    def LengthFactor(self, value: float) -> None: ...
    @overload
    @LengthResolution.setter
    def LengthResolution(self, value: int) -> None: ...
    @overload
    @LengthRoundoff.setter
    def LengthRoundoff(self, value: float) -> None: ...
    @overload
    @MaskColor.setter
    def MaskColor(self, value: Color) -> None: ...
    @overload
    @MaskColorSource.setter
    def MaskColorSource(self, value: MaskType) -> None: ...
    @overload
    @MaskEnabled.setter
    def MaskEnabled(self, value: bool) -> None: ...
    @overload
    @MaskFrame.setter
    def MaskFrame(self, value: MaskFrame) -> None: ...
    @overload
    @MaskOffset.setter
    def MaskOffset(self, value: float) -> None: ...
    @overload
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self, value: bool) -> None: ...
    @overload
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self, value: DimensionStyle) -> None: ...
    @overload
    @PlainText.setter
    def PlainText(self, value: str) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @Prefix.setter
    def Prefix(self, value: str) -> None: ...
    @overload
    @RichText.setter
    def RichText(self, value: str) -> None: ...
    @overload
    @Suffix.setter
    def Suffix(self, value: str) -> None: ...
    @overload
    @SuppressExtension1.setter
    def SuppressExtension1(self, value: bool) -> None: ...
    @overload
    @SuppressExtension2.setter
    def SuppressExtension2(self, value: bool) -> None: ...
    @overload
    @Text.setter
    def Text(self, value: str) -> None: ...
    @overload
    @TextAngleType.setter
    def TextAngleType(self, value: LeaderContentAngleStyle) -> None: ...
    @overload
    @TextFit.setter
    def TextFit(self, value: TextFit) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextHeight.setter
    def TextHeight(self, value: float) -> None: ...
    @overload
    @TextIsWrapped.setter
    def TextIsWrapped(self, value: bool) -> None: ...
    @overload
    @TextLocation.setter
    def TextLocation(self, value: TextLocation) -> None: ...
    @overload
    @TextOrientation.setter
    def TextOrientation(self, value: TextOrientation) -> None: ...
    @overload
    @TextPosition.setter
    def TextPosition(self, value: Point2d) -> None: ...
    @overload
    @TextRotation.setter
    def TextRotation(self, value: float) -> None: ...
    @overload
    @TextRotationDegrees.setter
    def TextRotationDegrees(self, value: float) -> None: ...
    @overload
    @TextRotationRadians.setter
    def TextRotationRadians(self, value: float) -> None: ...
    @overload
    @ToleranceFormat.setter
    def ToleranceFormat(self, value: ToleranceDisplayFormat) -> None: ...
    @overload
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self, value: float) -> None: ...
    @overload
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self, value: float) -> None: ...
    @overload
    @ToleranceResolution.setter
    def ToleranceResolution(self, value: int) -> None: ...
    @overload
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self, value: float) -> None: ...
    @overload
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self, value: bool) -> None: ...
    @overload
    @ZeroSuppression.setter
    def ZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetBold(self, set_on: bool) -> bool: ...
    @overload
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    @overload
    def SetItalic(self, set_on: bool) -> bool: ...
    @overload
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    @overload
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    @overload
    def SetUnderline(self, set_on: bool) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    @overload
    def WrapText(self) -> None: ...


class DistancingMode(Enum):
    Undefined = 0
    Linear = 1
    LinearFromEnd = 2
    Ratio = 3
    RatioFromEnd = 4


class EdgeAdjacency(Enum):
    # None = 0
    Naked = 1
    Interior = 2
    NonManifold = 3


class Ellipse:
    @overload
    def __init__(self, plane: Plane, radius1: float, radius2: float): ...
    @overload
    def __init__(self, center: Point3d, second: Point3d, third: Point3d): ...
    @overload
    def EpsilonEquals(self, other: Ellipse, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Center(self) -> Point3d: ...
    @overload
    @property
    def FocalDistance(self) -> float: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Radius1(self) -> float: ...
    @overload
    @property
    def Radius2(self) -> float: ...
    @overload
    def GetFoci(self) -> Tuple[Point3d, Point3d]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @Center.setter
    def Center(self, value: Point3d) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @Radius1.setter
    def Radius1(self, value: float) -> None: ...
    @overload
    @Radius2.setter
    def Radius2(self, value: float) -> None: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToString(self) -> str: ...


class ExtraordinaryVertexProcessOption(Enum):
    # None = 0
    LocalG1 = 1
    LocalG2 = 2
    LocalG1x = 3
    LocalG1xx = 4


class ExtrudeCornerType(Enum):
    # None = 0
    Sharp = 1
    Round = 2
    Smooth = 3
    Chamfer = 4


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Extrusion(Surface):
    @overload
    def __init__(self): ...
    @overload
    def AddInnerProfile(self, innerProfile: Curve) -> bool: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(planarCurve: Curve, height: float, cap: bool) -> Extrusion: ...
    @overload
    @staticmethod
    def Create(curve: Curve, plane: Plane, height: float, cap: bool) -> Extrusion: ...
    @overload
    @staticmethod
    def CreateBoxExtrusion(box: Box, cap: bool) -> Extrusion: ...
    @overload
    @staticmethod
    def CreateCylinderExtrusion(cylinder: Cylinder, capBottom: bool, capTop: bool) -> Extrusion: ...
    @overload
    @staticmethod
    def CreatePipeExtrusion(cylinder: Cylinder, otherRadius: float, capTop: bool, capBottom: bool) -> Extrusion: ...
    @overload
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def Degree(self, direction: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    @overload
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    @overload
    def FitCurveToSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], divideIntoSections: bool, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[Iterable[Curve], Curve, Curve]: ...
    @overload
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def CapCount(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsCappedAtBottom(self) -> bool: ...
    @overload
    @property
    def IsCappedAtTop(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsMiteredAtEnd(self) -> bool: ...
    @overload
    @property
    def IsMiteredAtStart(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def MiterPlaneNormalAtEnd(self) -> Vector3d: ...
    @overload
    @property
    def MiterPlaneNormalAtStart(self) -> Vector3d: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PathEnd(self) -> Point3d: ...
    @overload
    @property
    def PathStart(self) -> Point3d: ...
    @overload
    @property
    def PathTangent(self) -> Vector3d: ...
    @overload
    @property
    def ProfileCount(self) -> int: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetBrepFormComponentIndex(self, extrusionComponentIndex: ComponentIndex) -> ComponentIndex: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetMesh(self, meshType: MeshType) -> Mesh: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPathPlane(self, s: float) -> Plane: ...
    @overload
    def GetProfilePlane(self, s: float) -> Plane: ...
    @overload
    def GetProfileTransformation(self, s: float) -> Transform: ...
    @overload
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    @overload
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def GetWireframe(self) -> Iterable[Curve]: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    @overload
    def IsAtSeam(self, u: float, v: float) -> int: ...
    @overload
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    @overload
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    @overload
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    @overload
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    @overload
    def PathLineCurve(self) -> LineCurve: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Profile3d(self, ci: ComponentIndex) -> Curve: ...
    @overload
    def Profile3d(self, profileIndex: int, s: float) -> Curve: ...
    @overload
    def ProfileIndex(self, profileParameter: float) -> int: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    @overload
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def RefitSimplySplitSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, knotAdditionMode: RefitTrimKnotMode, numInsertKnots: int, Knots: Iterable[float], sectionMode: RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Point3d, outputSurface: bool, outputCurve: bool, numSections: int, lowerSurface: List, upperSurface: List, edgeCurve: List, FitMeasurement: float, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[bool, int, float, Curve, Curve]: ...
    @overload
    def RefitSplit(self, curve: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], bMeetCurve: bool, divideIntoSections: bool, srfLower: List, srfUpper: List, edgeCurve: List, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[int, Curve, Curve]: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @MiterPlaneNormalAtEnd.setter
    def MiterPlaneNormalAtEnd(self, value: Vector3d) -> None: ...
    @overload
    @MiterPlaneNormalAtStart.setter
    def MiterPlaneNormalAtStart(self, value: Vector3d) -> None: ...
    @overload
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    @overload
    def SetMesh(self, mesh: Mesh, meshType: MeshType) -> bool: ...
    @overload
    def SetOuterProfile(self, outerProfile: Curve, cap: bool) -> bool: ...
    @overload
    def SetPathAndUp(self, a: Point3d, b: Point3d, up: Vector3d) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    @overload
    def SpanCount(self, direction: int) -> int: ...
    @overload
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToBrep(self, splitKinkyFaces: bool) -> Brep: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    @overload
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...
    @overload
    def WallEdge(self, ci: ComponentIndex) -> Curve: ...
    @overload
    def WallSurface(self, ci: ComponentIndex) -> Surface: ...


class FilletSurfaceSplitType(Enum):
    Nothing = 0
    Trim = 1
    Split = 2


class ForceArrow(Enum):
    Auto = 0
    Inside = 1
    Outside = 2


class ForceText(Enum):
    Auto = 0
    Inside = 1
    Right = 2
    Left = 3
    HintRight = 4
    HintLeft = 5


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
from ..Runtime import CommonObject
class GeometryBase(CommonObject):
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @staticmethod
    def GeometryEquals(first: GeometryBase, second: GeometryBase) -> bool: ...
    @overload
    @staticmethod
    def GeometryReferenceEquals(one: GeometryBase, other: GeometryBase) -> bool: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


from ..DocObjects import HatchPattern
from ..Display import ColorGradient
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Hatch(GeometryBase):
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(curves: Iterable[Curve], hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> Iterable[Hatch]: ...
    @overload
    @staticmethod
    def Create(curve: Curve, hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> Iterable[Hatch]: ...
    @overload
    @staticmethod
    def Create(hatchPlane: Plane, outerLoop: Curve, innerLoops: Iterable[Curve], hatchPatternIndex: int, rotationRadians: float, scale: float) -> Hatch: ...
    @overload
    def CreateDisplayGeometry(self, pattern: HatchPattern, patternScale: float) -> Tuple[Iterable[Curve], Iterable[Line], Brep]: ...
    @overload
    @staticmethod
    def CreateFromBrep(brep: Brep, brepFaceIndex: int, hatchPatternIndex: int, rotationRadians: float, scale: float, basePoint: Point3d) -> Hatch: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Explode(self) -> Iterable[GeometryBase]: ...
    @overload
    @property
    def BasePoint(self) -> Point3d: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PatternIndex(self) -> int: ...
    @overload
    @property
    def PatternRotation(self) -> float: ...
    @overload
    @property
    def PatternScale(self) -> float: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def Get2dCurves(self, outer: bool) -> Iterable[Curve]: ...
    @overload
    def Get3dCurves(self, outer: bool) -> Iterable[Curve]: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetGradientFill(self) -> ColorGradient: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def ScalePattern(self, xform: Transform) -> None: ...
    @overload
    @BasePoint.setter
    def BasePoint(self, value: Point3d) -> None: ...
    @overload
    @PatternIndex.setter
    def PatternIndex(self, value: int) -> None: ...
    @overload
    @PatternRotation.setter
    def PatternRotation(self, value: float) -> None: ...
    @overload
    @PatternScale.setter
    def PatternScale(self, value: float) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    def SetGradientFill(self, fill: ColorGradient) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class HermiteSurface:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, uCount: int, vCount: int): ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def UCount(self) -> int: ...
    @overload
    @property
    def VCount(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def PointAt(self, uIndex: int, vIndex: int) -> Point3d: ...
    @overload
    def SetPointAt(self, uIndex: int, vIndex: int, point: Point3d) -> None: ...
    @overload
    def SetTwistAt(self, uIndex: int, vIndex: int, twist: Vector3d) -> None: ...
    @overload
    def SetUParameterAt(self, index: int, parameter: float) -> None: ...
    @overload
    def SetUTangentAt(self, uIndex: int, vIndex: int, tangent: Vector3d) -> None: ...
    @overload
    def SetVParameterAt(self, index: int, parameter: float) -> None: ...
    @overload
    def SetVTangentAt(self, uIndex: int, vIndex: int, tangent: Vector3d) -> None: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def TwistAt(self, uIndex: int, vIndex: int) -> Vector3d: ...
    @overload
    def UParameterAt(self, index: int) -> float: ...
    @overload
    def UTangentAt(self, uIndex: int, vIndex: int) -> Vector3d: ...
    @overload
    def VParameterAt(self, index: int) -> float: ...
    @overload
    def VTangentAt(self, uIndex: int, vIndex: int) -> Vector3d: ...


from ..DocObjects import ViewportInfo
class HiddenLineDrawing:
    @overload
    def BoundingBox(self, includeHidden: bool) -> BoundingBox: ...
    @overload
    @staticmethod
    def Compute(parameters: HiddenLineDrawingParameters, multipleThreads: bool) -> HiddenLineDrawing: ...
    @overload
    @staticmethod
    def Compute(parameters: HiddenLineDrawingParameters, multipleThreads: bool, progress: IProgress, cancelToken: CancellationToken) -> HiddenLineDrawing: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Points(self) -> Iterable[HiddenLineDrawingPoint]: ...
    @overload
    @property
    def Segments(self) -> Iterable[HiddenLineDrawingSegment]: ...
    @overload
    @property
    def Viewport(self) -> ViewportInfo: ...
    @overload
    @property
    def WorldToHiddenLine(self) -> Transform: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def RejoinCompatibleVisible(self) -> None: ...
    @overload
    def ToString(self) -> str: ...


class HiddenLineDrawingObject:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Geometry(self) -> GeometryBase: ...
    @overload
    @property
    def OccludingSections(self) -> bool: ...
    @overload
    @property
    def Tag(self) -> object: ...
    @overload
    @property
    def Transform(self) -> Transform: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @OccludingSections.setter
    def OccludingSections(self, value: bool) -> None: ...
    @overload
    def ToString(self) -> str: ...


class HiddenLineDrawingObjectCurve:
    @overload
    def Curve(self, t: float) -> HiddenLineDrawingSegment: ...
    @overload
    def Curve(self, t: float, side: int) -> HiddenLineDrawingSegment: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ClippingPlaneIndex(self) -> int: ...
    @overload
    @property
    def Index(self) -> int: ...
    @overload
    @property
    def IsProjecting(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def OriginalDomainStart(self) -> float: ...
    @overload
    @property
    def Parameters(self) -> Iterable[float]: ...
    @overload
    @property
    def Segments(self) -> Iterable[HiddenLineDrawingSegment]: ...
    @overload
    @property
    def SilhouetteType(self) -> SilhouetteType: ...
    @overload
    @property
    def SourceObject(self) -> HiddenLineDrawingObject: ...
    @overload
    @property
    def SourceObjectComponentIndex(self) -> ComponentIndex: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


from ..DocObjects import ViewportInfo
from ..Display import RhinoViewport
class HiddenLineDrawingParameters:
    @overload
    def __init__(self): ...
    @overload
    def AddClippingPlane(self, plane: Plane) -> None: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, tag: object) -> bool: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, xform: Transform, tag: object) -> bool: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, tag: object, occluding_sections: bool) -> bool: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, xform: Transform, tag: object, occluding_sections: bool) -> bool: ...
    @overload
    def AddGeometryAndPlanes(self, geometry: GeometryBase, tag: object, clips: List) -> bool: ...
    @overload
    def AddGeometryAndPlanes(self, geometry: GeometryBase, xform: Transform, tag: object, clips: List) -> bool: ...
    @overload
    def AddGeometryAndPlanes(self, geometry: GeometryBase, tag: object, occluding_sections: bool, clips: List) -> bool: ...
    @overload
    def AddGeometryAndPlanes(self, geometry: GeometryBase, xform: Transform, tag: object, occluding_sections: bool, clips: List) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def AbsoluteTolerance(self) -> float: ...
    @overload
    @property
    def Flatten(self) -> bool: ...
    @overload
    @property
    def IncludeHiddenCurves(self) -> bool: ...
    @overload
    @property
    def IncludeTangentEdges(self) -> bool: ...
    @overload
    @property
    def IncludeTangentSeams(self) -> bool: ...
    @overload
    @property
    def OccludingSectionOption(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, value: float) -> None: ...
    @overload
    @Flatten.setter
    def Flatten(self, value: bool) -> None: ...
    @overload
    @IncludeHiddenCurves.setter
    def IncludeHiddenCurves(self, value: bool) -> None: ...
    @overload
    @IncludeTangentEdges.setter
    def IncludeTangentEdges(self, value: bool) -> None: ...
    @overload
    @IncludeTangentSeams.setter
    def IncludeTangentSeams(self, value: bool) -> None: ...
    @overload
    @OccludingSectionOption.setter
    def OccludingSectionOption(self, value: bool) -> None: ...
    @overload
    def SetViewport(self, viewport: RhinoViewport) -> None: ...
    @overload
    def SetViewport(self, viewport: ViewportInfo) -> None: ...
    @overload
    def ToString(self) -> str: ...


class HiddenLineDrawingPoint:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ClippingPlaneIndex(self) -> int: ...
    @overload
    @property
    def Index(self) -> int: ...
    @overload
    @property
    def Location(self) -> Point3d: ...
    @overload
    @property
    def PointVisibility(self) -> Visibility: ...
    @overload
    @property
    def SourceObject(self) -> HiddenLineDrawingObject: ...
    @overload
    @property
    def SourceObjectComponentIndex(self) -> ComponentIndex: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class HiddenLineDrawingSegment:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def CurveGeometry(self) -> Curve: ...
    @overload
    @property
    def CurveSideFills(self) -> Iterable[SideFill]: ...
    @overload
    @property
    def Index(self) -> int: ...
    @overload
    @property
    def IsSceneSilhouette(self) -> bool: ...
    @overload
    @property
    def ParentCurve(self) -> HiddenLineDrawingObjectCurve: ...
    @overload
    @property
    def SegmentVisibility(self) -> Visibility: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


from ..DocObjects import ModelComponentType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
from ..DocObjects import ModelComponent
class InstanceDefinitionGeometry(ModelComponent):
    @overload
    def __init__(self): ...
    @overload
    def ClearId(self) -> None: ...
    @overload
    def ClearIndex(self) -> None: ...
    @overload
    def ClearName(self) -> None: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ComponentStatus(self) -> ComponentStatus: ...
    @overload
    @property
    def ComponentType(self) -> ModelComponentType: ...
    @overload
    @property
    def DeletedName(self) -> str: ...
    @overload
    @property
    def Description(self) -> str: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasId(self) -> bool: ...
    @overload
    @property
    def HasIndex(self) -> bool: ...
    @overload
    @property
    def HasName(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def Id(self) -> Guid: ...
    @overload
    @property
    def IdIsLocked(self) -> bool: ...
    @overload
    @property
    def Index(self) -> int: ...
    @overload
    @property
    def IndexIsLocked(self) -> bool: ...
    @overload
    @property
    def InstanceDefinitionModelSerialNumber(self) -> int: ...
    @overload
    @property
    def IsComponentStatusLocked(self) -> bool: ...
    @overload
    @property
    def IsDeleted(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsReference(self) -> bool: ...
    @overload
    @property
    def IsSystemComponent(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ModelSerialNumber(self) -> int: ...
    @overload
    @property
    def Name(self) -> str: ...
    @overload
    @property
    def NameIsLocked(self) -> bool: ...
    @overload
    @property
    def ReferenceModelSerialNumber(self) -> int: ...
    @overload
    @property
    def SourceArchive(self) -> str: ...
    @overload
    @property
    def Url(self) -> str: ...
    @overload
    @property
    def UrlDescription(self) -> str: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetObjectIds(self) -> Iterable[Guid]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LockId(self) -> None: ...
    @overload
    def LockIndex(self) -> None: ...
    @overload
    def LockName(self) -> None: ...
    @overload
    @ComponentStatus.setter
    def ComponentStatus(self, value: ComponentStatus) -> None: ...
    @overload
    @Description.setter
    def Description(self, value: str) -> None: ...
    @overload
    @Id.setter
    def Id(self, value: Guid) -> None: ...
    @overload
    @Index.setter
    def Index(self, value: int) -> None: ...
    @overload
    @Name.setter
    def Name(self, value: str) -> None: ...
    @overload
    @Url.setter
    def Url(self, value: str) -> None: ...
    @overload
    @UrlDescription.setter
    def UrlDescription(self, value: str) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class InstanceReferenceGeometry(GeometryBase):
    @overload
    def __init__(self, instanceDefinitionId: Guid, transform: Transform): ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ParentIdefId(self) -> Guid: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def Xform(self) -> Transform: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class InteriorCreaseOption(Enum):
    Unset = 0
    # None = 1
    AtMeshDoubleEdge = 2


from ..Collections import RhinoList
class Interpolator:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initialCapacity: int): ...
    @overload
    def __init__(self, list: RhinoList): ...
    @overload
    def __init__(self, collection: Iterable[float]): ...
    @overload
    def __init__(self, amount: int, defaultValue: float): ...
    def __iter__(self) -> Iterator[float]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float): ...
    @overload
    def Add(self, item: float) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[float]) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[Any]) -> None: ...
    @overload
    def AsReadOnly(self) -> ReadOnlyCollection: ...
    @overload
    def BinarySearch(self, item: float) -> int: ...
    @overload
    def BinarySearch(self, item: float, comparer: IComparer) -> int: ...
    @overload
    def BinarySearch(self, index: int, count: int, item: float, comparer: IComparer) -> int: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def Contains(self, item: float) -> bool: ...
    @overload
    def ConvertAll(self, converter: Converter) -> RhinoList: ...
    @overload
    def CopyTo(self, array: Iterable[float]) -> None: ...
    @overload
    def CopyTo(self, array: Iterable[float], arrayIndex: int) -> None: ...
    @overload
    def CopyTo(self, index: int, array: Iterable[float], arrayIndex: int, count: int) -> None: ...
    @overload
    def Duplicate(self) -> RhinoList: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Exists(self, match: Predicate) -> bool: ...
    @overload
    def Find(self, match: Predicate) -> float: ...
    @overload
    def FindAll(self, match: Predicate) -> RhinoList: ...
    @overload
    def FindIndex(self, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def FindLast(self, match: Predicate) -> float: ...
    @overload
    def FindLastIndex(self, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def ForEach(self, action: Action) -> None: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Cyclical(self) -> bool: ...
    @overload
    @property
    def First(self) -> float: ...
    @overload
    @overload
    @property
    def Last(self) -> float: ...
    @overload
    @property
    def NullCount(self) -> int: ...
    @overload
    def GetEnumerator(self) -> Iterator[float]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetRange(self, index: int, count: int) -> RhinoList: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IndexOf(self, item: float) -> int: ...
    @overload
    def IndexOf(self, item: float, index: int) -> int: ...
    @overload
    def IndexOf(self, item: float, index: int, count: int) -> int: ...
    @overload
    def Insert(self, index: int, item: float) -> None: ...
    @overload
    def InsertRange(self, index: int, collection: Iterable[float]) -> None: ...
    @overload
    def InterpolateCatmullRom(self, t: float) -> float: ...
    @overload
    def InterpolateCosine(self, t: float) -> float: ...
    @overload
    def InterpolateCubic(self, t: float) -> float: ...
    @overload
    def InterpolateLinear(self, t: float) -> float: ...
    @overload
    def InterpolateNearestNeighbour(self, t: float) -> float: ...
    @overload
    def LastIndexOf(self, item: float) -> int: ...
    @overload
    def LastIndexOf(self, item: float, index: int) -> int: ...
    @overload
    def LastIndexOf(self, item: float, index: int, count: int) -> int: ...
    @overload
    def RemapIndex(self, index: int) -> int: ...
    @overload
    def Remove(self, item: float) -> bool: ...
    @overload
    def RemoveAll(self, match: Predicate) -> int: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RemoveNulls(self) -> int: ...
    @overload
    def RemoveRange(self, index: int, count: int) -> None: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    def Reverse(self, index: int, count: int) -> None: ...
    @overload
    @Capacity.setter
    def Capacity(self, value: int) -> None: ...
    @overload
    @Cyclical.setter
    def Cyclical(self, value: bool) -> None: ...
    @overload
    @First.setter
    def First(self, value: float) -> None: ...
    @overload
    @property
    def Item(self) -> MutableSequence[float]: ...
    @overload
    @Last.setter
    def Last(self, value: float) -> None: ...
    @overload
    def Sort(self) -> None: ...
    @overload
    def Sort(self, keys: Iterable[float]) -> None: ...
    @overload
    def Sort(self, keys: Iterable[int]) -> None: ...
    @overload
    def Sort(self, comparer: IComparer) -> None: ...
    @overload
    def Sort(self, comparison: Comparison) -> None: ...
    @overload
    def Sort(self, index: int, count: int, comparer: IComparer) -> None: ...
    @overload
    def ToArray(self) -> Iterable[float]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def TrimExcess(self) -> None: ...
    @overload
    def TrueForAll(self, match: Predicate) -> bool: ...


class Interval:
    @overload
    def __init__(self, other: Interval): ...
    @overload
    def __init__(self, t0: float, t1: float): ...
    @overload
    def CompareTo(self, other: Interval) -> int: ...
    @overload
    def EpsilonEquals(self, other: Interval, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: Interval) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @staticmethod
    def FromIntersection(a: Interval, b: Interval) -> Interval: ...
    @overload
    @staticmethod
    def FromUnion(a: Interval, b: Interval) -> Interval: ...
    @overload
    @property
    def IsDecreasing(self) -> bool: ...
    @overload
    @property
    def IsIncreasing(self) -> bool: ...
    @overload
    @property
    def IsSingleton(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @overload
    @property
    def Length(self) -> float: ...
    @overload
    @property
    def Max(self) -> float: ...
    @overload
    @property
    def Mid(self) -> float: ...
    @overload
    @property
    def Min(self) -> float: ...
    @overload
    @property
    def T0(self) -> float: ...
    @overload
    @property
    def T1(self) -> float: ...
    @overload
    @property
    def Unset() -> Interval: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Grow(self, value: float) -> None: ...
    @overload
    def IncludesInterval(self, interval: Interval) -> bool: ...
    @overload
    def IncludesInterval(self, interval: Interval, strict: bool) -> bool: ...
    @overload
    def IncludesParameter(self, t: float) -> bool: ...
    @overload
    def IncludesParameter(self, t: float, strict: bool) -> bool: ...
    @overload
    def MakeIncreasing(self) -> None: ...
    @overload
    def NormalizedIntervalAt(self, intervalParameter: Interval) -> Interval: ...
    @overload
    def NormalizedParameterAt(self, intervalParameter: float) -> float: ...
    @overload
    def __add__(interval: Interval, number: float) -> Interval: ...
    @overload
    def __radd__(interval: Interval, number: float) -> Interval: ...
    @overload
    def __eq__(a: Interval, b: Interval) -> bool: ...
    @overload
    def __gt__(a: Interval, b: Interval) -> bool: ...
    @overload
    def __ge__(a: Interval, b: Interval) -> bool: ...
    @overload
    def __ne__(a: Interval, b: Interval) -> bool: ...
    @overload
    def __lt__(a: Interval, b: Interval) -> bool: ...
    @overload
    def __le__(a: Interval, b: Interval) -> bool: ...
    @overload
    def __sub__(interval: Interval, number: float) -> Interval: ...
    @overload
    def __rsub__(interval: Interval, number: float) -> Interval: ...
    @overload
    def ParameterAt(self, normalizedParameter: float) -> float: ...
    @overload
    def ParameterIntervalAt(self, normalizedInterval: Interval) -> Interval: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    @property
    def Item(self) -> MutableSequence[float]: ...
    @overload
    @T0.setter
    def T0(self, value: float) -> None: ...
    @overload
    @T1.setter
    def T1(self, value: float) -> None: ...
    @overload
    def Swap(self) -> None: ...
    @overload
    def ToString(self) -> str: ...


class InvalidDimensionStyleIdException:
    @overload
    def __init__(self, msg: str): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Data(self) -> IDictionary: ...
    @overload
    @property
    def HelpLink(self) -> str: ...
    @overload
    @property
    def HResult(self) -> int: ...
    @overload
    @property
    def InnerException(self) -> Exception: ...
    @overload
    @property
    def Message(self) -> str: ...
    @overload
    @property
    def Source(self) -> str: ...
    @overload
    @property
    def StackTrace(self) -> str: ...
    @overload
    @property
    def TargetSite(self) -> MethodBase: ...
    @overload
    def GetBaseException(self) -> Exception: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @HelpLink.setter
    def HelpLink(self, value: str) -> None: ...
    @overload
    @Source.setter
    def Source(self, value: str) -> None: ...
    @overload
    def ToString(self) -> str: ...


class IsoStatus(Enum):
    # None = 0
    X = 1
    Y = 2
    West = 3
    South = 4
    East = 5
    North = 6


class KnotStyle(Enum):
    Unknown = 0
    Uniform = 1
    QuasiUniform = 2
    PiecewiseBezier = 3
    ClampedEnd = 4
    NonUniform = 5


from ..DocObjects import DimensionStyle
from ..DocObjects import TextHorizontalAlignment
from ..DocObjects import TextVerticalAlignment
from ..DocObjects import ArrowType
from ..DocObjects import LeaderCurveStyle
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import LengthDisplay
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Leader(AnnotationBase):
    @overload
    def __init__(self): ...
    @overload
    def ClearPropertyOverrides(self) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(text: str, plane: Plane, dimstyle: DimensionStyle, points: Iterable[Point3d]) -> Leader: ...
    @overload
    @staticmethod
    def CreateWithRichText(richText: str, plane: Plane, dimstyle: DimensionStyle, points: Iterable[Point3d]) -> Leader: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Explode(self) -> Iterable[GeometryBase]: ...
    @overload
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @overload
    @property
    def Curve(self) -> NurbsCurve: ...
    @overload
    @property
    def DecimalSeparator(self) -> Char: ...
    @overload
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def DimensionScale(self) -> float: ...
    @overload
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def DimensionStyleId(self) -> Guid: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def DrawForward(self) -> bool: ...
    @overload
    @property
    def DrawTextFrame(self) -> bool: ...
    @overload
    @property
    def FirstCharFont(self) -> Font: ...
    @overload
    @property
    def Font(self) -> Font: ...
    @overload
    @property
    def FontIndex(self) -> int: ...
    @overload
    @property
    def FormatWidth(self) -> float: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def LeaderArrowBlockId(self) -> Guid: ...
    @overload
    @property
    def LeaderArrowSize(self) -> float: ...
    @overload
    @property
    def LeaderArrowType(self) -> ArrowType: ...
    @overload
    @property
    def LeaderContentAngleStyle(self) -> LeaderContentAngleStyle: ...
    @overload
    @property
    def LeaderCurveStyle(self) -> LeaderCurveStyle: ...
    @overload
    @property
    def LeaderHasLanding(self) -> bool: ...
    @overload
    @property
    def LeaderLandingLength(self) -> float: ...
    @overload
    @property
    def LeaderTextHorizontalAlignment(self) -> TextHorizontalAlignment: ...
    @overload
    @property
    def LeaderTextVerticalAlignment(self) -> TextVerticalAlignment: ...
    @overload
    @property
    def MaskColor(self) -> Color: ...
    @overload
    @property
    def MaskColorSource(self) -> MaskType: ...
    @overload
    @property
    def MaskEnabled(self) -> bool: ...
    @overload
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @overload
    @property
    def MaskOffset(self) -> float: ...
    @overload
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def PlainText(self) -> str: ...
    @overload
    @property
    def PlainTextWithFields(self) -> str: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Points2D(self) -> Iterable[Point2d]: ...
    @overload
    @property
    def Points3D(self) -> Iterable[Point3d]: ...
    @overload
    @property
    def RichText(self) -> str: ...
    @overload
    @property
    def Text(self) -> str: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @overload
    @property
    def TextHeight(self) -> float: ...
    @overload
    @property
    def TextIsWrapped(self) -> bool: ...
    @overload
    @property
    def TextModelWidth(self) -> float: ...
    @overload
    @property
    def TextRotationDegrees(self) -> float: ...
    @overload
    @property
    def TextRotationRadians(self) -> float: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsAllBold(self) -> bool: ...
    @overload
    def IsAllItalic(self) -> bool: ...
    @overload
    def IsAllUnderlined(self) -> bool: ...
    @overload
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DecimalSeparator.setter
    def DecimalSeparator(self, value: Char) -> None: ...
    @overload
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DimensionScale.setter
    def DimensionScale(self, value: float) -> None: ...
    @overload
    @DimensionStyleId.setter
    def DimensionStyleId(self, value: Guid) -> None: ...
    @overload
    @DrawForward.setter
    def DrawForward(self, value: bool) -> None: ...
    @overload
    @DrawTextFrame.setter
    def DrawTextFrame(self, value: bool) -> None: ...
    @overload
    @Font.setter
    def Font(self, value: Font) -> None: ...
    @overload
    @FontIndex.setter
    def FontIndex(self, value: int) -> None: ...
    @overload
    @FormatWidth.setter
    def FormatWidth(self, value: float) -> None: ...
    @overload
    @LeaderArrowBlockId.setter
    def LeaderArrowBlockId(self, value: Guid) -> None: ...
    @overload
    @LeaderArrowSize.setter
    def LeaderArrowSize(self, value: float) -> None: ...
    @overload
    @LeaderArrowType.setter
    def LeaderArrowType(self, value: ArrowType) -> None: ...
    @overload
    @LeaderContentAngleStyle.setter
    def LeaderContentAngleStyle(self, value: LeaderContentAngleStyle) -> None: ...
    @overload
    @LeaderCurveStyle.setter
    def LeaderCurveStyle(self, value: LeaderCurveStyle) -> None: ...
    @overload
    @LeaderHasLanding.setter
    def LeaderHasLanding(self, value: bool) -> None: ...
    @overload
    @LeaderLandingLength.setter
    def LeaderLandingLength(self, value: float) -> None: ...
    @overload
    @LeaderTextHorizontalAlignment.setter
    def LeaderTextHorizontalAlignment(self, value: TextHorizontalAlignment) -> None: ...
    @overload
    @LeaderTextVerticalAlignment.setter
    def LeaderTextVerticalAlignment(self, value: TextVerticalAlignment) -> None: ...
    @overload
    @MaskColor.setter
    def MaskColor(self, value: Color) -> None: ...
    @overload
    @MaskColorSource.setter
    def MaskColorSource(self, value: MaskType) -> None: ...
    @overload
    @MaskEnabled.setter
    def MaskEnabled(self, value: bool) -> None: ...
    @overload
    @MaskFrame.setter
    def MaskFrame(self, value: MaskFrame) -> None: ...
    @overload
    @MaskOffset.setter
    def MaskOffset(self, value: float) -> None: ...
    @overload
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self, value: bool) -> None: ...
    @overload
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self, value: DimensionStyle) -> None: ...
    @overload
    @PlainText.setter
    def PlainText(self, value: str) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @Points2D.setter
    def Points2D(self, value: Iterable[Point2d]) -> None: ...
    @overload
    @Points3D.setter
    def Points3D(self, value: Iterable[Point3d]) -> None: ...
    @overload
    @RichText.setter
    def RichText(self, value: str) -> None: ...
    @overload
    @Text.setter
    def Text(self, value: str) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextHeight.setter
    def TextHeight(self, value: float) -> None: ...
    @overload
    @TextIsWrapped.setter
    def TextIsWrapped(self, value: bool) -> None: ...
    @overload
    @TextRotationDegrees.setter
    def TextRotationDegrees(self, value: float) -> None: ...
    @overload
    @TextRotationRadians.setter
    def TextRotationRadians(self, value: float) -> None: ...
    @overload
    def SetBold(self, set_on: bool) -> bool: ...
    @overload
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    @overload
    def SetItalic(self, set_on: bool) -> bool: ...
    @overload
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    @overload
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    @overload
    def SetUnderline(self, set_on: bool) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def WrapText(self) -> None: ...


class LengthMassProperties:
    @overload
    def CentroidCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    def CentroidCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    @staticmethod
    def Compute(curve: Curve) -> LengthMassProperties: ...
    @overload
    @staticmethod
    def Compute(curves: Iterable[Curve]) -> LengthMassProperties: ...
    @overload
    @staticmethod
    def Compute(curve: Curve, length: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> LengthMassProperties: ...
    @overload
    @staticmethod
    def Compute(curves: Iterable[Curve], length: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> LengthMassProperties: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Centroid(self) -> Point3d: ...
    @overload
    @property
    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def CentroidError(self) -> Vector3d: ...
    @overload
    @property
    def Length(self) -> float: ...
    @overload
    @property
    def LengthError(self) -> float: ...
    @overload
    @property
    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesProductMoments(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def WorldCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    def WorldCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...


from ..Render import Sun
from ..DocObjects import CoordinateSystem
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Light(GeometryBase):
    @overload
    def __init__(self): ...
    ConstantAttenuationVector: Vector3d
    LinearAttenuationVector: Vector3d
    InverseSquaredAttenuationVector: Vector3d
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def CreateSunLight(sun: Sun) -> Light: ...
    @overload
    @staticmethod
    def CreateSunLight(northAngleDegrees: float, azimuthDegrees: float, altitudeDegrees: float) -> Light: ...
    @overload
    @staticmethod
    def CreateSunLight(northAngleDegrees: float, when: DateTime, latitudeDegrees: float, longitudeDegrees: float) -> Light: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Ambient(self) -> Color: ...
    @overload
    @property
    def AttenuationType(self) -> Attenuation: ...
    @overload
    @property
    def AttenuationVector(self) -> Vector3d: ...
    @overload
    @property
    def CoordinateSystem(self) -> CoordinateSystem: ...
    @overload
    @property
    def Diffuse(self) -> Color: ...
    @overload
    @property
    def Direction(self) -> Vector3d: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def HotSpot(self) -> float: ...
    @overload
    @property
    def Id(self) -> Guid: ...
    @overload
    @property
    def Intensity(self) -> float: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDirectionalLight(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsEnabled(self) -> bool: ...
    @overload
    @property
    def IsLinearLight(self) -> bool: ...
    @overload
    @property
    def IsPointLight(self) -> bool: ...
    @overload
    @property
    def IsRectangularLight(self) -> bool: ...
    @overload
    @property
    def IsSpotLight(self) -> bool: ...
    @overload
    @property
    def IsSunLight(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Length(self) -> Vector3d: ...
    @overload
    @property
    def LightStyle(self) -> LightStyle: ...
    @overload
    @property
    def Location(self) -> Point3d: ...
    @overload
    @property
    def Name(self) -> str: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PerpendicularDirection(self) -> Vector3d: ...
    @overload
    @property
    def PowerCandela(self) -> float: ...
    @overload
    @property
    def PowerLumens(self) -> float: ...
    @overload
    @property
    def PowerWatts(self) -> float: ...
    @overload
    @property
    def ShadowIntensity(self) -> float: ...
    @overload
    @property
    def Specular(self) -> Color: ...
    @overload
    @property
    def SpotAngleRadians(self) -> float: ...
    @overload
    @property
    def SpotExponent(self) -> float: ...
    @overload
    @property
    def SpotLightShadowIntensity(self) -> float: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def Width(self) -> Vector3d: ...
    @overload
    def GetAttenuation(self, d: float) -> float: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetSpotLightRadii(self) -> Tuple[bool, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Ambient.setter
    def Ambient(self, value: Color) -> None: ...
    @overload
    @AttenuationType.setter
    def AttenuationType(self, value: Attenuation) -> None: ...
    @overload
    @AttenuationVector.setter
    def AttenuationVector(self, value: Vector3d) -> None: ...
    @overload
    @Diffuse.setter
    def Diffuse(self, value: Color) -> None: ...
    @overload
    @Direction.setter
    def Direction(self, value: Vector3d) -> None: ...
    @overload
    @HotSpot.setter
    def HotSpot(self, value: float) -> None: ...
    @overload
    @Id.setter
    def Id(self, value: Guid) -> None: ...
    @overload
    @Intensity.setter
    def Intensity(self, value: float) -> None: ...
    @overload
    @IsEnabled.setter
    def IsEnabled(self, value: bool) -> None: ...
    @overload
    @Length.setter
    def Length(self, value: Vector3d) -> None: ...
    @overload
    @LightStyle.setter
    def LightStyle(self, value: LightStyle) -> None: ...
    @overload
    @Location.setter
    def Location(self, value: Point3d) -> None: ...
    @overload
    @Name.setter
    def Name(self, value: str) -> None: ...
    @overload
    @PowerCandela.setter
    def PowerCandela(self, value: float) -> None: ...
    @overload
    @PowerLumens.setter
    def PowerLumens(self, value: float) -> None: ...
    @overload
    @PowerWatts.setter
    def PowerWatts(self, value: float) -> None: ...
    @overload
    @ShadowIntensity.setter
    def ShadowIntensity(self, value: float) -> None: ...
    @overload
    @Specular.setter
    def Specular(self, value: Color) -> None: ...
    @overload
    @SpotAngleRadians.setter
    def SpotAngleRadians(self, value: float) -> None: ...
    @overload
    @SpotExponent.setter
    def SpotExponent(self, value: float) -> None: ...
    @overload
    @SpotLightShadowIntensity.setter
    def SpotLightShadowIntensity(self, value: float) -> None: ...
    @overload
    @Width.setter
    def Width(self, value: Vector3d) -> None: ...
    @overload
    def SetAttenuation(self, a0: float, a1: float, a2: float) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class LightStyle(Enum):
    # None = 0
    CameraDirectional = 4
    CameraPoint = 5
    CameraSpot = 6
    WorldDirectional = 7
    WorldPoint = 8
    WorldSpot = 9
    Ambient = 10
    WorldLinear = 11
    WorldRectangular = 12


class Line:
    @overload
    def __init__(self, from_: Point3d, to: Point3d): ...
    @overload
    def __init__(self, start: Point3d, span: Vector3d): ...
    @overload
    def __init__(self, start: Point3d, direction: Vector3d, length: float): ...
    @overload
    def __init__(self, x0: float, y0: float, z0: float, x1: float, y1: float, z1: float): ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, limitToFiniteSegment: bool) -> Point3d: ...
    @overload
    def DistanceTo(self, testPoint: Point3d, limitToFiniteSegment: bool) -> float: ...
    @overload
    def EpsilonEquals(self, other: Line, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: Line) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Extend(self, startLength: float, endLength: float) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: Box) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: Box, additionalLength: float) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox, additionalLength: float) -> bool: ...
    @overload
    def Flip(self) -> None: ...
    @overload
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def Direction(self) -> Vector3d: ...
    @overload
    @property
    def From(self) -> Point3d: ...
    @overload
    @property
    def FromX(self) -> float: ...
    @overload
    @property
    def FromY(self) -> float: ...
    @overload
    @property
    def FromZ(self) -> float: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Length(self) -> float: ...
    @overload
    @property
    def To(self) -> Point3d: ...
    @overload
    @property
    def ToX(self) -> float: ...
    @overload
    @property
    def ToY(self) -> float: ...
    @overload
    @property
    def ToZ(self) -> float: ...
    @overload
    @property
    def UnitTangent(self) -> Vector3d: ...
    @overload
    @property
    def Unset() -> Line: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def MaximumDistanceTo(self, testLine: Line) -> float: ...
    @overload
    def MaximumDistanceTo(self, testPoint: Point3d) -> float: ...
    @overload
    def MinimumDistanceTo(self, testLine: Line) -> float: ...
    @overload
    def MinimumDistanceTo(self, testPoint: Point3d) -> float: ...
    @overload
    def __eq__(a: Line, b: Line) -> bool: ...
    @overload
    def __ne__(a: Line, b: Line) -> bool: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, distance: float) -> Point3d: ...
    @overload
    @From.setter
    def From(self, value: Point3d) -> None: ...
    @overload
    @FromX.setter
    def FromX(self, value: float) -> None: ...
    @overload
    @FromY.setter
    def FromY(self, value: float) -> None: ...
    @overload
    @FromZ.setter
    def FromZ(self, value: float) -> None: ...
    @overload
    @Length.setter
    def Length(self, value: float) -> None: ...
    @overload
    @To.setter
    def To(self, value: Point3d) -> None: ...
    @overload
    @ToX.setter
    def ToX(self, value: float) -> None: ...
    @overload
    @ToY.setter
    def ToY(self, value: float) -> None: ...
    @overload
    @ToZ.setter
    def ToZ(self, value: float) -> None: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    @staticmethod
    def TryCreateBetweenCurves(curve0: Curve, curve1: Curve, t0: float, t1: float, perpendicular0: bool, perpendicular1: bool) -> Tuple[bool, float, float, Line]: ...
    @overload
    @staticmethod
    def TryFitLineToPoints(points: Iterable[Point3d]) -> Tuple[bool, Line]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...


from ..DocObjects import DimensionStyle
from ..DocObjects import ViewportInfo
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ArrowType
from ..DocObjects import ZeroSuppression
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class LinearDimension(Dimension):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, dimensionPlane: Plane, extensionLine1End: Point2d, extensionLine2End: Point2d, pointOnDimensionLine: Point2d): ...
    @overload
    def ClearPropertyOverrides(self) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(dimtype: AnnotationType, dimStyle: DimensionStyle, plane: Plane, horizontal: Vector3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d, rotationInPlane: float) -> LinearDimension: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Explode(self) -> Iterable[GeometryBase]: ...
    @overload
    @staticmethod
    def FromPoints(extensionLine1End: Point3d, extensionLine2End: Point3d, pointOnDimensionLine: Point3d) -> LinearDimension: ...
    @overload
    @property
    def Aligned(self) -> bool: ...
    @overload
    @property
    def AlternateBelowLine(self) -> bool: ...
    @overload
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def AltLengthFactor(self) -> float: ...
    @overload
    @property
    def AltLengthResolution(self) -> int: ...
    @overload
    @property
    def AltLengthRoundoff(self) -> float: ...
    @overload
    @property
    def AltPrefix(self) -> str: ...
    @overload
    @property
    def AltSuffix(self) -> str: ...
    @overload
    @property
    def AltToleranceResolution(self) -> int: ...
    @overload
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @overload
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @overload
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @overload
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @overload
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @overload
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @overload
    @property
    def Arrowhead1End(self) -> Point2d: ...
    @overload
    @property
    def Arrowhead2End(self) -> Point2d: ...
    @overload
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @overload
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @overload
    @property
    def ArrowSize(self) -> float: ...
    @overload
    @property
    def BaselineSpacing(self) -> float: ...
    @overload
    @property
    def CentermarkSize(self) -> float: ...
    @overload
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @overload
    @property
    def DecimalSeparator(self) -> Char: ...
    @overload
    @property
    def DetailMeasured(self) -> Guid: ...
    @overload
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def DimensionLineExtension(self) -> float: ...
    @overload
    @property
    def DimensionLinePoint(self) -> Point2d: ...
    @overload
    @property
    def DimensionScale(self) -> float: ...
    @overload
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def DimensionStyleId(self) -> Guid: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def DistanceBetweenArrowTips(self) -> float: ...
    @overload
    @property
    def DistanceScale(self) -> float: ...
    @overload
    @property
    def DrawForward(self) -> bool: ...
    @overload
    @property
    def DrawTextFrame(self) -> bool: ...
    @overload
    @property
    def ExtensionLine1End(self) -> Point2d: ...
    @overload
    @property
    def ExtensionLine2End(self) -> Point2d: ...
    @overload
    @property
    def ExtensionLineExtension(self) -> float: ...
    @overload
    @property
    def ExtensionLineOffset(self) -> float: ...
    @overload
    @property
    def FirstCharFont(self) -> Font: ...
    @overload
    @property
    def FixedExtensionLength(self) -> float: ...
    @overload
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @overload
    @property
    def Font(self) -> Font: ...
    @overload
    @property
    def FontIndex(self) -> int: ...
    @overload
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @overload
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @overload
    @property
    def ForceDimLine(self) -> bool: ...
    @overload
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @overload
    @property
    def FormatWidth(self) -> float: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def LengthFactor(self) -> float: ...
    @overload
    @property
    def LengthResolution(self) -> int: ...
    @overload
    @property
    def LengthRoundoff(self) -> float: ...
    @overload
    @property
    def MaskColor(self) -> Color: ...
    @overload
    @property
    def MaskColorSource(self) -> MaskType: ...
    @overload
    @property
    def MaskEnabled(self) -> bool: ...
    @overload
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @overload
    @property
    def MaskOffset(self) -> float: ...
    @overload
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @overload
    @property
    def NumericValue(self) -> float: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def PlainText(self) -> str: ...
    @overload
    @property
    def PlainTextWithFields(self) -> str: ...
    @overload
    @property
    def PlainUserText(self) -> str: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Prefix(self) -> str: ...
    @overload
    @property
    def RichText(self) -> str: ...
    @overload
    @property
    def Suffix(self) -> str: ...
    @overload
    @property
    def SuppressExtension1(self) -> bool: ...
    @overload
    @property
    def SuppressExtension2(self) -> bool: ...
    @overload
    @property
    def Text(self) -> str: ...
    @overload
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @overload
    @property
    def TextFit(self) -> TextFit: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @overload
    @property
    def TextHeight(self) -> float: ...
    @overload
    @property
    def TextIsWrapped(self) -> bool: ...
    @overload
    @property
    def TextLocation(self) -> TextLocation: ...
    @overload
    @property
    def TextModelWidth(self) -> float: ...
    @overload
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @overload
    @property
    def TextPosition(self) -> Point2d: ...
    @overload
    @property
    def TextRotation(self) -> float: ...
    @overload
    @property
    def TextRotationDegrees(self) -> float: ...
    @overload
    @property
    def TextRotationRadians(self) -> float: ...
    @overload
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @overload
    @property
    def ToleranceHeightScale(self) -> float: ...
    @overload
    @property
    def ToleranceLowerValue(self) -> float: ...
    @overload
    @property
    def ToleranceResolution(self) -> int: ...
    @overload
    @property
    def ToleranceUpperValue(self) -> float: ...
    @overload
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d]: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    @overload
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Iterable[Any]]: ...
    @overload
    def GetDistanceDisplayText(self, unitsystem: UnitSystem, style: DimensionStyle) -> str: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    @overload
    def GetTextRectangle(self) -> Tuple[bool, Iterable[Point3d]]: ...
    @overload
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsAllBold(self) -> bool: ...
    @overload
    def IsAllItalic(self) -> bool: ...
    @overload
    def IsAllUnderlined(self) -> bool: ...
    @overload
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Aligned.setter
    def Aligned(self, value: bool) -> None: ...
    @overload
    @AlternateBelowLine.setter
    def AlternateBelowLine(self, value: bool) -> None: ...
    @overload
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @AltLengthFactor.setter
    def AltLengthFactor(self, value: float) -> None: ...
    @overload
    @AltLengthResolution.setter
    def AltLengthResolution(self, value: int) -> None: ...
    @overload
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self, value: float) -> None: ...
    @overload
    @AltPrefix.setter
    def AltPrefix(self, value: str) -> None: ...
    @overload
    @AltSuffix.setter
    def AltSuffix(self, value: str) -> None: ...
    @overload
    @AltToleranceResolution.setter
    def AltToleranceResolution(self, value: int) -> None: ...
    @overload
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self, value: bool) -> None: ...
    @overload
    @AltZeroSuppression.setter
    def AltZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    @AnnotationType.setter
    def AnnotationType(self, value: AnnotationType) -> None: ...
    @overload
    @ArrowBlockId1.setter
    def ArrowBlockId1(self, value: Guid) -> None: ...
    @overload
    @ArrowBlockId2.setter
    def ArrowBlockId2(self, value: Guid) -> None: ...
    @overload
    @ArrowFit.setter
    def ArrowFit(self, value: ArrowFit) -> None: ...
    @overload
    @ArrowheadType1.setter
    def ArrowheadType1(self, value: ArrowType) -> None: ...
    @overload
    @ArrowheadType2.setter
    def ArrowheadType2(self, value: ArrowType) -> None: ...
    @overload
    @ArrowSize.setter
    def ArrowSize(self, value: float) -> None: ...
    @overload
    @BaselineSpacing.setter
    def BaselineSpacing(self, value: float) -> None: ...
    @overload
    @CentermarkSize.setter
    def CentermarkSize(self, value: float) -> None: ...
    @overload
    @CentermarkStyle.setter
    def CentermarkStyle(self, value: CenterMarkStyle) -> None: ...
    @overload
    @DecimalSeparator.setter
    def DecimalSeparator(self, value: Char) -> None: ...
    @overload
    @DetailMeasured.setter
    def DetailMeasured(self, value: Guid) -> None: ...
    @overload
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DimensionLineExtension.setter
    def DimensionLineExtension(self, value: float) -> None: ...
    @overload
    @DimensionLinePoint.setter
    def DimensionLinePoint(self, value: Point2d) -> None: ...
    @overload
    @DimensionScale.setter
    def DimensionScale(self, value: float) -> None: ...
    @overload
    @DimensionStyleId.setter
    def DimensionStyleId(self, value: Guid) -> None: ...
    @overload
    @DistanceScale.setter
    def DistanceScale(self, value: float) -> None: ...
    @overload
    @DrawForward.setter
    def DrawForward(self, value: bool) -> None: ...
    @overload
    @DrawTextFrame.setter
    def DrawTextFrame(self, value: bool) -> None: ...
    @overload
    @ExtensionLine1End.setter
    def ExtensionLine1End(self, value: Point2d) -> None: ...
    @overload
    @ExtensionLine2End.setter
    def ExtensionLine2End(self, value: Point2d) -> None: ...
    @overload
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self, value: float) -> None: ...
    @overload
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self, value: float) -> None: ...
    @overload
    @FixedExtensionLength.setter
    def FixedExtensionLength(self, value: float) -> None: ...
    @overload
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self, value: bool) -> None: ...
    @overload
    @Font.setter
    def Font(self, value: Font) -> None: ...
    @overload
    @FontIndex.setter
    def FontIndex(self, value: int) -> None: ...
    @overload
    @ForceArrowPosition.setter
    def ForceArrowPosition(self, value: ForceArrow) -> None: ...
    @overload
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self, value: bool) -> None: ...
    @overload
    @ForceDimLine.setter
    def ForceDimLine(self, value: bool) -> None: ...
    @overload
    @ForceTextPosition.setter
    def ForceTextPosition(self, value: ForceText) -> None: ...
    @overload
    @FormatWidth.setter
    def FormatWidth(self, value: float) -> None: ...
    @overload
    @LengthFactor.setter
    def LengthFactor(self, value: float) -> None: ...
    @overload
    @LengthResolution.setter
    def LengthResolution(self, value: int) -> None: ...
    @overload
    @LengthRoundoff.setter
    def LengthRoundoff(self, value: float) -> None: ...
    @overload
    @MaskColor.setter
    def MaskColor(self, value: Color) -> None: ...
    @overload
    @MaskColorSource.setter
    def MaskColorSource(self, value: MaskType) -> None: ...
    @overload
    @MaskEnabled.setter
    def MaskEnabled(self, value: bool) -> None: ...
    @overload
    @MaskFrame.setter
    def MaskFrame(self, value: MaskFrame) -> None: ...
    @overload
    @MaskOffset.setter
    def MaskOffset(self, value: float) -> None: ...
    @overload
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self, value: bool) -> None: ...
    @overload
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self, value: DimensionStyle) -> None: ...
    @overload
    @PlainText.setter
    def PlainText(self, value: str) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @Prefix.setter
    def Prefix(self, value: str) -> None: ...
    @overload
    @RichText.setter
    def RichText(self, value: str) -> None: ...
    @overload
    @Suffix.setter
    def Suffix(self, value: str) -> None: ...
    @overload
    @SuppressExtension1.setter
    def SuppressExtension1(self, value: bool) -> None: ...
    @overload
    @SuppressExtension2.setter
    def SuppressExtension2(self, value: bool) -> None: ...
    @overload
    @Text.setter
    def Text(self, value: str) -> None: ...
    @overload
    @TextAngleType.setter
    def TextAngleType(self, value: LeaderContentAngleStyle) -> None: ...
    @overload
    @TextFit.setter
    def TextFit(self, value: TextFit) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextHeight.setter
    def TextHeight(self, value: float) -> None: ...
    @overload
    @TextIsWrapped.setter
    def TextIsWrapped(self, value: bool) -> None: ...
    @overload
    @TextLocation.setter
    def TextLocation(self, value: TextLocation) -> None: ...
    @overload
    @TextOrientation.setter
    def TextOrientation(self, value: TextOrientation) -> None: ...
    @overload
    @TextPosition.setter
    def TextPosition(self, value: Point2d) -> None: ...
    @overload
    @TextRotation.setter
    def TextRotation(self, value: float) -> None: ...
    @overload
    @TextRotationDegrees.setter
    def TextRotationDegrees(self, value: float) -> None: ...
    @overload
    @TextRotationRadians.setter
    def TextRotationRadians(self, value: float) -> None: ...
    @overload
    @ToleranceFormat.setter
    def ToleranceFormat(self, value: ToleranceDisplayFormat) -> None: ...
    @overload
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self, value: float) -> None: ...
    @overload
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self, value: float) -> None: ...
    @overload
    @ToleranceResolution.setter
    def ToleranceResolution(self, value: int) -> None: ...
    @overload
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self, value: float) -> None: ...
    @overload
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self, value: bool) -> None: ...
    @overload
    @ZeroSuppression.setter
    def ZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetBold(self, set_on: bool) -> bool: ...
    @overload
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    @overload
    def SetItalic(self, set_on: bool) -> bool: ...
    @overload
    def SetLocations(self, extensionLine1End: Point2d, extensionLine2End: Point2d, pointOnDimensionLine: Point2d) -> None: ...
    @overload
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    @overload
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    @overload
    def SetUnderline(self, set_on: bool) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    @overload
    def WrapText(self) -> None: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class LineCurve(Curve):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: LineCurve): ...
    @overload
    def __init__(self, line: Line): ...
    @overload
    def __init__(self, from_: Point2d, to: Point2d): ...
    @overload
    def __init__(self, from_: Point3d, to: Point3d): ...
    @overload
    def __init__(self, line: Line, t0: float, t1: float): ...
    @overload
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    @overload
    def ControlPolygon(self) -> Polyline: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateCurve(self) -> Curve: ...
    @overload
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    @overload
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    @overload
    def FilletSurfaceToCurve(self, face: BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FilletSurfaceToRail(self, faceWithCurve: BrepFace, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: List, out_breps0: List, out_breps1: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FindLocalInflection(self, N: Vector3d, subDomain: Interval, seed: float) -> Tuple[bool, float, float]: ...
    @overload
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Degree(self) -> int: ...
    @overload
    @property
    def Dimension(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Domain(self) -> Interval: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsPeriodic(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Line(self) -> Line: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PointAtEnd(self) -> Point3d: ...
    @overload
    @property
    def PointAtMid(self) -> Point3d: ...
    @overload
    @property
    def PointAtStart(self) -> Point3d: ...
    @overload
    @property
    def SpanCount(self) -> int: ...
    @overload
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @overload
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    @overload
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    @overload
    def GetSubCurves(self) -> Iterable[Curve]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def InflectionPoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    @overload
    def MakeClosed(self, tolerance: float) -> bool: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    @overload
    def MaxCurvaturePoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    @overload
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetTangentToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, length: float) -> Point3d: ...
    @overload
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float, loose: bool) -> Curve: ...
    @overload
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    @overload
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def Reparameterize(self) -> Curve: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, ribbonParameters: RibbonOffsetParameters) -> Tuple[Curve, Iterable[Curve], Iterable[Curve], Iterable[Brep]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Domain.setter
    def Domain(self, value: Interval) -> None: ...
    @overload
    @Line.setter
    def Line(self, value: Line) -> None: ...
    @overload
    def SetEndPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetStartPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    @overload
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def SpanVector(self) -> Iterable[float]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    @overload
    def TorsionAt(self, t: float) -> float: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class LoftType(Enum):
    Normal = 0
    Loose = 1
    Tight = 2
    Straight = 3
    Developable = 4
    Uniform = 5


class Matrix:
    @overload
    def __init__(self, xform: Transform): ...
    @overload
    def __init__(self, rowCount: int, columnCount: int): ...
    @overload
    def BackSolve(self, zeroTolerance: float, b: Iterable[float]) -> Iterable[float]: ...
    @overload
    def BackSolvePoints(self, zeroTolerance: float, b: Iterable[Point3d]) -> Iterable[Point3d]: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> Matrix: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ColumnCount(self) -> int: ...
    @overload
    @property
    def IsColumnOrthogonal(self) -> bool: ...
    @overload
    @property
    def IsColumnOrthoNormal(self) -> bool: ...
    @overload
    @property
    def IsRowOrthogonal(self) -> bool: ...
    @overload
    @property
    def IsRowOrthoNormal(self) -> bool: ...
    @overload
    @property
    def IsSquare(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Item(self, row: int, column: int) -> float: ...
    @overload
    @property
    def RowCount(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Invert(self, zeroTolerance: float) -> bool: ...
    @overload
    def __add__(a: Matrix, b: Matrix) -> Matrix: ...
    @overload
    def __mul__(a: Matrix, b: Matrix) -> Matrix: ...
    @overload
    def RowReduce(self, zeroTolerance: float, b: Iterable[Point3d]) -> Tuple[int, float]: ...
    @overload
    def RowReduce(self, zeroTolerance: float) -> Tuple[int, float, float]: ...
    @overload
    def RowReduce(self, zeroTolerance: float, b: Iterable[float]) -> Tuple[int, float]: ...
    @overload
    def Scale(self, s: float) -> None: ...
    @overload
    @Item.setter
    def Item(self, row: int, column: int, value: float) -> None: ...
    @overload
    def SetDiagonal(self, d: float) -> None: ...
    @overload
    def SwapColumns(self, columnA: int, columnB: int) -> bool: ...
    @overload
    def SwapRows(self, rowA: int, rowB: int) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transpose(self) -> bool: ...
    @overload
    def Zero(self) -> None: ...


class MaximumCounts(Enum):
    MaximumRecommendedInterpolatedVertexCount = 1000


class MeasuredDirection(Enum):
    Unset = 0
    Xaxis = 1
    Yaxis = 2


from ..Display import RhinoViewport
from ..DocObjects import ViewportInfo
from ..FileIO import TextLog
from ..Render import TextureMapping
from .MeshRefinements import LoopFormula
from .MeshRefinements import RefinementSettings
from ..Commands import Result
from .Collections import MeshVertexList
from .Collections import MeshTopologyVertexList
from .Collections import MeshTopologyEdgeList
from .Collections import MeshVertexNormalList
from .Collections import MeshFaceList
from .Collections import MeshNgonList
from .Collections import MeshFaceNormalList
from .Collections import MeshVertexColorList
from .Collections import MeshTextureCoordinateList
from .Collections import MeshVertexStatusList
from ..DocObjects import RhinoObject
from ..DocObjects import Material
from ..Render import CachedTextureCoordinates
from ..DocObjects import Texture
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Mesh(GeometryBase):
    @overload
    def __init__(self): ...
    @overload
    def Append(self, other: Mesh) -> None: ...
    @overload
    def Append(self, meshes: Iterable[Mesh]) -> None: ...
    @overload
    def Check(self, textLog: TextLog, parameters: MeshCheckParameters) -> Tuple[bool, MeshCheckParameters]: ...
    @overload
    def ClearSurfaceData(self) -> None: ...
    @overload
    def ClearTextureData(self) -> None: ...
    @overload
    def ClosestMeshPoint(self, testPoint: Point3d, maximumDistance: float) -> MeshPoint: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[int, Point3d]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[int, Point3d, Vector3d]: ...
    @overload
    def CollapseFacesByArea(self, lessThanArea: float, greaterThanArea: float) -> int: ...
    @overload
    def CollapseFacesByByAspectRatio(self, aspectRatio: float) -> int: ...
    @overload
    def CollapseFacesByEdgeLength(self, bGreaterThan: bool, edgeLength: float) -> int: ...
    @overload
    def ColorAt(self, meshPoint: MeshPoint) -> Color: ...
    @overload
    def ColorAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Color: ...
    @overload
    def Compact(self) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def ComputeAutoCreaseInformation(self) -> Iterable[int]: ...
    @overload
    def ComputeCurvatureApproximation(self, type: int) -> Tuple[bool, Iterable[float]]: ...
    @overload
    @staticmethod
    def ComputeThickness(meshes: Iterable[Mesh], maximumThickness: float) -> Iterable[MeshThicknessMeasurement]: ...
    @overload
    @staticmethod
    def ComputeThickness(meshes: Iterable[Mesh], maximumThickness: float, cancelToken: CancellationToken) -> Iterable[MeshThicknessMeasurement]: ...
    @overload
    @staticmethod
    def ComputeThickness(meshes: Iterable[Mesh], maximumThickness: float, sharpAngle: float, cancelToken: CancellationToken) -> Iterable[MeshThicknessMeasurement]: ...
    @overload
    def CopyFrom(self, other: Mesh) -> None: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstSet: Iterable[Mesh], secondSet: Iterable[Mesh]) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstSet: Iterable[Mesh], secondSet: Iterable[Mesh], options: MeshBooleanOptions) -> Tuple[Iterable[Mesh], Result]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstSet: Iterable[Mesh], secondSet: Iterable[Mesh]) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstSet: Iterable[Mesh], secondSet: Iterable[Mesh], options: MeshBooleanOptions) -> Tuple[Iterable[Mesh], Result]: ...
    @overload
    @staticmethod
    def CreateBooleanSplit(meshesToSplit: Iterable[Mesh], meshSplitters: Iterable[Mesh]) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def CreateBooleanSplit(meshesToSplit: Iterable[Mesh], meshSplitters: Iterable[Mesh], options: MeshBooleanOptions) -> Tuple[Iterable[Mesh], Result]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(meshes: Iterable[Mesh]) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(meshes: Iterable[Mesh], tolerance: float) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(meshes: Iterable[Mesh], options: MeshBooleanOptions) -> Tuple[Iterable[Mesh], Result]: ...
    @overload
    @staticmethod
    def CreateContourCurves(meshToContour: Mesh, sectionPlane: Plane, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateContourCurves(meshToContour: Mesh, contourStart: Point3d, contourEnd: Point3d, interval: float, tolerance: float) -> Iterable[Curve]: ...
    @overload
    @staticmethod
    def CreateConvexHull3D(points: Iterable[Point3d], tolerance: float, angleTolerance: float) -> Tuple[Mesh, Iterable[Iterable[int]]]: ...
    @overload
    @staticmethod
    def CreateExtrusion(profile: Curve, direction: Vector3d) -> Mesh: ...
    @overload
    @staticmethod
    def CreateExtrusion(profile: Curve, direction: Vector3d, parameters: MeshingParameters) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromBox(corners: Iterable[Point3d], xCount: int, yCount: int, zCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromBox(box: Box, xCount: int, yCount: int, zCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromBox(box: BoundingBox, xCount: int, yCount: int, zCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromBrep(brep: Brep, meshingParameters: MeshingParameters) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def CreateFromClosedPolyline(polyline: Polyline) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone, vertical: int, around: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone, vertical: int, around: int, solid: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone, vertical: int, around: int, solid: bool, quadCaps: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCurveExtrusion(curve: Curve, direction: Vector3d, parameters: MeshingParameters, boundingBox: BoundingBox) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCurvePipe(curve: Curve, radius: float, segments: int, accuracy: int, capType: MeshPipeCapStyle, faceted: bool, intervals: Iterable[Interval]) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool, quadCaps: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool, circumscribe: bool, quadCaps: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromExtrusion(extrusion: Extrusion, meshingParameters: MeshingParameters) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromFilteredFaceList(original: Mesh, inclusion: Iterable[bool]) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromIterativeCleanup(meshes: Iterable[Mesh], tolerance: float) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def CreateFromLines(lines: Iterable[Curve], maxFaceValence: int, tolerance: float) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromPatchSingleFace(mesh: Mesh, components: Iterable[ComponentIndex]) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromPlanarBoundary(boundary: Curve, parameters: MeshingParameters, tolerance: float) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromPlane(plane: Plane, xInterval: Interval, yInterval: Interval, xCount: int, yCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSphere(sphere: Sphere, xCount: int, yCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSubD(subd: SubD, displayDensity: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSubDControlNet(subd: SubD) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSubDControlNetWithTextureCoordinates(subd: SubD) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSurface(surface: Surface) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSurface(surface: Surface, meshingParameters: MeshingParameters) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSurfaceControlNet(surface: Surface) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromTessellation(points: Iterable[Point3d], edges: Iterable[Iterable[Point3d]], plane: Plane, allowNewVertices: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromTorus(torus: Torus, vertical: int, around: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateIcoSphere(sphere: Sphere, subdivisions: int) -> Mesh: ...
    @overload
    def CreatePartitions(self, maximumVertexCount: int, maximumTriangleCount: int) -> bool: ...
    @overload
    @staticmethod
    def CreatePatch(outerBoundary: Polyline, angleToleranceRadians: float, pullbackSurface: Surface, innerBoundaryCurves: Iterable[Curve], innerBothSideCurves: Iterable[Curve], innerPoints: Iterable[Point3d], trimback: bool, divisions: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateQuadSphere(sphere: Sphere, subdivisions: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateRefinedCatmullClarkMesh(mesh: Mesh, settings: RefinementSettings) -> Mesh: ...
    @overload
    @staticmethod
    def CreateRefinedLoopMesh(mesh: Mesh, formula: LoopFormula, settings: RefinementSettings) -> Mesh: ...
    @overload
    @staticmethod
    def CreateUnweldedMesh(mesh: Mesh) -> Mesh: ...
    @overload
    def CreateVertexColorsFromBitmap(self, doc: RhinoDoc, mapping: TextureMapping, xform: Transform, bitmap: Bitmap) -> bool: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def DestroyPartition(self) -> None: ...
    @overload
    def DestroyTopology(self) -> None: ...
    @overload
    def DestroyTree(self) -> None: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateMesh(self) -> Mesh: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def EvaluateMeshGeometry(self, surface: Surface) -> bool: ...
    @overload
    def ExplodeAtUnweldedEdges(self) -> Iterable[Mesh]: ...
    @overload
    def ExtendSelectionByEdgeRidge(self, preselectedEdges: Iterable[int], newEdge: int, iterative: bool) -> Iterable[int]: ...
    @overload
    def ExtendSelectionByFaceLoop(self, preselectedFaces: Iterable[int], newFace: int, iterative: bool) -> Iterable[int]: ...
    @overload
    def ExtractNonManifoldEdges(self, selective: bool) -> Mesh: ...
    @overload
    def FileHole(self, topologyEdgeIndex: int) -> bool: ...
    @overload
    def FillHoles(self) -> bool: ...
    @overload
    def Flip(self, vertexNormals: bool, faceNormals: bool, faceOrientation: bool) -> None: ...
    @overload
    def Flip(self, vertexNormals: bool, faceNormals: bool, faceOrientation: bool, ngonsBoundaryDirection: bool) -> None: ...
    @overload
    @property
    def ComponentStates(self) -> MeshVertexStatusList: ...
    @overload
    @property
    def DisjointMeshCount(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def FaceNormals(self) -> MeshFaceNormalList: ...
    @overload
    @property
    def Faces(self) -> MeshFaceList: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasCachedTextureCoordinates(self) -> bool: ...
    @overload
    @property
    def HasPrincipalCurvatures(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsOriented(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Ngons(self) -> MeshNgonList: ...
    @overload
    @property
    def Normals(self) -> MeshVertexNormalList: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PartitionCount(self) -> int: ...
    @overload
    @property
    def TextureCoordinates(self) -> MeshTextureCoordinateList: ...
    @overload
    @property
    def TopologyEdges(self) -> MeshTopologyEdgeList: ...
    @overload
    @property
    def TopologyVertices(self) -> MeshTopologyVertexList: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def VertexColors(self) -> MeshVertexColorList: ...
    @overload
    @property
    def Vertices(self) -> MeshVertexList: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetCachedTextureCoordinates(self, textureMappingId: Guid) -> CachedTextureCoordinates: ...
    @overload
    def GetCachedTextureCoordinates(self, rhinoObject: RhinoObject, texture: Texture) -> CachedTextureCoordinates: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetNakedEdgePointStatus(self) -> Iterable[bool]: ...
    @overload
    def GetNakedEdges(self) -> Iterable[Polyline]: ...
    @overload
    def GetNgonAndFacesCount(self) -> int: ...
    @overload
    def GetNgonAndFacesEnumerable(self) -> Iterable[MeshNgon]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetOutlines(self, plane: Plane) -> Iterable[Polyline]: ...
    @overload
    def GetOutlines(self, viewport: RhinoViewport) -> Iterable[Polyline]: ...
    @overload
    def GetOutlines(self, viewportInfo: ViewportInfo, plane: Plane) -> Iterable[Polyline]: ...
    @overload
    def GetPartition(self, which: int) -> MeshPart: ...
    @overload
    def GetSelfIntersections(self, tolerance: float, overlapsPolylines: bool, overlapsMesh: bool, textLog: TextLog, cancel: CancellationToken, progress: IProgress) -> Tuple[bool, Iterable[Polyline], Iterable[Polyline], Mesh]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUnsafeLock(self, writable: bool) -> MeshUnsafeLock: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HealNakedEdges(self, distance: float) -> bool: ...
    @overload
    def InvalidateCachedTextureCoordinates(self, bOnlyInvalidateCachedSurfaceParameterMapping: bool) -> None: ...
    @overload
    def IsManifold(self) -> bool: ...
    @overload
    def IsManifold(self, topologicalTest: bool) -> Tuple[bool, bool, bool]: ...
    @overload
    def IsPointInside(self, point: Point3d, tolerance: float, strictlyIn: bool) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MatchEdges(self, distance: float, rachet: bool) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float) -> bool: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def NormalAt(self, meshPoint: MeshPoint) -> Vector3d: ...
    @overload
    def NormalAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool, direction: Vector3d) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool, direction: Vector3d) -> Tuple[Mesh, List]: ...
    @overload
    def PatchSingleFace(self, components: Iterable[ComponentIndex]) -> bool: ...
    @overload
    def PointAt(self, meshPoint: MeshPoint) -> Point3d: ...
    @overload
    def PointAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Point3d: ...
    @overload
    def PullCurve(self, curve: Curve, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullPointsToMesh(self, points: Iterable[Point3d]) -> Iterable[Point3d]: ...
    @overload
    def QuadRemesh(self, parameters: QuadRemeshParameters) -> Mesh: ...
    @overload
    def QuadRemesh(self, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve]) -> Mesh: ...
    @overload
    def QuadRemeshAsync(self, parameters: QuadRemeshParameters, progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    def QuadRemeshAsync(self, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve], progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    def QuadRemeshAsync(self, faceBlocks: Iterable[int], parameters: QuadRemeshParameters, guideCurves: Iterable[Curve], progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    @staticmethod
    def QuadRemeshBrep(brep: Brep, parameters: QuadRemeshParameters) -> Mesh: ...
    @overload
    @staticmethod
    def QuadRemeshBrep(brep: Brep, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve]) -> Mesh: ...
    @overload
    @staticmethod
    def QuadRemeshBrepAsync(brep: Brep, parameters: QuadRemeshParameters, progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    @staticmethod
    def QuadRemeshBrepAsync(brep: Brep, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve], progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    def RebuildNormals(self) -> None: ...
    @overload
    def Reduce(self, parameters: ReduceMeshParameters) -> bool: ...
    @overload
    def Reduce(self, parameters: ReduceMeshParameters, threaded: bool) -> bool: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool) -> bool: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, threaded: bool) -> bool: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: CancellationToken, progress: IProgress) -> Tuple[bool, str]: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: CancellationToken, progress: IProgress, threaded: bool) -> Tuple[bool, str]: ...
    @overload
    def ReleaseUnsafeLock(self, meshData: MeshUnsafeLock) -> None: ...
    @overload
    @staticmethod
    def RequireIterativeCleanup(meshes: Iterable[Mesh], tolerance: float) -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetCachedTextureCoordinates(self, tm: TextureMapping, xf: Transform) -> Tuple[Transform]: ...
    @overload
    def SetCachedTextureCoordinatesFromMaterial(self, rhinoObject: RhinoObject, material: Material) -> None: ...
    @overload
    def SetSurfaceParametersFromTextureCoordinates(self) -> bool: ...
    @overload
    def SetTextureCoordinates(self, tm: TextureMapping, xf: Transform, lazy: bool) -> None: ...
    @overload
    def SetTextureCoordinates(self, tm: TextureMapping, xf: Transform, lazy: bool, seamCheck: bool) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ShrinkWrap(self, parameters: ShrinkWrapParameters) -> Mesh: ...
    @overload
    @staticmethod
    def ShrinkWrap(pointCloud: PointCloud, parameters: ShrinkWrapParameters) -> Mesh: ...
    @overload
    @staticmethod
    def ShrinkWrap(meshes: Iterable[Mesh], parameters: ShrinkWrapParameters) -> Mesh: ...
    @overload
    def ShrinkWrap(self, parameters: ShrinkWrapParameters, token: CancellationToken) -> Mesh: ...
    @overload
    @staticmethod
    def ShrinkWrap(geometryBases: Iterable[GeometryBase], parameters: ShrinkWrapParameters, meshingParameters: MeshingParameters) -> Mesh: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> bool: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    @overload
    def Smooth(self, smoothFactor: float, numSteps: int, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    @overload
    def Smooth(self, vertexIndices: Iterable[int], smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    @overload
    def Smooth(self, vertexIndices: Iterable[int], smoothFactor: float, numSteps: int, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    @overload
    def SolidOrientation(self) -> int: ...
    @overload
    def Split(self, meshes: Iterable[Mesh]) -> Iterable[Mesh]: ...
    @overload
    def Split(self, mesh: Mesh) -> Iterable[Mesh]: ...
    @overload
    def Split(self, plane: Plane) -> Iterable[Mesh]: ...
    @overload
    def Split(self, meshes: Iterable[Mesh], tolerance: float, splitAtCoplanar: bool, textLog: TextLog, cancel: CancellationToken, progress: IProgress) -> Iterable[Mesh]: ...
    @overload
    def Split(self, meshes: Iterable[Mesh], tolerance: float, splitAtCoplanar: bool, createNgons: bool, textLog: TextLog, cancel: CancellationToken, progress: IProgress) -> Iterable[Mesh]: ...
    @overload
    def SplitDisjointPieces(self) -> Iterable[Mesh]: ...
    @overload
    def SplitWithProjectedPolylines(self, curves: Iterable[PolylineCurve], tolerance: float) -> Iterable[Mesh]: ...
    @overload
    def SplitWithProjectedPolylines(self, curves: Iterable[PolylineCurve], tolerance: float, textLog: TextLog, cancel: CancellationToken, progress: IProgress) -> Iterable[Mesh]: ...
    @overload
    def Subdivide(self) -> bool: ...
    @overload
    def Subdivide(self, faceIndices: Iterable[int]) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def UnifyNormals(self) -> int: ...
    @overload
    def UnifyNormals(self, countOnly: bool) -> int: ...
    @overload
    def Unweld(self, angleToleranceRadians: float, modifyNormals: bool) -> None: ...
    @overload
    def UnweldEdge(self, edgeIndices: Iterable[int], modifyNormals: bool) -> bool: ...
    @overload
    def UnweldVertices(self, topologyVertexIndices: Iterable[int], modifyNormals: bool) -> bool: ...
    @overload
    def Volume(self) -> float: ...
    @overload
    def Weld(self, angleToleranceRadians: float) -> None: ...
    @overload
    def WithDisplacement(self, displacement: MeshDisplacementInfo) -> Mesh: ...
    @overload
    def WithEdgeSoftening(self, softeningRadius: float, chamfer: bool, faceted: bool, force: bool, angleThreshold: float) -> Mesh: ...
    @overload
    def WithShutLining(self, faceted: bool, tolerance: float, curves: Iterable[ShutLiningCurveInfo]) -> Mesh: ...


from ..FileIO import TextLog
class MeshBooleanOptions:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def CancellationToken(self) -> CancellationToken: ...
    @overload
    @property
    def ProgressReporter(self) -> IProgress: ...
    @overload
    @property
    def TextLog(self) -> TextLog: ...
    @overload
    @property
    def Tolerance(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @CancellationToken.setter
    def CancellationToken(self, value: CancellationToken) -> None: ...
    @overload
    @ProgressReporter.setter
    def ProgressReporter(self, value: IProgress) -> None: ...
    @overload
    @TextLog.setter
    def TextLog(self, value: TextLog) -> None: ...
    @overload
    @Tolerance.setter
    def Tolerance(self, value: float) -> None: ...
    @overload
    def ToString(self) -> str: ...


class MeshCheckParameters:
    @overload
    @staticmethod
    def Defaults() -> MeshCheckParameters: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def CheckForBadNormals(self) -> bool: ...
    @overload
    @property
    def CheckForDegenerateFaces(self) -> bool: ...
    @overload
    @property
    def CheckForDisjointMeshes(self) -> bool: ...
    @overload
    @property
    def CheckForDuplicateFaces(self) -> bool: ...
    @overload
    @property
    def CheckForExtremelyShortEdges(self) -> bool: ...
    @overload
    @property
    def CheckForInvalidNgons(self) -> bool: ...
    @overload
    @property
    def CheckForNakedEdges(self) -> bool: ...
    @overload
    @property
    def CheckForNonManifoldEdges(self) -> bool: ...
    @overload
    @property
    def CheckForRandomFaceNormals(self) -> bool: ...
    @overload
    @property
    def CheckForSelfIntersection(self) -> bool: ...
    @overload
    @property
    def CheckForUnusedVertices(self) -> bool: ...
    @overload
    @property
    def DegenerateFaceCount(self) -> int: ...
    @overload
    @property
    def DisjointMeshCount(self) -> int: ...
    @overload
    @property
    def DuplicateFaceCount(self) -> int: ...
    @overload
    @property
    def ExtremelyShortEdgeCount(self) -> int: ...
    @overload
    @property
    def InvalidNgonCount(self) -> int: ...
    @overload
    @property
    def NakedEdgeCount(self) -> int: ...
    @overload
    @property
    def NonManifoldEdgeCount(self) -> int: ...
    @overload
    @property
    def NonUnitVectorNormalCount(self) -> int: ...
    @overload
    @property
    def RandomFaceNormalCount(self) -> int: ...
    @overload
    @property
    def SelfIntersectingPairsCount(self) -> int: ...
    @overload
    @property
    def UnusedVertexCount(self) -> int: ...
    @overload
    @property
    def VertexFaceNormalsDifferCount(self) -> int: ...
    @overload
    @property
    def ZeroLengthNormalCount(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @CheckForBadNormals.setter
    def CheckForBadNormals(self, value: bool) -> None: ...
    @overload
    @CheckForDegenerateFaces.setter
    def CheckForDegenerateFaces(self, value: bool) -> None: ...
    @overload
    @CheckForDisjointMeshes.setter
    def CheckForDisjointMeshes(self, value: bool) -> None: ...
    @overload
    @CheckForDuplicateFaces.setter
    def CheckForDuplicateFaces(self, value: bool) -> None: ...
    @overload
    @CheckForExtremelyShortEdges.setter
    def CheckForExtremelyShortEdges(self, value: bool) -> None: ...
    @overload
    @CheckForInvalidNgons.setter
    def CheckForInvalidNgons(self, value: bool) -> None: ...
    @overload
    @CheckForNakedEdges.setter
    def CheckForNakedEdges(self, value: bool) -> None: ...
    @overload
    @CheckForNonManifoldEdges.setter
    def CheckForNonManifoldEdges(self, value: bool) -> None: ...
    @overload
    @CheckForRandomFaceNormals.setter
    def CheckForRandomFaceNormals(self, value: bool) -> None: ...
    @overload
    @CheckForSelfIntersection.setter
    def CheckForSelfIntersection(self, value: bool) -> None: ...
    @overload
    @CheckForUnusedVertices.setter
    def CheckForUnusedVertices(self, value: bool) -> None: ...
    @overload
    def ToString(self) -> str: ...


from ..Render import RenderTexture
from ..Render import TextureMapping
class MeshDisplacementInfo:
    @overload
    def __init__(self, texture: RenderTexture, mapping: TextureMapping): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Black(self) -> float: ...
    @overload
    @property
    def BlackMove(self) -> float: ...
    @overload
    @property
    def ChannelNumber(self) -> int: ...
    @overload
    @property
    def FaceLimit(self) -> int: ...
    @overload
    @property
    def FairingAmount(self) -> int: ...
    @overload
    @property
    def InstanceTransform(self) -> Transform: ...
    @overload
    @property
    def Mapping(self) -> TextureMapping: ...
    @overload
    @property
    def MappingTransform(self) -> Transform: ...
    @overload
    @property
    def MemoryLimit(self) -> int: ...
    @overload
    @property
    def PostWeldAngle(self) -> float: ...
    @overload
    @property
    def RefineSensitivity(self) -> float: ...
    @overload
    @property
    def RefineStepCount(self) -> int: ...
    @overload
    @property
    def SweepPitch(self) -> float: ...
    @overload
    @property
    def Texture(self) -> RenderTexture: ...
    @overload
    @property
    def White(self) -> float: ...
    @overload
    @property
    def WhiteMove(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @Black.setter
    def Black(self, value: float) -> None: ...
    @overload
    @BlackMove.setter
    def BlackMove(self, value: float) -> None: ...
    @overload
    @ChannelNumber.setter
    def ChannelNumber(self, value: int) -> None: ...
    @overload
    @FaceLimit.setter
    def FaceLimit(self, value: int) -> None: ...
    @overload
    @FairingAmount.setter
    def FairingAmount(self, value: int) -> None: ...
    @overload
    @InstanceTransform.setter
    def InstanceTransform(self, value: Transform) -> None: ...
    @overload
    @MappingTransform.setter
    def MappingTransform(self, value: Transform) -> None: ...
    @overload
    @MemoryLimit.setter
    def MemoryLimit(self, value: int) -> None: ...
    @overload
    @PostWeldAngle.setter
    def PostWeldAngle(self, value: float) -> None: ...
    @overload
    @RefineSensitivity.setter
    def RefineSensitivity(self, value: float) -> None: ...
    @overload
    @RefineStepCount.setter
    def RefineStepCount(self, value: int) -> None: ...
    @overload
    @SweepPitch.setter
    def SweepPitch(self, value: float) -> None: ...
    @overload
    @White.setter
    def White(self, value: float) -> None: ...
    @overload
    @WhiteMove.setter
    def WhiteMove(self, value: float) -> None: ...
    @overload
    def ToString(self) -> str: ...


class MeshExtruder:
    @overload
    def __init__(self, inputMesh: Mesh, componentIndices: Iterable[ComponentIndex]): ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def ExtrudedMesh(self) -> Tuple[bool, Mesh]: ...
    @overload
    def ExtrudedMesh(self) -> Tuple[bool, Mesh, List]: ...
    @overload
    @property
    def EdgeBasedUVN(self) -> bool: ...
    @overload
    @property
    def FaceDirectionMode(self) -> MeshExtruderFaceDirectionMode: ...
    @overload
    @property
    def KeepOriginalFaces(self) -> bool: ...
    @overload
    @property
    def PreviewLines(self) -> Iterable[Line]: ...
    @overload
    @property
    def SurfaceParameterMode(self) -> MeshExtruderParameterMode: ...
    @overload
    @property
    def TextureCoordinateMode(self) -> MeshExtruderParameterMode: ...
    @overload
    @property
    def Transform(self) -> Transform: ...
    @overload
    @property
    def UVN(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetWallFaces(self) -> List: ...
    @overload
    @EdgeBasedUVN.setter
    def EdgeBasedUVN(self, value: bool) -> None: ...
    @overload
    @FaceDirectionMode.setter
    def FaceDirectionMode(self, value: MeshExtruderFaceDirectionMode) -> None: ...
    @overload
    @KeepOriginalFaces.setter
    def KeepOriginalFaces(self, value: bool) -> None: ...
    @overload
    @SurfaceParameterMode.setter
    def SurfaceParameterMode(self, value: MeshExtruderParameterMode) -> None: ...
    @overload
    @TextureCoordinateMode.setter
    def TextureCoordinateMode(self, value: MeshExtruderParameterMode) -> None: ...
    @overload
    @Transform.setter
    def Transform(self, value: Transform) -> None: ...
    @overload
    @UVN.setter
    def UVN(self, value: bool) -> None: ...
    @overload
    def ToString(self) -> str: ...


class MeshExtruderFaceDirectionMode(Enum):
    Keep = 0
    OrientClosedFrontOut = 1


class MeshExtruderParameterMode(Enum):
    CoverWalls = 0
    KeepAndStretch = 1


class MeshFace:
    @overload
    def __init__(self, a: int, b: int, c: int): ...
    @overload
    def __init__(self, a: int, b: int, c: int, d: int): ...
    @overload
    def CompareTo(self, other: MeshFace) -> int: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: MeshFace) -> bool: ...
    @overload
    def Flip(self) -> MeshFace: ...
    @overload
    @property
    def A(self) -> int: ...
    @overload
    @property
    def B(self) -> int: ...
    @overload
    @property
    def C(self) -> int: ...
    @overload
    @property
    def D(self) -> int: ...
    @overload
    @property
    def IsQuad(self) -> bool: ...
    @overload
    @property
    def IsTriangle(self) -> bool: ...
    @overload
    @overload
    @property
    def Unset() -> MeshFace: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IsValid(self) -> bool: ...
    @overload
    def IsValid(self, vertexCount: int) -> bool: ...
    @overload
    def IsValid(self, points: Iterable[Point3d]) -> bool: ...
    @overload
    def IsValidEx(self, points: Iterable[Point3d]) -> Tuple[bool, Iterable[Point3d]]: ...
    @overload
    def __eq__(a: MeshFace, b: MeshFace) -> bool: ...
    @overload
    def __ne__(a: MeshFace, b: MeshFace) -> bool: ...
    @overload
    def Repair(self, points: Iterable[Point3d]) -> bool: ...
    @overload
    def RepairEx(self, points: Iterable[Point3d]) -> Tuple[bool, Iterable[Point3d]]: ...
    @overload
    @A.setter
    def A(self, value: int) -> None: ...
    @overload
    @B.setter
    def B(self, value: int) -> None: ...
    @overload
    @C.setter
    def C(self, value: int) -> None: ...
    @overload
    @D.setter
    def D(self, value: int) -> None: ...
    @overload
    @property
    def Item(self) -> MutableSequence[int]: ...
    @overload
    def Set(self, a: int, b: int, c: int) -> None: ...
    @overload
    def Set(self, a: int, b: int, c: int, d: int) -> None: ...
    @overload
    def ToString(self) -> str: ...


class MeshingParameters:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, source: MeshingParameters): ...
    @overload
    def __init__(self, density: float): ...
    @overload
    def __init__(self, density: float, minimumEdgeLength: float): ...
    @overload
    def __init__(self, info: SerializationInfo, context: StreamingContext): ...
    @overload
    def CopyFrom(self, source: MeshingParameters) -> None: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    @staticmethod
    def DocumentCurrentSetting(doc: RhinoDoc) -> MeshingParameters: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: MeshingParameters) -> bool: ...
    @overload
    @staticmethod
    def FromEncodedString(value: str) -> MeshingParameters: ...
    @overload
    @property
    def ClosedObjectPostProcess(self) -> bool: ...
    @overload
    @property
    def Coarse() -> MeshingParameters: ...
    @overload
    @property
    def ComputeCurvature(self) -> bool: ...
    @overload
    @property
    def Default() -> MeshingParameters: ...
    @overload
    @property
    def DefaultAnalysisMesh() -> MeshingParameters: ...
    @overload
    @property
    def DoublePrecision(self) -> bool: ...
    @overload
    @property
    def FastRenderMesh() -> MeshingParameters: ...
    @overload
    @property
    def GridAmplification(self) -> float: ...
    @overload
    @property
    def GridAngle(self) -> float: ...
    @overload
    @property
    def GridAspectRatio(self) -> float: ...
    @overload
    @property
    def GridMaxCount(self) -> int: ...
    @overload
    @property
    def GridMinCount(self) -> int: ...
    @overload
    @property
    def JaggedSeams(self) -> bool: ...
    @overload
    @property
    def MaximumEdgeLength(self) -> float: ...
    @overload
    @property
    def Minimal() -> MeshingParameters: ...
    @overload
    @property
    def MinimumEdgeLength(self) -> float: ...
    @overload
    @property
    def MinimumTolerance(self) -> float: ...
    @overload
    @property
    def QualityRenderMesh() -> MeshingParameters: ...
    @overload
    @property
    def RefineAngle(self) -> float: ...
    @overload
    @property
    def RefineAngleInDegrees(self) -> float: ...
    @overload
    @property
    def RefineGrid(self) -> bool: ...
    @overload
    @property
    def RelativeTolerance(self) -> float: ...
    @overload
    @property
    def SimplePlanes(self) -> bool: ...
    @overload
    @property
    def Smooth() -> MeshingParameters: ...
    @overload
    @property
    def TextureRange(self) -> MeshingParameterTextureRange: ...
    @overload
    @property
    def Tolerance(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def __eq__(mp1: MeshingParameters, mp2: MeshingParameters) -> bool: ...
    @overload
    def __ne__(mp1: MeshingParameters, mp2: MeshingParameters) -> bool: ...
    @overload
    @ClosedObjectPostProcess.setter
    def ClosedObjectPostProcess(self, value: bool) -> None: ...
    @overload
    @ComputeCurvature.setter
    def ComputeCurvature(self, value: bool) -> None: ...
    @overload
    @DoublePrecision.setter
    def DoublePrecision(self, value: bool) -> None: ...
    @overload
    @GridAmplification.setter
    def GridAmplification(self, value: float) -> None: ...
    @overload
    @GridAngle.setter
    def GridAngle(self, value: float) -> None: ...
    @overload
    @GridAspectRatio.setter
    def GridAspectRatio(self, value: float) -> None: ...
    @overload
    @GridMaxCount.setter
    def GridMaxCount(self, value: int) -> None: ...
    @overload
    @GridMinCount.setter
    def GridMinCount(self, value: int) -> None: ...
    @overload
    @JaggedSeams.setter
    def JaggedSeams(self, value: bool) -> None: ...
    @overload
    @MaximumEdgeLength.setter
    def MaximumEdgeLength(self, value: float) -> None: ...
    @overload
    @MinimumEdgeLength.setter
    def MinimumEdgeLength(self, value: float) -> None: ...
    @overload
    @MinimumTolerance.setter
    def MinimumTolerance(self, value: float) -> None: ...
    @overload
    @RefineAngle.setter
    def RefineAngle(self, value: float) -> None: ...
    @overload
    @RefineAngleInDegrees.setter
    def RefineAngleInDegrees(self, value: float) -> None: ...
    @overload
    @RefineGrid.setter
    def RefineGrid(self, value: bool) -> None: ...
    @overload
    @RelativeTolerance.setter
    def RelativeTolerance(self, value: float) -> None: ...
    @overload
    @SimplePlanes.setter
    def SimplePlanes(self, value: bool) -> None: ...
    @overload
    @TextureRange.setter
    def TextureRange(self, value: MeshingParameterTextureRange) -> None: ...
    @overload
    @Tolerance.setter
    def Tolerance(self, value: float) -> None: ...
    @overload
    def SetSubDDisplayParameters(self, subDDisplayParameters: SubDDisplayParameters) -> None: ...
    @overload
    def SubDDisplayParameters(self) -> SubDDisplayParameters: ...
    @overload
    def ToEncodedString(self) -> str: ...
    @overload
    def ToString(self) -> str: ...


class MeshingParameterStyle(Enum):
    # None = 0
    Fast = 1
    Quality = 2
    Custom = 9
    PerObject = 10


class MeshingParameterTextureRange(Enum):
    Unset = 0
    UnpackedUnscaledNormalized = 1
    PackedScaledNormalized = 2


class MeshNgon:
    @overload
    def BoundaryVertexIndexList(self) -> Iterable[int]: ...
    @overload
    def CompareTo(self, otherNgon: MeshNgon) -> int: ...
    @overload
    @staticmethod
    def Create(meshVertexIndexList: Iterable[int], meshFaceIndexList: Iterable[int]) -> MeshNgon: ...
    @overload
    def Equals(self, otherNgon: MeshNgon) -> bool: ...
    @overload
    def Equals(self, otherObj: object) -> bool: ...
    @overload
    def FaceIndexList(self) -> Iterable[int]: ...
    @overload
    @property
    def BoundaryVertexCount(self) -> int: ...
    @overload
    @property
    def Empty() -> MeshNgon: ...
    @overload
    @property
    def FaceCount(self) -> int: ...
    @overload
    @property
    def Item(self) -> Sequence[int]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def __eq__(a: MeshNgon, b: MeshNgon) -> bool: ...
    @overload
    def __ne__(a: MeshNgon, b: MeshNgon) -> bool: ...
    @overload
    def Set(self, meshVertexIndexList: Iterable[int], meshFaceIndexList: Iterable[int]) -> None: ...
    @overload
    def ToString(self) -> str: ...


class MeshPart:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def EndFaceIndex(self) -> int: ...
    @overload
    @property
    def EndVertexIndex(self) -> int: ...
    @overload
    @property
    def StartFaceIndex(self) -> int: ...
    @overload
    @property
    def StartVertexIndex(self) -> int: ...
    @overload
    @property
    def TriangleCount(self) -> int: ...
    @overload
    @property
    def VertexCount(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class MeshPipeCapStyle(Enum):
    # None = 0
    Flat = 1
    Box = 2
    Dome = 3


class MeshPoint:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @property
    def EdgeIndex(self) -> int: ...
    @overload
    @property
    def EdgeParameter(self) -> float: ...
    @overload
    @property
    def FaceIndex(self) -> int: ...
    @overload
    @property
    def Mesh(self) -> Mesh: ...
    @overload
    @property
    def Point(self) -> Point3d: ...
    @overload
    @property
    def T(self) -> Iterable[float]: ...
    @overload
    @property
    def Triangle(self) -> Char: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetTriangle(self) -> Tuple[bool, int, int, int]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class MeshThicknessMeasurement:
    @overload
    def __init__(self, meshIndex: int, vertexIndex: int, thickness: float, point: Point3d, oppositePoint: Point3d): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def MeshIndex(self) -> int: ...
    @overload
    @property
    def OppositePoint(self) -> Point3d: ...
    @overload
    @property
    def Point(self) -> Point3d: ...
    @overload
    @property
    def Thickness(self) -> float: ...
    @overload
    @property
    def VertexIndex(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class MeshType(Enum):
    Default = 0
    Render = 1
    Analysis = 2
    Preview = 3
    Any = 4


class MeshUnsafeLock:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def FaceNormalsArray(self) -> Tuple[Vector3f, int]: ...
    @overload
    def FacesArray(self) -> Tuple[MeshFace, int]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def NormalVector3fArray(self) -> Tuple[Vector3f, int]: ...
    @overload
    def Release(self) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def VertexColorsArray(self) -> Tuple[Int32, int]: ...
    @overload
    def VertexPoint3dArray(self) -> Tuple[Point3d, int]: ...
    @overload
    def VertexPoint3fArray(self) -> Tuple[Point3f, int]: ...


class MeshUnwrapMethod(Enum):
    LSCM = 0
    ABFPP = 1
    ARAP = 2


class MeshUnwrapper:
    @overload
    def __init__(self, mesh: Mesh): ...
    @overload
    def __init__(self, meshes: Iterable[Mesh]): ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @SymmetryPlane.setter
    def SymmetryPlane(self, value: Plane) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Unwrap(self, method: MeshUnwrapMethod) -> bool: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class MorphControl(GeometryBase):
    @overload
    def __init__(self, originCurve: NurbsCurve, targetCurve: NurbsCurve): ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Curve(self) -> NurbsCurve: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PreserveStructure(self) -> bool: ...
    @overload
    @property
    def QuickPreview(self) -> bool: ...
    @overload
    @property
    def SpaceMorphTolerance(self) -> float: ...
    @overload
    @property
    def Surface(self) -> NurbsSurface: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Morph(self, geometry: GeometryBase) -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @PreserveStructure.setter
    def PreserveStructure(self, value: bool) -> None: ...
    @overload
    @QuickPreview.setter
    def QuickPreview(self, value: bool) -> None: ...
    @overload
    @SpaceMorphTolerance.setter
    def SpaceMorphTolerance(self, value: float) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


from .Collections import NurbsCurveKnotList
from .Collections import NurbsCurvePointList
from ..Collections import Point3dList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class NurbsCurve(Curve):
    @overload
    def __init__(self, other: NurbsCurve): ...
    @overload
    def __init__(self, degree: int, pointCount: int): ...
    @overload
    def __init__(self, dimension: int, rational: bool, order: int, pointCount: int): ...
    @overload
    def Append(self, nurbsCurve: NurbsCurve) -> bool: ...
    @overload
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    @overload
    def ControlPolygon(self) -> Polyline: ...
    @overload
    def ConvertSpanToBezier(self, spanIndex: int) -> BezierCurve: ...
    @overload
    @staticmethod
    def Create(periodic: bool, degree: int, points: Iterable[Point3d]) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromArc(arc: Arc) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromArc(arc: Arc, degree: int, cvCount: int) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromCircle(circle: Circle) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromCircle(circle: Circle, degree: int, cvCount: int) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromEllipse(ellipse: Ellipse) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromFitPoints(points: Iterable[Point3d], tolerance: float, periodic: bool) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromFitPoints(points: Iterable[Point3d], tolerance: float, degree: int, periodic: bool, startTangent: Vector3d, endTangent: Vector3d) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromLine(line: Line) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateHSpline(points: Iterable[Point3d]) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateHSpline(points: Iterable[Point3d], startTangent: Vector3d, endTangent: Vector3d) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateNonRationalArcBezier(degree: int, center: Point3d, start: Point3d, end: Point3d, radius: float, tanSlider: float, midSlider: float) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateParabolaFromFocus(focus: Point3d, startPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateParabolaFromPoints(startPoint: Point3d, innerPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateParabolaFromVertex(vertex: Point3d, startPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...
    @overload
    def CreatePlanarRailFrames(self, parameters: Iterable[float], normal: Vector3d) -> Iterable[Plane]: ...
    @overload
    def CreateRailFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    @overload
    @staticmethod
    def CreateSpiral(axisStart: Point3d, axisDir: Vector3d, radiusPoint: Point3d, pitch: float, turnCount: float, radius0: float, radius1: float) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSpiral(railCurve: Curve, t0: float, t1: float, radiusPoint: Point3d, pitch: float, turnCount: float, radius0: float, radius1: float, pointsPerTurn: int) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSubDFriendly(curve: Curve) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSubDFriendly(points: Iterable[Point3d], interpolatePoints: bool, periodicClosedCurve: bool) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSubDFriendly(curve: Curve, pointCount: int, periodicClosedCurve: bool) -> NurbsCurve: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateCurve(self) -> Curve: ...
    @overload
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def EpsilonEquals(self, other: NurbsCurve, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    @overload
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    @overload
    def FilletSurfaceToCurve(self, face: BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FilletSurfaceToRail(self, faceWithCurve: BrepFace, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: List, out_breps0: List, out_breps1: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FindLocalInflection(self, N: Vector3d, subDomain: Interval, seed: float) -> Tuple[bool, float, float]: ...
    @overload
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Degree(self) -> int: ...
    @overload
    @property
    def Dimension(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Domain(self) -> Interval: ...
    @overload
    @property
    def HasBezierSpans(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsPeriodic(self) -> bool: ...
    @overload
    @property
    def IsRational(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Knots(self) -> NurbsCurveKnotList: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def Order(self) -> int: ...
    @overload
    @property
    def PointAtEnd(self) -> Point3d: ...
    @overload
    @property
    def PointAtMid(self) -> Point3d: ...
    @overload
    @property
    def PointAtStart(self) -> Point3d: ...
    @overload
    @property
    def Points(self) -> NurbsCurvePointList: ...
    @overload
    @property
    def SpanCount(self) -> int: ...
    @overload
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @overload
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    @overload
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    @overload
    def GetSubCurves(self) -> Iterable[Curve]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def GrevilleParameter(self, index: int) -> float: ...
    @overload
    def GrevilleParameters(self) -> Iterable[float]: ...
    @overload
    def GrevillePoint(self, index: int) -> Point3d: ...
    @overload
    def GrevillePoints(self) -> Point3dList: ...
    @overload
    def GrevillePoints(self, all: bool) -> Point3dList: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def IncreaseDegree(self, desiredDegree: int) -> bool: ...
    @overload
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def InflectionPoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    @staticmethod
    def IsDuplicate(curveA: NurbsCurve, curveB: NurbsCurve, ignoreParameterization: bool, tolerance: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    @overload
    def MakeClosed(self, tolerance: float) -> bool: ...
    @overload
    @staticmethod
    def MakeCompatible(curves: Iterable[Curve], startPt: Point3d, endPt: Point3d, simplifyMethod: int, numPoints: int, refitTolerance: float, angleTolerance: float) -> Iterable[NurbsCurve]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MakePiecewiseBezier(self, setEndWeightsToOne: bool) -> bool: ...
    @overload
    def MatchToCurve(self, targetCurve: Curve, maxEndDistance: float, maxInteriorDistance: float, matchTolerance: float, maxLevel: int) -> NurbsCurve: ...
    @overload
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    @overload
    def MaxCurvaturePoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    @overload
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetTangentToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, length: float) -> Point3d: ...
    @overload
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float, loose: bool) -> Curve: ...
    @overload
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    @overload
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def Reparameterize(self) -> Curve: ...
    @overload
    def Reparameterize(self, c: float) -> bool: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, ribbonParameters: RibbonOffsetParameters) -> Tuple[Curve, Iterable[Curve], Iterable[Curve], Iterable[Brep]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Domain.setter
    def Domain(self, value: Interval) -> None: ...
    @overload
    def SetEndCondition(self, bSetEnd: bool, continuity: NurbsCurveEndConditionType, point: Point3d, tangent: Vector3d) -> bool: ...
    @overload
    def SetEndCondition(self, bSetEnd: bool, continuity: NurbsCurveEndConditionType, point: Point3d, tangent: Vector3d, curvature: Vector3d) -> bool: ...
    @overload
    def SetEndPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetGrevillePoints(self, points: Iterable[Point3d]) -> bool: ...
    @overload
    def SetStartPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    @overload
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def SpanVector(self) -> Iterable[float]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    @overload
    def TorsionAt(self, t: float) -> float: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...
    @overload
    def UVNDirectionsAt(self, t: float) -> Tuple[bool, Vector3d, Vector3d, Vector3d]: ...


class NurbsCurveEndConditionType(Enum):
    Nothing = 0
    Position = 1
    Tangency = 2
    Curvature = 3


from .Collections import NurbsSurfaceKnotList
from .Collections import NurbsSurfacePointList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class NurbsSurface(Surface):
    @overload
    def __init__(self, other: NurbsSurface): ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def ConvertSpanToBezier(self, spanIndex0: int, spanIndex1: int) -> BezierSurface: ...
    @overload
    def CopyFrom(self, other: NurbsSurface) -> None: ...
    @overload
    @staticmethod
    def Create(dimension: int, isRational: bool, order0: int, order1: int, controlPointCount0: int, controlPointCount1: int) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateCurveOnSurface(surface: Surface, points: Iterable[Point2d], tolerance: float, periodic: bool) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateCurveOnSurfacePoints(surface: Surface, fixedPoints: Iterable[Point2d], tolerance: float, periodic: bool, initCount: int, levels: int) -> Iterable[Point2d]: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d, tolerance: float) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromPlane(plane: Plane, uInterval: Interval, vInterval: Interval, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromPoints(points: Iterable[Point3d], uCount: int, vCount: int, uDegree: int, vDegree: int) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromSphere(sphere: Sphere) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromTorus(torus: Torus) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateNetworkSurface(curves: Iterable[Curve], continuity: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    @staticmethod
    def CreateNetworkSurface(uCurves: Iterable[Curve], uContinuityStart: int, uContinuityEnd: int, vCurves: Iterable[Curve], vContinuityStart: int, vContinuityEnd: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    @staticmethod
    def CreateRailRevolvedSurface(profile: Curve, rail: Curve, axis: Line, scaleHeight: bool) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateRuledSurface(curveA: Curve, curveB: Curve) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateSubDFriendly(surface: Surface) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateThroughPoints(points: Iterable[Point3d], uCount: int, vCount: int, uDegree: int, vDegree: int, uClosed: bool, vClosed: bool) -> NurbsSurface: ...
    @overload
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def Degree(self, direction: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def EpsilonEquals(self, other: NurbsSurface, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    @overload
    def FindClosestIsoCurve(self, testPoint: Point3d) -> IsoStatus: ...
    @overload
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    @overload
    def FitCurveToSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], divideIntoSections: bool, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[Iterable[Curve], Curve, Curve]: ...
    @overload
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsRational(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def KnotsU(self) -> NurbsSurfaceKnotList: ...
    @overload
    @property
    def KnotsV(self) -> NurbsSurfaceKnotList: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def OrderU(self) -> int: ...
    @overload
    @property
    def OrderV(self) -> int: ...
    @overload
    @property
    def Points(self) -> NurbsSurfacePointList: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    @overload
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def IncreaseDegreeU(self, desiredDegree: int) -> bool: ...
    @overload
    def IncreaseDegreeV(self, desiredDegree: int) -> bool: ...
    @overload
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    @overload
    def IsAtSeam(self, u: float, v: float) -> int: ...
    @overload
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    @overload
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    @overload
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    @overload
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    @overload
    @staticmethod
    def MakeCompatible(surface0: Surface, surface1: Surface) -> Tuple[bool, NurbsSurface, NurbsSurface]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MakeNonRational(self) -> bool: ...
    @overload
    def MakeRational(self) -> bool: ...
    @overload
    def MatchToCurve(self, side: IsoStatus, targetCurve: Curve, maxEndDistance: float, maxInteriorDistance: float, matchTolerance: float, maxLevel: int) -> NurbsSurface: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    @overload
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def RefitSimplySplitSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, knotAdditionMode: RefitTrimKnotMode, numInsertKnots: int, Knots: Iterable[float], sectionMode: RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Point3d, outputSurface: bool, outputCurve: bool, numSections: int, lowerSurface: List, upperSurface: List, edgeCurve: List, FitMeasurement: float, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[bool, int, float, Curve, Curve]: ...
    @overload
    def RefitSplit(self, curve: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], bMeetCurve: bool, divideIntoSections: bool, srfLower: List, srfUpper: List, edgeCurve: List, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[int, Curve, Curve]: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    @overload
    def SpanCount(self, direction: int) -> int: ...
    @overload
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    @overload
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def UVNDirectionsAt(self, u: float, v: float) -> Tuple[bool, Vector3d, Vector3d, Vector3d]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


class NurbsSurfaceType(Enum):
    Unset = 0
    Large = 1
    Medium = 2
    Small = 3
    Unprocessed = 4


from ..DocObjects import DimensionStyle
from ..DocObjects import ViewportInfo
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ArrowType
from ..DocObjects import ZeroSuppression
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class OrdinateDimension(Dimension):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float): ...
    @overload
    def AdjustFromPoints(self, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float) -> bool: ...
    @overload
    def ClearPropertyOverrides(self) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(dimStyle: DimensionStyle, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float) -> OrdinateDimension: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Explode(self) -> Iterable[GeometryBase]: ...
    @overload
    @property
    def AlternateBelowLine(self) -> bool: ...
    @overload
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def AltLengthFactor(self) -> float: ...
    @overload
    @property
    def AltLengthResolution(self) -> int: ...
    @overload
    @property
    def AltLengthRoundoff(self) -> float: ...
    @overload
    @property
    def AltPrefix(self) -> str: ...
    @overload
    @property
    def AltSuffix(self) -> str: ...
    @overload
    @property
    def AltToleranceResolution(self) -> int: ...
    @overload
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @overload
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @overload
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @overload
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @overload
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @overload
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @overload
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @overload
    @property
    def ArrowSize(self) -> float: ...
    @overload
    @property
    def BaselineSpacing(self) -> float: ...
    @overload
    @property
    def CentermarkSize(self) -> float: ...
    @overload
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @overload
    @property
    def DecimalSeparator(self) -> Char: ...
    @overload
    @property
    def DefPoint(self) -> Point2d: ...
    @overload
    @property
    def DetailMeasured(self) -> Guid: ...
    @overload
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def DimensionLineExtension(self) -> float: ...
    @overload
    @property
    def DimensionScale(self) -> float: ...
    @overload
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def DimensionStyleId(self) -> Guid: ...
    @overload
    @property
    def Direction(self) -> MeasuredDirection: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def DistanceScale(self) -> float: ...
    @overload
    @property
    def DrawForward(self) -> bool: ...
    @overload
    @property
    def DrawTextFrame(self) -> bool: ...
    @overload
    @property
    def ExtensionLineExtension(self) -> float: ...
    @overload
    @property
    def ExtensionLineOffset(self) -> float: ...
    @overload
    @property
    def FirstCharFont(self) -> Font: ...
    @overload
    @property
    def FixedExtensionLength(self) -> float: ...
    @overload
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @overload
    @property
    def Font(self) -> Font: ...
    @overload
    @property
    def FontIndex(self) -> int: ...
    @overload
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @overload
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @overload
    @property
    def ForceDimLine(self) -> bool: ...
    @overload
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @overload
    @property
    def FormatWidth(self) -> float: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def KinkOffset1(self) -> float: ...
    @overload
    @property
    def KinkOffset2(self) -> float: ...
    @overload
    @property
    def KinkPoint1(self) -> Point2d: ...
    @overload
    @property
    def KinkPoint2(self) -> Point2d: ...
    @overload
    @property
    def LeaderPoint(self) -> Point2d: ...
    @overload
    @property
    def LengthFactor(self) -> float: ...
    @overload
    @property
    def LengthResolution(self) -> int: ...
    @overload
    @property
    def LengthRoundoff(self) -> float: ...
    @overload
    @property
    def MaskColor(self) -> Color: ...
    @overload
    @property
    def MaskColorSource(self) -> MaskType: ...
    @overload
    @property
    def MaskEnabled(self) -> bool: ...
    @overload
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @overload
    @property
    def MaskOffset(self) -> float: ...
    @overload
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @overload
    @property
    def NumericValue(self) -> float: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def PlainText(self) -> str: ...
    @overload
    @property
    def PlainTextWithFields(self) -> str: ...
    @overload
    @property
    def PlainUserText(self) -> str: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Prefix(self) -> str: ...
    @overload
    @property
    def RichText(self) -> str: ...
    @overload
    @property
    def Suffix(self) -> str: ...
    @overload
    @property
    def SuppressExtension1(self) -> bool: ...
    @overload
    @property
    def SuppressExtension2(self) -> bool: ...
    @overload
    @property
    def Text(self) -> str: ...
    @overload
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @overload
    @property
    def TextFit(self) -> TextFit: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @overload
    @property
    def TextHeight(self) -> float: ...
    @overload
    @property
    def TextIsWrapped(self) -> bool: ...
    @overload
    @property
    def TextLocation(self) -> TextLocation: ...
    @overload
    @property
    def TextModelWidth(self) -> float: ...
    @overload
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @overload
    @property
    def TextPosition(self) -> Point2d: ...
    @overload
    @property
    def TextRotation(self) -> float: ...
    @overload
    @property
    def TextRotationDegrees(self) -> float: ...
    @overload
    @property
    def TextRotationRadians(self) -> float: ...
    @overload
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @overload
    @property
    def ToleranceHeightScale(self) -> float: ...
    @overload
    @property
    def ToleranceLowerValue(self) -> float: ...
    @overload
    @property
    def ToleranceResolution(self) -> int: ...
    @overload
    @property
    def ToleranceUpperValue(self) -> float: ...
    @overload
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d, Point3d]: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    @overload
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Iterable[Any]]: ...
    @overload
    def GetDistanceDisplayText(self, unitsystem: UnitSystem, style: DimensionStyle) -> str: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    @overload
    def GetTextRectangle(self) -> Tuple[bool, Iterable[Point3d]]: ...
    @overload
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsAllBold(self) -> bool: ...
    @overload
    def IsAllItalic(self) -> bool: ...
    @overload
    def IsAllUnderlined(self) -> bool: ...
    @overload
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @AlternateBelowLine.setter
    def AlternateBelowLine(self, value: bool) -> None: ...
    @overload
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @AltLengthFactor.setter
    def AltLengthFactor(self, value: float) -> None: ...
    @overload
    @AltLengthResolution.setter
    def AltLengthResolution(self, value: int) -> None: ...
    @overload
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self, value: float) -> None: ...
    @overload
    @AltPrefix.setter
    def AltPrefix(self, value: str) -> None: ...
    @overload
    @AltSuffix.setter
    def AltSuffix(self, value: str) -> None: ...
    @overload
    @AltToleranceResolution.setter
    def AltToleranceResolution(self, value: int) -> None: ...
    @overload
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self, value: bool) -> None: ...
    @overload
    @AltZeroSuppression.setter
    def AltZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    @ArrowBlockId1.setter
    def ArrowBlockId1(self, value: Guid) -> None: ...
    @overload
    @ArrowBlockId2.setter
    def ArrowBlockId2(self, value: Guid) -> None: ...
    @overload
    @ArrowFit.setter
    def ArrowFit(self, value: ArrowFit) -> None: ...
    @overload
    @ArrowheadType1.setter
    def ArrowheadType1(self, value: ArrowType) -> None: ...
    @overload
    @ArrowheadType2.setter
    def ArrowheadType2(self, value: ArrowType) -> None: ...
    @overload
    @ArrowSize.setter
    def ArrowSize(self, value: float) -> None: ...
    @overload
    @BaselineSpacing.setter
    def BaselineSpacing(self, value: float) -> None: ...
    @overload
    @CentermarkSize.setter
    def CentermarkSize(self, value: float) -> None: ...
    @overload
    @CentermarkStyle.setter
    def CentermarkStyle(self, value: CenterMarkStyle) -> None: ...
    @overload
    @DecimalSeparator.setter
    def DecimalSeparator(self, value: Char) -> None: ...
    @overload
    @DefPoint.setter
    def DefPoint(self, value: Point2d) -> None: ...
    @overload
    @DetailMeasured.setter
    def DetailMeasured(self, value: Guid) -> None: ...
    @overload
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DimensionLineExtension.setter
    def DimensionLineExtension(self, value: float) -> None: ...
    @overload
    @DimensionScale.setter
    def DimensionScale(self, value: float) -> None: ...
    @overload
    @DimensionStyleId.setter
    def DimensionStyleId(self, value: Guid) -> None: ...
    @overload
    @Direction.setter
    def Direction(self, value: MeasuredDirection) -> None: ...
    @overload
    @DistanceScale.setter
    def DistanceScale(self, value: float) -> None: ...
    @overload
    @DrawForward.setter
    def DrawForward(self, value: bool) -> None: ...
    @overload
    @DrawTextFrame.setter
    def DrawTextFrame(self, value: bool) -> None: ...
    @overload
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self, value: float) -> None: ...
    @overload
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self, value: float) -> None: ...
    @overload
    @FixedExtensionLength.setter
    def FixedExtensionLength(self, value: float) -> None: ...
    @overload
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self, value: bool) -> None: ...
    @overload
    @Font.setter
    def Font(self, value: Font) -> None: ...
    @overload
    @FontIndex.setter
    def FontIndex(self, value: int) -> None: ...
    @overload
    @ForceArrowPosition.setter
    def ForceArrowPosition(self, value: ForceArrow) -> None: ...
    @overload
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self, value: bool) -> None: ...
    @overload
    @ForceDimLine.setter
    def ForceDimLine(self, value: bool) -> None: ...
    @overload
    @ForceTextPosition.setter
    def ForceTextPosition(self, value: ForceText) -> None: ...
    @overload
    @FormatWidth.setter
    def FormatWidth(self, value: float) -> None: ...
    @overload
    @KinkOffset1.setter
    def KinkOffset1(self, value: float) -> None: ...
    @overload
    @KinkOffset2.setter
    def KinkOffset2(self, value: float) -> None: ...
    @overload
    @LeaderPoint.setter
    def LeaderPoint(self, value: Point2d) -> None: ...
    @overload
    @LengthFactor.setter
    def LengthFactor(self, value: float) -> None: ...
    @overload
    @LengthResolution.setter
    def LengthResolution(self, value: int) -> None: ...
    @overload
    @LengthRoundoff.setter
    def LengthRoundoff(self, value: float) -> None: ...
    @overload
    @MaskColor.setter
    def MaskColor(self, value: Color) -> None: ...
    @overload
    @MaskColorSource.setter
    def MaskColorSource(self, value: MaskType) -> None: ...
    @overload
    @MaskEnabled.setter
    def MaskEnabled(self, value: bool) -> None: ...
    @overload
    @MaskFrame.setter
    def MaskFrame(self, value: MaskFrame) -> None: ...
    @overload
    @MaskOffset.setter
    def MaskOffset(self, value: float) -> None: ...
    @overload
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self, value: bool) -> None: ...
    @overload
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self, value: DimensionStyle) -> None: ...
    @overload
    @PlainText.setter
    def PlainText(self, value: str) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @Prefix.setter
    def Prefix(self, value: str) -> None: ...
    @overload
    @RichText.setter
    def RichText(self, value: str) -> None: ...
    @overload
    @Suffix.setter
    def Suffix(self, value: str) -> None: ...
    @overload
    @SuppressExtension1.setter
    def SuppressExtension1(self, value: bool) -> None: ...
    @overload
    @SuppressExtension2.setter
    def SuppressExtension2(self, value: bool) -> None: ...
    @overload
    @Text.setter
    def Text(self, value: str) -> None: ...
    @overload
    @TextAngleType.setter
    def TextAngleType(self, value: LeaderContentAngleStyle) -> None: ...
    @overload
    @TextFit.setter
    def TextFit(self, value: TextFit) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextHeight.setter
    def TextHeight(self, value: float) -> None: ...
    @overload
    @TextIsWrapped.setter
    def TextIsWrapped(self, value: bool) -> None: ...
    @overload
    @TextLocation.setter
    def TextLocation(self, value: TextLocation) -> None: ...
    @overload
    @TextOrientation.setter
    def TextOrientation(self, value: TextOrientation) -> None: ...
    @overload
    @TextPosition.setter
    def TextPosition(self, value: Point2d) -> None: ...
    @overload
    @TextRotation.setter
    def TextRotation(self, value: float) -> None: ...
    @overload
    @TextRotationDegrees.setter
    def TextRotationDegrees(self, value: float) -> None: ...
    @overload
    @TextRotationRadians.setter
    def TextRotationRadians(self, value: float) -> None: ...
    @overload
    @ToleranceFormat.setter
    def ToleranceFormat(self, value: ToleranceDisplayFormat) -> None: ...
    @overload
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self, value: float) -> None: ...
    @overload
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self, value: float) -> None: ...
    @overload
    @ToleranceResolution.setter
    def ToleranceResolution(self, value: int) -> None: ...
    @overload
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self, value: float) -> None: ...
    @overload
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self, value: bool) -> None: ...
    @overload
    @ZeroSuppression.setter
    def ZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetBold(self, set_on: bool) -> bool: ...
    @overload
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    @overload
    def SetItalic(self, set_on: bool) -> bool: ...
    @overload
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    @overload
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    @overload
    def SetUnderline(self, set_on: bool) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    @overload
    def WrapText(self) -> None: ...


class Particle:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Color(self) -> Color: ...
    @overload
    @property
    def DisplayBitmapIndex(self) -> int: ...
    @overload
    @property
    def Index(self) -> int: ...
    @overload
    @property
    def Location(self) -> Point3d: ...
    @overload
    @property
    def ParentSystem(self) -> ParticleSystem: ...
    @overload
    @property
    def Size(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @Color.setter
    def Color(self, value: Color) -> None: ...
    @overload
    @DisplayBitmapIndex.setter
    def DisplayBitmapIndex(self, value: int) -> None: ...
    @overload
    @Location.setter
    def Location(self, value: Point3d) -> None: ...
    @overload
    @Size.setter
    def Size(self, value: float) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Update(self) -> None: ...


class ParticleSystem:
    @overload
    def __init__(self): ...
    def __iter__(self) -> Iterator[Particle]: ...
    @overload
    def Add(self, particle: Particle) -> bool: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def DisplaySizesInWorldUnits(self) -> bool: ...
    @overload
    @property
    def DrawRequiresDepthSorting(self) -> bool: ...
    @overload
    def GetEnumerator(self) -> Iterator[Particle]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Remove(self, particle: Particle) -> None: ...
    @overload
    @DisplaySizesInWorldUnits.setter
    def DisplaySizesInWorldUnits(self, value: bool) -> None: ...
    @overload
    @DrawRequiresDepthSorting.setter
    def DrawRequiresDepthSorting(self, value: bool) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Update(self) -> None: ...


class PipeCapMode(Enum):
    # None = 0
    Flat = 1
    Round = 2


class Plane:
    @overload
    def __init__(self, other: Plane): ...
    @overload
    def __init__(self, origin: Point3d, normal: Vector3d): ...
    @overload
    def __init__(self, origin: Point3d, xDirection: Vector3d, yDirection: Vector3d): ...
    @overload
    def __init__(self, origin: Point3d, xPoint: Point3d, yPoint: Point3d): ...
    @overload
    def __init__(self, a: float, b: float, c: float, d: float): ...
    @overload
    def Clone(self) -> Plane: ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    @staticmethod
    def CreateFromFrame(origin: Point3d, xDirection: Vector3d, yDirection: Vector3d) -> Plane: ...
    @overload
    @staticmethod
    def CreateFromNormal(origin: Point3d, normal: Vector3d) -> Plane: ...
    @overload
    @staticmethod
    def CreateFromNormalYup(origin: Point3d, normal: Vector3d, yDirection: Vector3d) -> Plane: ...
    @overload
    @staticmethod
    def CreateFromPoints(origin: Point3d, xPoint: Point3d, yPoint: Point3d) -> Plane: ...
    @overload
    def DistanceTo(self, testPoint: Point3d) -> float: ...
    @overload
    def DistanceTo(self, bbox: BoundingBox) -> Tuple[bool, float, float]: ...
    @overload
    def EpsilonEquals(self, other: Plane, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, plane: Plane) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox) -> Tuple[bool, Interval, Interval]: ...
    @overload
    def ExtendThroughBox(self, box: Box) -> Tuple[bool, Interval, Interval]: ...
    @overload
    @staticmethod
    def FitPlaneToPoints(points: Iterable[Point3d]) -> Tuple[PlaneFitResult, Plane]: ...
    @overload
    @staticmethod
    def FitPlaneToPoints(points: Iterable[Point3d]) -> Tuple[PlaneFitResult, Plane, float]: ...
    @overload
    def Flip(self) -> None: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Normal(self) -> Vector3d: ...
    @overload
    @property
    def Origin(self) -> Point3d: ...
    @overload
    @property
    def OriginX(self) -> float: ...
    @overload
    @property
    def OriginY(self) -> float: ...
    @overload
    @property
    def OriginZ(self) -> float: ...
    @overload
    @property
    def Unset() -> Plane: ...
    @overload
    @property
    def WorldXY() -> Plane: ...
    @overload
    @property
    def WorldYZ() -> Plane: ...
    @overload
    @property
    def WorldZX() -> Plane: ...
    @overload
    @property
    def XAxis(self) -> Vector3d: ...
    @overload
    @property
    def YAxis(self) -> Vector3d: ...
    @overload
    @property
    def ZAxis(self) -> Vector3d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetPlaneEquation(self) -> Iterable[float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IsCoplanar(self, plane: Plane) -> bool: ...
    @overload
    def IsCoplanar(self, plane: Plane, tolerance: float) -> bool: ...
    @overload
    def __eq__(a: Plane, b: Plane) -> bool: ...
    @overload
    def __ne__(a: Plane, b: Plane) -> bool: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def PointAt(self, u: float, v: float, w: float) -> Point3d: ...
    @overload
    def RemapToPlaneSpace(self, ptSample: Point3d) -> Tuple[bool, Point3d]: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @overload
    @Origin.setter
    def Origin(self, value: Point3d) -> None: ...
    @overload
    @OriginX.setter
    def OriginX(self, value: float) -> None: ...
    @overload
    @OriginY.setter
    def OriginY(self, value: float) -> None: ...
    @overload
    @OriginZ.setter
    def OriginZ(self, value: float) -> None: ...
    @overload
    @XAxis.setter
    def XAxis(self, value: Vector3d) -> None: ...
    @overload
    @YAxis.setter
    def YAxis(self, value: Vector3d) -> None: ...
    @overload
    @ZAxis.setter
    def ZAxis(self, value: Vector3d) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, delta: Vector3d) -> bool: ...
    @overload
    def UpdateEquation(self) -> bool: ...
    @overload
    def ValueAt(self, p: Point3d) -> float: ...


class PlaneFitResult(Enum):
    Success = 0
    Inconclusive = 1
    Failure = -1


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class PlaneSurface(Surface):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, plane: Plane): ...
    @overload
    def __init__(self, plane: Plane, xExtents: Interval, yExtents: Interval): ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def CreateThroughBox(plane: Plane, box: BoundingBox) -> PlaneSurface: ...
    @overload
    @staticmethod
    def CreateThroughBox(lineInPlane: Line, vectorInPlane: Vector3d, box: BoundingBox) -> PlaneSurface: ...
    @overload
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def Degree(self, direction: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    @overload
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    @overload
    def FitCurveToSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], divideIntoSections: bool, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[Iterable[Curve], Curve, Curve]: ...
    @overload
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetExtents(self, direction: int) -> Interval: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    @overload
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    @overload
    def IsAtSeam(self, u: float, v: float) -> int: ...
    @overload
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    @overload
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    @overload
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    @overload
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    @overload
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def RefitSimplySplitSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, knotAdditionMode: RefitTrimKnotMode, numInsertKnots: int, Knots: Iterable[float], sectionMode: RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Point3d, outputSurface: bool, outputCurve: bool, numSections: int, lowerSurface: List, upperSurface: List, edgeCurve: List, FitMeasurement: float, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[bool, int, float, Curve, Curve]: ...
    @overload
    def RefitSplit(self, curve: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], bMeetCurve: bool, divideIntoSections: bool, srfLower: List, srfUpper: List, edgeCurve: List, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[int, Curve, Curve]: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    @overload
    def SetExtents(self, direction: int, extents: Interval, syncDomain: bool) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    @overload
    def SpanCount(self, direction: int) -> int: ...
    @overload
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToMesh(self) -> Mesh: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    @overload
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Point(GeometryBase):
    @overload
    def __init__(self, location: Point3d): ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Location(self) -> Point3d: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Location.setter
    def Location(self, value: Point3d) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class Point2d:
    @overload
    def __init__(self, vector: Vector2d): ...
    @overload
    def __init__(self, point: Point2d): ...
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, x: float, y: float): ...
    @overload
    @staticmethod
    def Add(point1: Point2d, point2: Point2d) -> Point2d: ...
    @overload
    @staticmethod
    def Add(vector: Vector2d, point: Point2d) -> Point2d: ...
    @overload
    @staticmethod
    def Add(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    def CompareTo(self, other: Point2d) -> int: ...
    @overload
    def DistanceTo(self, other: Point2d) -> float: ...
    @overload
    def DistanceToSquared(self, other: Point2d) -> float: ...
    @overload
    @staticmethod
    def Divide(point: Point2d, t: float) -> Point2d: ...
    @overload
    def EpsilonEquals(self, other: Point2d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, point: Point2d) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @overload
    @property
    def MaximumCoordinate(self) -> float: ...
    @overload
    @property
    def MinimumCoordinate(self) -> float: ...
    @overload
    @property
    def Origin() -> Point2d: ...
    @overload
    @property
    def Unset() -> Point2d: ...
    @overload
    @property
    def X(self) -> float: ...
    @overload
    @property
    def Y(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Multiply(point: Point2d, t: float) -> Point2d: ...
    @overload
    @staticmethod
    def Multiply(t: float, point: Point2d) -> Point2d: ...
    @overload
    def __add__(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    def __radd__(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    def __add__(point1: Point2d, point2: Point2d) -> Point2d: ...
    @overload
    def __truediv__(point: Point2d, t: float) -> Point2d: ...
    @overload
    def __eq__(a: Point2d, b: Point2d) -> bool: ...
    @overload
    def __gt__(a: Point2d, b: Point2d) -> bool: ...
    @overload
    def __ge__(a: Point2d, b: Point2d) -> bool: ...
    @overload
    def __ne__(a: Point2d, b: Point2d) -> bool: ...
    @overload
    def __lt__(a: Point2d, b: Point2d) -> bool: ...
    @overload
    def __le__(a: Point2d, b: Point2d) -> bool: ...
    @overload
    def __rmul__(point: Point2d, t: float) -> Point2d: ...
    @overload
    def __mul__(point: Point2d, t: float) -> Point2d: ...
    @overload
    def __sub__(point1: Point2d, point2: Point2d) -> Vector2d: ...
    @overload
    def __sub__(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    @property
    def Item(self) -> MutableSequence[float]: ...
    @overload
    @X.setter
    def X(self, value: float) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    @staticmethod
    def Subtract(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    @staticmethod
    def Subtract(point1: Point2d, point2: Point2d) -> Vector2d: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...


class Point2f:
    @overload
    def __init__(self, x: float, y: float): ...
    @overload
    def __init__(self, x: float, y: float): ...
    @overload
    def CompareTo(self, other: Point2f) -> int: ...
    @overload
    def DistanceTo(self, other: Point2f) -> float: ...
    @overload
    def DistanceToSquared(self, other: Point2f) -> float: ...
    @overload
    def EpsilonEquals(self, other: Point2f, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, point: Point2f) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @overload
    @property
    def Unset() -> Point2f: ...
    @overload
    @property
    def X(self) -> float: ...
    @overload
    @property
    def Y(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def __add__(a: Point2f, b: Point2f) -> Vector2f: ...
    @overload
    def __truediv__(a: Point2f, b: float) -> Point2f: ...
    @overload
    def __eq__(a: Point2f, b: Point2f) -> bool: ...
    @overload
    def op_Explicit(point: Point2d) -> Point2f: ...
    @overload
    def __gt__(a: Point2f, b: Point2f) -> bool: ...
    @overload
    def __ge__(a: Point2f, b: Point2f) -> bool: ...
    @overload
    def __ne__(a: Point2f, b: Point2f) -> bool: ...
    @overload
    def __lt__(a: Point2f, b: Point2f) -> bool: ...
    @overload
    def __le__(a: Point2f, b: Point2f) -> bool: ...
    @overload
    def __mul__(a: Point2f, b: float) -> Point2f: ...
    @overload
    def __sub__(a: Point2f, b: Point2f) -> Vector2f: ...
    @overload
    @property
    def Item(self) -> MutableSequence[float]: ...
    @overload
    @X.setter
    def X(self, value: float) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...


class Point3d:
    @overload
    def __init__(self, vector: Vector3d): ...
    @overload
    def __init__(self, point: Point3f): ...
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, point: Point4d): ...
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    @staticmethod
    def Add(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    @staticmethod
    def Add(vector: Vector3d, point: Point3d) -> Point3d: ...
    @overload
    @staticmethod
    def Add(point1: Point3d, point2: Point3d) -> Point3d: ...
    @overload
    @staticmethod
    def Add(point: Point3d, vector: Vector3f) -> Point3d: ...
    @overload
    @staticmethod
    def ArePointsCoplanar(points: Iterable[Point3d], tolerance: float) -> bool: ...
    @overload
    def CompareTo(self, other: Point3d) -> int: ...
    @overload
    @staticmethod
    def CullDuplicates(points: Iterable[Point3d], tolerance: float) -> Iterable[Point3d]: ...
    @overload
    def DistanceTo(self, other: Point3d) -> float: ...
    @overload
    def DistanceToSquared(self, other: Point3d) -> float: ...
    @overload
    @staticmethod
    def Divide(point: Point3d, t: float) -> Point3d: ...
    @overload
    def EpsilonEquals(self, other: Point3d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, point: Point3d) -> bool: ...
    @overload
    @staticmethod
    def FromPoint3f(point: Point3f) -> Point3d: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @overload
    @property
    def MaximumCoordinate(self) -> float: ...
    @overload
    @property
    def MinimumCoordinate(self) -> float: ...
    @overload
    @property
    def Origin() -> Point3d: ...
    @overload
    @property
    def Unset() -> Point3d: ...
    @overload
    @property
    def X(self) -> float: ...
    @overload
    @property
    def Y(self) -> float: ...
    @overload
    @property
    def Z(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Interpolate(self, pA: Point3d, pB: Point3d, t: float) -> None: ...
    @overload
    @staticmethod
    def Multiply(t: float, point: Point3d) -> Point3d: ...
    @overload
    @staticmethod
    def Multiply(point: Point3d, t: float) -> Point3d: ...
    @overload
    def __add__(point: Point3d, vector: Vector3f) -> Point3d: ...
    @overload
    def __add__(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    def __add__(point1: Point3d, point2: Point3d) -> Point3d: ...
    @overload
    def __radd__(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    def __truediv__(point: Point3d, t: float) -> Point3d: ...
    @overload
    def __eq__(a: Point3d, b: Point3d) -> bool: ...
    @overload
    def op_Explicit(vector: Vector3d) -> Point3d: ...
    @overload
    def op_Explicit(point: Point3d) -> Vector3d: ...
    @overload
    def __gt__(a: Point3d, b: Point3d) -> bool: ...
    @overload
    def __ge__(a: Point3d, b: Point3d) -> bool: ...
    @overload
    def op_Implicit(pt: Point3d) -> ControlPoint: ...
    @overload
    def op_Implicit(point: Point3f) -> Point3d: ...
    @overload
    def __ne__(a: Point3d, b: Point3d) -> bool: ...
    @overload
    def __lt__(a: Point3d, b: Point3d) -> bool: ...
    @overload
    def __le__(a: Point3d, b: Point3d) -> bool: ...
    @overload
    def __rmul__(point: Point3d, t: float) -> Point3d: ...
    @overload
    def __mul__(point: Point3d, t: float) -> Point3d: ...
    @overload
    def __sub__(point1: Point3d, point2: Point3d) -> Vector3d: ...
    @overload
    def __sub__(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    def __neg__(point: Point3d) -> Point3d: ...
    @overload
    @property
    def Item(self) -> MutableSequence[float]: ...
    @overload
    @X.setter
    def X(self, value: float) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    @Z.setter
    def Z(self, value: float) -> None: ...
    @overload
    @staticmethod
    def SortAndCullPointList(points: Iterable[Point3d], minimumDistance: float) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def Subtract(point1: Point3d, point2: Point3d) -> Vector3d: ...
    @overload
    @staticmethod
    def Subtract(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...
    @overload
    @staticmethod
    def TryParse(input: str) -> Tuple[bool, Point3d]: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Point3dGrid(GeometryBase):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, rows: int, columns: int): ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class Point3f:
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    def CompareTo(self, other: Point3f) -> int: ...
    @overload
    def DistanceTo(self, other: Point3f) -> float: ...
    @overload
    def DistanceToSquared(self, other: Point3f) -> float: ...
    @overload
    def EpsilonEquals(self, other: Point3f, epsilon: float) -> bool: ...
    @overload
    def Equals(self, point: Point3f) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Origin() -> Point3f: ...
    @overload
    @property
    def Unset() -> Point3f: ...
    @overload
    @property
    def X(self) -> float: ...
    @overload
    @property
    def Y(self) -> float: ...
    @overload
    @property
    def Z(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def __add__(point1: Point3f, point2: Point3f) -> Point3f: ...
    @overload
    def __eq__(a: Point3f, b: Point3f) -> bool: ...
    @overload
    def op_Explicit(point: Point3f) -> Vector3f: ...
    @overload
    def op_Explicit(point: Point3d) -> Point3f: ...
    @overload
    def __gt__(a: Point3f, b: Point3f) -> bool: ...
    @overload
    def __ge__(a: Point3f, b: Point3f) -> bool: ...
    @overload
    def __ne__(a: Point3f, b: Point3f) -> bool: ...
    @overload
    def __lt__(a: Point3f, b: Point3f) -> bool: ...
    @overload
    def __le__(a: Point3f, b: Point3f) -> bool: ...
    @overload
    def __rmul__(point: Point3f, value: float) -> Point3f: ...
    @overload
    def __mul__(point: Point3f, value: float) -> Point3f: ...
    @overload
    def __sub__(point1: Point3f, point2: Point3f) -> Vector3f: ...
    @overload
    @X.setter
    def X(self, value: float) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    @Z.setter
    def Z(self, value: float) -> None: ...
    @overload
    @staticmethod
    def Subtract(point1: Point3f, point2: Point3f) -> Vector3f: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...


class Point4d:
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, point: Point4d): ...
    @overload
    def __init__(self, x: float, y: float, z: float, w: float): ...
    @overload
    @staticmethod
    def Add(point1: Point4d, point2: Point4d) -> Point4d: ...
    @overload
    def EpsilonEquals(self, other: Point4d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, point: Point4d) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Unset() -> Point4d: ...
    @overload
    @property
    def W(self) -> float: ...
    @overload
    @property
    def X(self) -> float: ...
    @overload
    @property
    def Y(self) -> float: ...
    @overload
    @property
    def Z(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Multiply(point: Point4d, d: float) -> Point4d: ...
    @overload
    def __add__(point1: Point4d, point2: Point4d) -> Point4d: ...
    @overload
    def __eq__(a: Point4d, b: Point4d) -> bool: ...
    @overload
    def __ne__(a: Point4d, b: Point4d) -> bool: ...
    @overload
    def __mul__(point: Point4d, d: float) -> Point4d: ...
    @overload
    def __mul__(point1: Point4d, point2: Point4d) -> float: ...
    @overload
    def __sub__(point1: Point4d, point2: Point4d) -> Point4d: ...
    @overload
    @W.setter
    def W(self, value: float) -> None: ...
    @overload
    @X.setter
    def X(self, value: float) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    @Z.setter
    def Z(self, value: float) -> None: ...
    @overload
    @staticmethod
    def Subtract(point1: Point4d, point2: Point4d) -> Point4d: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class PointCloud(GeometryBase):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: PointCloud): ...
    @overload
    def __init__(self, points: Iterable[Point3d]): ...
    def __iter__(self) -> Iterator[PointCloudItem]: ...
    @overload
    def Add(self, point: Point3d) -> None: ...
    @overload
    def Add(self, point: Point3d, color: Color) -> None: ...
    @overload
    def Add(self, point: Point3d, normal: Vector3d) -> None: ...
    @overload
    def Add(self, point: Point3d, normal: Vector3d, color: Color) -> None: ...
    @overload
    def Add(self, point: Point3d, normal: Vector3d, color: Color, value: float) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d]) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d], colors: Iterable[Color]) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d], normals: Iterable[Vector3d]) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d], normals: Iterable[Vector3d], colors: Iterable[Color]) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d], normals: Iterable[Vector3d], colors: Iterable[Color], values: Iterable[float]) -> None: ...
    @overload
    def AppendNew(self) -> PointCloudItem: ...
    @overload
    def AsReadOnlyListOfPoints(self) -> IReadOnlyList: ...
    @overload
    def ClearColors(self) -> None: ...
    @overload
    def ClearHiddenFlags(self) -> None: ...
    @overload
    def ClearNormals(self) -> None: ...
    @overload
    def ClearPointValues(self) -> None: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> int: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def CreateContourCurves(self, contourStart: Point3d, contourEnd: Point3d, interval: float, absoluteTolerance: float) -> Iterable[Curve]: ...
    @overload
    def CreateContourCurves(self, startPoint: Point3d, endPoint: Point3d, interval: float, absoluteTolerance: float, maxDistance: float, minDistance: float, openCurves: bool, createSpline: bool, createPolyline: bool, fitTolerance: float) -> Iterable[Curve]: ...
    @overload
    def CreateSectionCurve(self, plane: Plane, absoluteTolerance: float) -> Iterable[Curve]: ...
    @overload
    def CreateSectionCurve(self, plane: Plane, absoluteTolerance: float, maxDistance: float, minDistance: float, openCurves: bool, createSpline: bool, createPolyline: bool, fitTolerance: float) -> Iterable[Curve]: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ContainsColors(self) -> bool: ...
    @overload
    @property
    def ContainsHiddenFlags(self) -> bool: ...
    @overload
    @property
    def ContainsNormals(self) -> bool: ...
    @overload
    @property
    def ContainsPointValues(self) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def HiddenPointCount(self) -> int: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Item(self) -> Sequence[PointCloudItem]: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetColors(self) -> Iterable[Color]: ...
    @overload
    def GetEnumerator(self) -> Iterator[PointCloudItem]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetNormals(self) -> Iterable[Vector3d]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPoints(self) -> Iterable[Point3d]: ...
    @overload
    def GetPointValues(self) -> Iterable[float]: ...
    @overload
    def GetRandomSubsample(self, numberOfPoints: int) -> PointCloud: ...
    @overload
    def GetRandomSubsample(self, numberOfPoints: int, cancelToken: CancellationToken, progress: IProgress) -> PointCloud: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUnsafeLock(self, writable: bool) -> PointCloudUnsafeLock: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def Insert(self, index: int, point: Point3d) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, color: Color) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, normal: Vector3d) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, normal: Vector3d, color: Color) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, normal: Vector3d, color: Color, value: float) -> None: ...
    @overload
    def InsertNew(self, index: int) -> PointCloudItem: ...
    @overload
    def InsertRange(self, index: int, points: Iterable[Point3d]) -> None: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Merge(self, other: PointCloud) -> None: ...
    @overload
    def PointAt(self, index: int) -> Point3d: ...
    @overload
    def ReleaseUnsafeLock(self, pointCloudData: PointCloudUnsafeLock) -> None: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RemoveRange(self, indices: Iterable[int]) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ShrinkWrap(self, parameters: ShrinkWrapParameters) -> Mesh: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


class PointCloudItem:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Color(self) -> Color: ...
    @overload
    @property
    def Hidden(self) -> bool: ...
    @overload
    @property
    def Index(self) -> int: ...
    @overload
    @property
    def Location(self) -> Point3d: ...
    @overload
    @property
    def Normal(self) -> Vector3d: ...
    @overload
    @property
    def PointValue(self) -> float: ...
    @overload
    @property
    def X(self) -> float: ...
    @overload
    @property
    def Y(self) -> float: ...
    @overload
    @property
    def Z(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @Color.setter
    def Color(self, value: Color) -> None: ...
    @overload
    @Hidden.setter
    def Hidden(self, value: bool) -> None: ...
    @overload
    @Location.setter
    def Location(self, value: Point3d) -> None: ...
    @overload
    @Normal.setter
    def Normal(self, value: Vector3d) -> None: ...
    @overload
    @PointValue.setter
    def PointValue(self, value: float) -> None: ...
    @overload
    @X.setter
    def X(self, value: float) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    @Z.setter
    def Z(self, value: float) -> None: ...
    @overload
    def ToString(self) -> str: ...


class PointCloudUnsafeLock:
    @overload
    def ColorArray(self) -> Tuple[Int32, int]: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def NormalArray(self) -> Tuple[Vector3d, int]: ...
    @overload
    def PointArray(self) -> Tuple[Point3d, int]: ...
    @overload
    def Release(self) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ValueArray(self) -> Tuple[Double, int]: ...


class PointContainment(Enum):
    Unset = 0
    Inside = 1
    Outside = 2
    Coincident = 3


class PointFaceRelation(Enum):
    Exterior = 0
    Interior = 1
    Boundary = 2


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class PolyCurve(Curve):
    @overload
    def __init__(self): ...
    @overload
    def Append(self, line: Line) -> bool: ...
    @overload
    def Append(self, arc: Arc) -> bool: ...
    @overload
    def Append(self, curve: Curve) -> bool: ...
    @overload
    def AppendSegment(self, curve: Curve) -> bool: ...
    @overload
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def CleanUp(self) -> Curve: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    @overload
    def ControlPolygon(self) -> Polyline: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateCurve(self) -> Curve: ...
    @overload
    def DuplicatePolyCurve(self) -> PolyCurve: ...
    @overload
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Explode(self) -> Iterable[Curve]: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    @overload
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    @overload
    def FilletSurfaceToCurve(self, face: BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FilletSurfaceToRail(self, faceWithCurve: BrepFace, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: List, out_breps0: List, out_breps1: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FindLocalInflection(self, N: Vector3d, subDomain: Interval, seed: float) -> Tuple[bool, float, float]: ...
    @overload
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Degree(self) -> int: ...
    @overload
    @property
    def Dimension(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Domain(self) -> Interval: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasGap(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsNested(self) -> bool: ...
    @overload
    @property
    def IsPeriodic(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PointAtEnd(self) -> Point3d: ...
    @overload
    @property
    def PointAtMid(self) -> Point3d: ...
    @overload
    @property
    def PointAtStart(self) -> Point3d: ...
    @overload
    @property
    def SegmentCount(self) -> int: ...
    @overload
    @property
    def SpanCount(self) -> int: ...
    @overload
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @overload
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    @overload
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    @overload
    def GetSubCurves(self) -> Iterable[Curve]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def InflectionPoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    @overload
    def MakeClosed(self, tolerance: float) -> bool: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    @overload
    def MaxCurvaturePoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    @overload
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetTangentToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, length: float) -> Point3d: ...
    @overload
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    @overload
    def PolyCurveParameter(self, segmentIndex: int, segmentCurveParameter: float) -> float: ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float, loose: bool) -> Curve: ...
    @overload
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    @overload
    def RemoveNesting(self) -> bool: ...
    @overload
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def Reparameterize(self) -> Curve: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, ribbonParameters: RibbonOffsetParameters) -> Tuple[Curve, Iterable[Curve], Iterable[Curve], Iterable[Brep]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SegmentCurve(self, index: int) -> Curve: ...
    @overload
    def SegmentCurveParameter(self, polycurveParameter: float) -> float: ...
    @overload
    def SegmentDomain(self, segmentIndex: int) -> Interval: ...
    @overload
    def SegmentIndex(self, polycurveParameter: float) -> int: ...
    @overload
    def SegmentIndexes(self, subdomain: Interval) -> Tuple[int, int, int]: ...
    @overload
    @Domain.setter
    def Domain(self, value: Interval) -> None: ...
    @overload
    def SetEndPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetStartPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    @overload
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def SpanVector(self) -> Iterable[float]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    @overload
    def TorsionAt(self, t: float) -> float: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


from ..Collections import XAccess
from ..Collections import YAccess
from ..Collections import ZAccess
from ..Collections import Point3dList
from ..Collections import RhinoList
from ..Collections import Point3dList
class Polyline(Point3dList):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initialCapacity: int): ...
    @overload
    def __init__(self, collection: Iterable[Point3d]): ...
    def __iter__(self) -> Iterator[Point3d]: ...
    def __getitem__(self, index: int) -> Point3d: ...
    def __setitem__(self, index: int, value: Point3d): ...
    @overload
    def Add(self, item: Point3d) -> None: ...
    @overload
    def Add(self, x: float, y: float, z: float) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[Any]) -> None: ...
    @overload
    def AddRange(self, collection: Iterable[Point3d]) -> None: ...
    @overload
    def AsReadOnly(self) -> ReadOnlyCollection: ...
    @overload
    def BinarySearch(self, item: Point3d) -> int: ...
    @overload
    def BinarySearch(self, item: Point3d, comparer: IComparer) -> int: ...
    @overload
    def BinarySearch(self, index: int, count: int, item: Point3d, comparer: IComparer) -> int: ...
    @overload
    def BreakAtAngles(self, angle: float) -> Iterable[Polyline]: ...
    @overload
    def CenterPoint(self) -> Point3d: ...
    @overload
    def Clear(self) -> None: ...
    @overload
    def ClosestIndex(self, testPoint: Point3d) -> int: ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def CollapseShortSegments(self, tolerance: float) -> int: ...
    @overload
    def Contains(self, item: Point3d) -> bool: ...
    @overload
    def ConvertAll(self, converter: Converter) -> RhinoList: ...
    @overload
    def CopyTo(self, array: Iterable[Point3d]) -> None: ...
    @overload
    def CopyTo(self, array: Iterable[Point3d], arrayIndex: int) -> None: ...
    @overload
    def CopyTo(self, index: int, array: Iterable[Point3d], arrayIndex: int, count: int) -> None: ...
    @overload
    @staticmethod
    def CreateByJoiningLines(lines: Iterable[Line], tolerance: float, splitAtIntersections: bool) -> Iterable[Polyline]: ...
    @overload
    @staticmethod
    def CreateCircumscribedPolygon(circle: Circle, sideCount: int) -> Polyline: ...
    @overload
    @staticmethod
    def CreateInscribedPolygon(circle: Circle, sideCount: int) -> Polyline: ...
    @overload
    @staticmethod
    def CreateStarPolygon(circle: Circle, radius: float, cornerCount: int) -> Polyline: ...
    @overload
    def DeleteShortSegments(self, tolerance: float) -> int: ...
    @overload
    def Duplicate(self) -> RhinoList: ...
    @overload
    def Duplicate(self) -> Polyline: ...
    @overload
    def Duplicate(self) -> Point3dList: ...
    @overload
    def Equals(self, other: Point3dList) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Exists(self, match: Predicate) -> bool: ...
    @overload
    def Find(self, match: Predicate) -> Point3d: ...
    @overload
    def FindAll(self, match: Predicate) -> RhinoList: ...
    @overload
    def FindIndex(self, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def FindLast(self, match: Predicate) -> Point3d: ...
    @overload
    def FindLastIndex(self, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, match: Predicate) -> int: ...
    @overload
    def FindLastIndex(self, startIndex: int, count: int, match: Predicate) -> int: ...
    @overload
    def ForEach(self, action: Action) -> None: ...
    @overload
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def Capacity(self) -> int: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    @property
    def First(self) -> Point3d: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @overload
    @property
    def Last(self) -> Point3d: ...
    @overload
    @property
    def Length(self) -> float: ...
    @overload
    @property
    def NullCount(self) -> int: ...
    @overload
    @property
    def SegmentCount(self) -> int: ...
    @overload
    @property
    def X(self) -> XAccess: ...
    @overload
    @property
    def Y(self) -> YAccess: ...
    @overload
    @property
    def Z(self) -> ZAccess: ...
    @overload
    def GetEnumerator(self) -> Iterator[Point3d]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetRange(self, index: int, count: int) -> RhinoList: ...
    @overload
    def GetSegments(self) -> Iterable[Line]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IndexOf(self, item: Point3d) -> int: ...
    @overload
    def IndexOf(self, item: Point3d, index: int) -> int: ...
    @overload
    def IndexOf(self, item: Point3d, index: int, count: int) -> int: ...
    @overload
    def Insert(self, index: int, item: Point3d) -> None: ...
    @overload
    def InsertRange(self, index: int, collection: Iterable[Point3d]) -> None: ...
    @overload
    def IsClosedWithinTolerance(self, tolerance: float) -> bool: ...
    @overload
    def LastIndexOf(self, item: Point3d) -> int: ...
    @overload
    def LastIndexOf(self, item: Point3d, index: int) -> int: ...
    @overload
    def LastIndexOf(self, item: Point3d, index: int, count: int) -> int: ...
    @overload
    def MergeColinearSegments(self, angleTolerance: float, includeSeam: bool) -> int: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def ReduceSegments(self, tolerance: float) -> int: ...
    @overload
    def RemapIndex(self, index: int) -> int: ...
    @overload
    def Remove(self, item: Point3d) -> bool: ...
    @overload
    def RemoveAll(self, match: Predicate) -> int: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RemoveNearlyEqualSubsequentPoints(self, tolerance: float) -> None: ...
    @overload
    def RemoveNulls(self) -> int: ...
    @overload
    def RemoveRange(self, index: int, count: int) -> None: ...
    @overload
    def Reverse(self) -> None: ...
    @overload
    def Reverse(self, index: int, count: int) -> None: ...
    @overload
    def SegmentAt(self, index: int) -> Line: ...
    @overload
    @Capacity.setter
    def Capacity(self, value: int) -> None: ...
    @overload
    @First.setter
    def First(self, value: Point3d) -> None: ...
    @overload
    @property
    def Item(self) -> MutableSequence[Point3d]: ...
    @overload
    @Last.setter
    def Last(self, value: Point3d) -> None: ...
    @overload
    def SetAllX(self, xValue: float) -> None: ...
    @overload
    def SetAllY(self, yValue: float) -> None: ...
    @overload
    def SetAllZ(self, zValue: float) -> None: ...
    @overload
    def Smooth(self, amount: float) -> bool: ...
    @overload
    def Sort(self) -> None: ...
    @overload
    def Sort(self, comparer: IComparer) -> None: ...
    @overload
    def Sort(self, comparison: Comparison) -> None: ...
    @overload
    def Sort(self, keys: Iterable[float]) -> None: ...
    @overload
    def Sort(self, keys: Iterable[int]) -> None: ...
    @overload
    def Sort(self, index: int, count: int, comparer: IComparer) -> None: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArray(self) -> Iterable[Point3d]: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToPolylineCurve(self) -> PolylineCurve: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...
    @overload
    def TriangulateClosedPolyline(self) -> Iterable[MeshFace]: ...
    @overload
    def Trim(self, domain: Interval) -> Polyline: ...
    @overload
    def TrimExcess(self) -> None: ...
    @overload
    def TrueForAll(self, match: Predicate) -> bool: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class PolylineCurve(Curve):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: PolylineCurve): ...
    @overload
    def __init__(self, points: Iterable[Point3d]): ...
    @overload
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    @overload
    def ControlPolygon(self) -> Polyline: ...
    @overload
    @staticmethod
    def CreateConvexHull2d(points: Iterable[Point2d]) -> Tuple[PolylineCurve, Iterable[int]]: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Iterable[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Iterable[Vector3d]: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Iterable[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Iterable[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Iterable[float], Iterable[Point3d]]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Iterable[Point3d]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateCurve(self) -> Curve: ...
    @overload
    def DuplicateSegments(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtremeParameters(self, direction: Vector3d) -> Iterable[float]: ...
    @overload
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    @overload
    def FilletSurfaceToCurve(self, face: BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FilletSurfaceToRail(self, faceWithCurve: BrepFace, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: List, out_breps0: List, out_breps1: List) -> Tuple[bool, Iterable[float]]: ...
    @overload
    def FindLocalInflection(self, N: Vector3d, subDomain: Interval, seed: float) -> Tuple[bool, float, float]: ...
    @overload
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Degree(self) -> int: ...
    @overload
    @property
    def Dimension(self) -> int: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Domain(self) -> Interval: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsClosed(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsPeriodic(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def PointAtEnd(self) -> Point3d: ...
    @overload
    @property
    def PointAtMid(self) -> Point3d: ...
    @overload
    @property
    def PointAtStart(self) -> Point3d: ...
    @overload
    @property
    def PointCount(self) -> int: ...
    @overload
    @property
    def SpanCount(self) -> int: ...
    @overload
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @overload
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    @overload
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Iterable[Plane]: ...
    @overload
    def GetSubCurves(self) -> Iterable[Curve]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InflectionPoints(self) -> Iterable[Point3d]: ...
    @overload
    def InflectionPoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPolyline(self) -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    @overload
    def MakeClosed(self, tolerance: float) -> bool: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MaxCurvaturePoints(self) -> Iterable[Point3d]: ...
    @overload
    def MaxCurvaturePoints(self) -> Tuple[Iterable[Point3d], Iterable[float]]: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float) -> Iterable[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Iterable[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Iterable[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Iterable[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> Iterable[Curve]: ...
    @overload
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Iterable[float], offsetDistances: Iterable[float], fittingTolerance: float) -> Iterable[Curve]: ...
    @overload
    def OffsetTangentToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def Parameter(self, index: int) -> float: ...
    @overload
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    def Point(self, index: int) -> Point3d: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, length: float) -> Point3d: ...
    @overload
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Iterable[Curve]: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float, loose: bool) -> Curve: ...
    @overload
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    @overload
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def Reparameterize(self) -> Curve: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    def RibbonOffset(self, ribbonParameters: RibbonOffsetParameters) -> Tuple[Curve, Iterable[Curve], Iterable[Curve], Iterable[Brep]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[float], Iterable[float]]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Iterable[Curve], Iterable[Surface]]: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @Domain.setter
    def Domain(self, value: Interval) -> None: ...
    @overload
    def SetArcLengthParameterization(self, tolerance: float) -> None: ...
    @overload
    def SetEndPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetParameter(self, index: int, parameter: float) -> None: ...
    @overload
    def SetPoint(self, index: int, point: Point3d) -> None: ...
    @overload
    def SetStartPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    @overload
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def SpanVector(self) -> Iterable[float]: ...
    @overload
    def Split(self, t: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, t: Iterable[float]) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Iterable[Curve]: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    @overload
    def ToArray(self) -> Iterable[Point3d]: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self) -> Polyline: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    @overload
    def TorsionAt(self, t: float) -> float: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Iterable[float]]: ...


class PreserveEnd(Enum):
    # None = 0
    Position = 1
    Tangency = 2
    Curvature = 3


class QuadRemeshParameters:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def AdaptiveQuadCount(self) -> bool: ...
    @overload
    @property
    def AdaptiveSize(self) -> float: ...
    @overload
    @property
    def DetectHardEdges(self) -> bool: ...
    @overload
    @property
    def GuideCurveInfluence(self) -> int: ...
    @overload
    @property
    def PreserveMeshArrayEdgesMode(self) -> int: ...
    @overload
    @property
    def SymmetryAxis(self) -> QuadRemeshSymmetryAxis: ...
    @overload
    @property
    def TargetEdgeLength(self) -> float: ...
    @overload
    @property
    def TargetQuadCount(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @AdaptiveQuadCount.setter
    def AdaptiveQuadCount(self, value: bool) -> None: ...
    @overload
    @AdaptiveSize.setter
    def AdaptiveSize(self, value: float) -> None: ...
    @overload
    @DetectHardEdges.setter
    def DetectHardEdges(self, value: bool) -> None: ...
    @overload
    @GuideCurveInfluence.setter
    def GuideCurveInfluence(self, value: int) -> None: ...
    @overload
    @PreserveMeshArrayEdgesMode.setter
    def PreserveMeshArrayEdgesMode(self, value: int) -> None: ...
    @overload
    @SymmetryAxis.setter
    def SymmetryAxis(self, value: QuadRemeshSymmetryAxis) -> None: ...
    @overload
    @TargetEdgeLength.setter
    def TargetEdgeLength(self, value: float) -> None: ...
    @overload
    @TargetQuadCount.setter
    def TargetQuadCount(self, value: int) -> None: ...
    @overload
    def ToString(self) -> str: ...


class QuadRemeshSymmetryAxis(Enum):
    # None = 0
    X = 1
    Y = 2
    Z = 4


class Quaternion:
    @overload
    def __init__(self, a: float, b: float, c: float, d: float): ...
    @overload
    @staticmethod
    def CreateFromRotationZYX(yaw: float, pitch: float, roll: float) -> Quaternion: ...
    @overload
    @staticmethod
    def CreateFromRotationZYZ(alpha: float, beta: float, gamma: float) -> Quaternion: ...
    @overload
    @staticmethod
    def CrossProduct(p: Quaternion, q: Quaternion) -> Quaternion: ...
    @overload
    @staticmethod
    def Distance(p: Quaternion, q: Quaternion) -> float: ...
    @overload
    def DistanceTo(self, q: Quaternion) -> float: ...
    @overload
    def EpsilonEquals(self, other: Quaternion, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: Quaternion) -> bool: ...
    @overload
    @property
    def A(self) -> float: ...
    @overload
    @property
    def B(self) -> float: ...
    @overload
    @property
    def C(self) -> float: ...
    @overload
    @property
    def Conjugate(self) -> Quaternion: ...
    @overload
    @property
    def D(self) -> float: ...
    @overload
    @property
    def I() -> Quaternion: ...
    @overload
    @property
    def Identity() -> Quaternion: ...
    @overload
    @property
    def Inverse(self) -> Quaternion: ...
    @overload
    @property
    def IsScalar(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def IsVector(self) -> bool: ...
    @overload
    @property
    def IsZero(self) -> bool: ...
    @overload
    @property
    def J() -> Quaternion: ...
    @overload
    @property
    def K() -> Quaternion: ...
    @overload
    @property
    def Length(self) -> float: ...
    @overload
    @property
    def LengthSquared(self) -> float: ...
    @overload
    @property
    def Scalar(self) -> float: ...
    @overload
    @property
    def Vector(self) -> Vector3d: ...
    @overload
    @property
    def Zero() -> Quaternion: ...
    @overload
    def GetEulerZYZ(self) -> Tuple[bool, float, float, float]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetRotation(self) -> Tuple[bool, Transform]: ...
    @overload
    def GetRotation(self) -> Tuple[bool, Plane]: ...
    @overload
    def GetRotation(self) -> Tuple[bool, float, Vector3d]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetYawPitchRoll(self) -> Tuple[bool, float, float, float]: ...
    @overload
    def Invert(self) -> bool: ...
    @overload
    @staticmethod
    def Lerp(a: Quaternion, b: Quaternion, t: float) -> Quaternion: ...
    @overload
    def MatrixForm(self) -> Transform: ...
    @overload
    def __add__(a: Quaternion, b: Quaternion) -> Quaternion: ...
    @overload
    def __truediv__(q: Quaternion, y: float) -> Quaternion: ...
    @overload
    def __eq__(a: Quaternion, b: Quaternion) -> bool: ...
    @overload
    def __ne__(a: Quaternion, b: Quaternion) -> bool: ...
    @overload
    def __mul__(q: Quaternion, x: float) -> Quaternion: ...
    @overload
    def __mul__(q: Quaternion, x: int) -> Quaternion: ...
    @overload
    def __mul__(a: Quaternion, b: Quaternion) -> Quaternion: ...
    @overload
    def __mul__(q: Quaternion, x: float) -> Quaternion: ...
    @overload
    def __sub__(a: Quaternion, b: Quaternion) -> Quaternion: ...
    @overload
    @staticmethod
    def Product(p: Quaternion, q: Quaternion) -> Quaternion: ...
    @overload
    def Rotate(self, v: Vector3d) -> Vector3d: ...
    @overload
    @staticmethod
    def RotateTowards(a: Quaternion, b: Quaternion, maxRadians: float) -> Quaternion: ...
    @overload
    @staticmethod
    def Rotation(plane0: Plane, plane1: Plane) -> Quaternion: ...
    @overload
    @staticmethod
    def Rotation(angle: float, axisOfRotation: Vector3d) -> Quaternion: ...
    @overload
    @A.setter
    def A(self, value: float) -> None: ...
    @overload
    @B.setter
    def B(self, value: float) -> None: ...
    @overload
    @C.setter
    def C(self, value: float) -> None: ...
    @overload
    @D.setter
    def D(self, value: float) -> None: ...
    @overload
    def Set(self, a: float, b: float, c: float, d: float) -> None: ...
    @overload
    def SetRotation(self, plane0: Plane, plane1: Plane) -> None: ...
    @overload
    def SetRotation(self, angle: float, axisOfRotation: Vector3d) -> None: ...
    @overload
    @staticmethod
    def Slerp(a: Quaternion, b: Quaternion, t: float) -> Quaternion: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Unitize(self) -> bool: ...


from ..DocObjects import DimensionStyle
from ..DocObjects import TextHorizontalAlignment
from ..DocObjects import ArrowType
from ..DocObjects import LeaderCurveStyle
from ..DocObjects import TextOrientation
from ..DocObjects import TextLocation
from ..DocObjects import LeaderContentAngleStyle
from ..DocObjects import ViewportInfo
from ..DocObjects import ArrowFit
from ..DocObjects import TextFit
from ..DocObjects import CenterMarkStyle
from ..DocObjects import ZeroSuppression
from ..DocObjects import ToleranceDisplayFormat
from ..DocObjects import LengthDisplay
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class RadialDimension(Dimension):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, dimtype: AnnotationType, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d): ...
    @overload
    def AdjustFromPoints(self, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d, rotationInPlane: float) -> bool: ...
    @overload
    def ClearPropertyOverrides(self) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(dimStyle: DimensionStyle, dimtype: AnnotationType, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d) -> RadialDimension: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Explode(self) -> Iterable[GeometryBase]: ...
    @overload
    @property
    def AlternateBelowLine(self) -> bool: ...
    @overload
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def AltLengthFactor(self) -> float: ...
    @overload
    @property
    def AltLengthResolution(self) -> int: ...
    @overload
    @property
    def AltLengthRoundoff(self) -> float: ...
    @overload
    @property
    def AltPrefix(self) -> str: ...
    @overload
    @property
    def AltSuffix(self) -> str: ...
    @overload
    @property
    def AltToleranceResolution(self) -> int: ...
    @overload
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @overload
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @overload
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @overload
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @overload
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @overload
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @overload
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @overload
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @overload
    @property
    def ArrowSize(self) -> float: ...
    @overload
    @property
    def BaselineSpacing(self) -> float: ...
    @overload
    @property
    def CentermarkSize(self) -> float: ...
    @overload
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @overload
    @property
    def CenterPoint(self) -> Point2d: ...
    @overload
    @property
    def DecimalSeparator(self) -> Char: ...
    @overload
    @property
    def DetailMeasured(self) -> Guid: ...
    @overload
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def DimensionLineExtension(self) -> float: ...
    @overload
    @property
    def DimensionScale(self) -> float: ...
    @overload
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def DimensionStyleId(self) -> Guid: ...
    @overload
    @property
    def DimlinePoint(self) -> Point2d: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def DistanceScale(self) -> float: ...
    @overload
    @property
    def DrawForward(self) -> bool: ...
    @overload
    @property
    def DrawTextFrame(self) -> bool: ...
    @overload
    @property
    def ExtensionLineExtension(self) -> float: ...
    @overload
    @property
    def ExtensionLineOffset(self) -> float: ...
    @overload
    @property
    def FirstCharFont(self) -> Font: ...
    @overload
    @property
    def FixedExtensionLength(self) -> float: ...
    @overload
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @overload
    @property
    def Font(self) -> Font: ...
    @overload
    @property
    def FontIndex(self) -> int: ...
    @overload
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @overload
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @overload
    @property
    def ForceDimLine(self) -> bool: ...
    @overload
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @overload
    @property
    def FormatWidth(self) -> float: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDiameterDimension(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def KneePoint(self) -> Point2d: ...
    @overload
    @property
    def LeaderArrowBlockId(self) -> Guid: ...
    @overload
    @property
    def LeaderArrowSize(self) -> float: ...
    @overload
    @property
    def LeaderArrowType(self) -> ArrowType: ...
    @overload
    @property
    def LeaderCurveStyle(self) -> LeaderCurveStyle: ...
    @overload
    @property
    def LeaderTextHorizontalAlignment(self) -> TextHorizontalAlignment: ...
    @overload
    @property
    def LengthFactor(self) -> float: ...
    @overload
    @property
    def LengthResolution(self) -> int: ...
    @overload
    @property
    def LengthRoundoff(self) -> float: ...
    @overload
    @property
    def MaskColor(self) -> Color: ...
    @overload
    @property
    def MaskColorSource(self) -> MaskType: ...
    @overload
    @property
    def MaskEnabled(self) -> bool: ...
    @overload
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @overload
    @property
    def MaskOffset(self) -> float: ...
    @overload
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @overload
    @property
    def NumericValue(self) -> float: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def PlainText(self) -> str: ...
    @overload
    @property
    def PlainTextWithFields(self) -> str: ...
    @overload
    @property
    def PlainUserText(self) -> str: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Prefix(self) -> str: ...
    @overload
    @property
    def RadiusPoint(self) -> Point2d: ...
    @overload
    @property
    def RichText(self) -> str: ...
    @overload
    @property
    def Suffix(self) -> str: ...
    @overload
    @property
    def SuppressExtension1(self) -> bool: ...
    @overload
    @property
    def SuppressExtension2(self) -> bool: ...
    @overload
    @property
    def Text(self) -> str: ...
    @overload
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @overload
    @property
    def TextFit(self) -> TextFit: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @overload
    @property
    def TextHeight(self) -> float: ...
    @overload
    @property
    def TextIsWrapped(self) -> bool: ...
    @overload
    @property
    def TextLocation(self) -> TextLocation: ...
    @overload
    @property
    def TextModelWidth(self) -> float: ...
    @overload
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @overload
    @property
    def TextPosition(self) -> Point2d: ...
    @overload
    @property
    def TextRotation(self) -> float: ...
    @overload
    @property
    def TextRotationDegrees(self) -> float: ...
    @overload
    @property
    def TextRotationRadians(self) -> float: ...
    @overload
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @overload
    @property
    def ToleranceHeightScale(self) -> float: ...
    @overload
    @property
    def ToleranceLowerValue(self) -> float: ...
    @overload
    @property
    def ToleranceResolution(self) -> int: ...
    @overload
    @property
    def ToleranceUpperValue(self) -> float: ...
    @overload
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    @overload
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d]: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    @overload
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Iterable[Any]]: ...
    @overload
    def GetDistanceDisplayText(self, unitsystem: UnitSystem, style: DimensionStyle) -> str: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    @overload
    def GetTextRectangle(self) -> Tuple[bool, Iterable[Point3d]]: ...
    @overload
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsAllBold(self) -> bool: ...
    @overload
    def IsAllItalic(self) -> bool: ...
    @overload
    def IsAllUnderlined(self) -> bool: ...
    @overload
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @AlternateBelowLine.setter
    def AlternateBelowLine(self, value: bool) -> None: ...
    @overload
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @AltLengthFactor.setter
    def AltLengthFactor(self, value: float) -> None: ...
    @overload
    @AltLengthResolution.setter
    def AltLengthResolution(self, value: int) -> None: ...
    @overload
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self, value: float) -> None: ...
    @overload
    @AltPrefix.setter
    def AltPrefix(self, value: str) -> None: ...
    @overload
    @AltSuffix.setter
    def AltSuffix(self, value: str) -> None: ...
    @overload
    @AltToleranceResolution.setter
    def AltToleranceResolution(self, value: int) -> None: ...
    @overload
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self, value: bool) -> None: ...
    @overload
    @AltZeroSuppression.setter
    def AltZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    @AnnotationType.setter
    def AnnotationType(self, value: AnnotationType) -> None: ...
    @overload
    @ArrowBlockId1.setter
    def ArrowBlockId1(self, value: Guid) -> None: ...
    @overload
    @ArrowBlockId2.setter
    def ArrowBlockId2(self, value: Guid) -> None: ...
    @overload
    @ArrowFit.setter
    def ArrowFit(self, value: ArrowFit) -> None: ...
    @overload
    @ArrowheadType1.setter
    def ArrowheadType1(self, value: ArrowType) -> None: ...
    @overload
    @ArrowheadType2.setter
    def ArrowheadType2(self, value: ArrowType) -> None: ...
    @overload
    @ArrowSize.setter
    def ArrowSize(self, value: float) -> None: ...
    @overload
    @BaselineSpacing.setter
    def BaselineSpacing(self, value: float) -> None: ...
    @overload
    @CentermarkSize.setter
    def CentermarkSize(self, value: float) -> None: ...
    @overload
    @CentermarkStyle.setter
    def CentermarkStyle(self, value: CenterMarkStyle) -> None: ...
    @overload
    @CenterPoint.setter
    def CenterPoint(self, value: Point2d) -> None: ...
    @overload
    @DecimalSeparator.setter
    def DecimalSeparator(self, value: Char) -> None: ...
    @overload
    @DetailMeasured.setter
    def DetailMeasured(self, value: Guid) -> None: ...
    @overload
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DimensionLineExtension.setter
    def DimensionLineExtension(self, value: float) -> None: ...
    @overload
    @DimensionScale.setter
    def DimensionScale(self, value: float) -> None: ...
    @overload
    @DimensionStyleId.setter
    def DimensionStyleId(self, value: Guid) -> None: ...
    @overload
    @DimlinePoint.setter
    def DimlinePoint(self, value: Point2d) -> None: ...
    @overload
    @DistanceScale.setter
    def DistanceScale(self, value: float) -> None: ...
    @overload
    @DrawForward.setter
    def DrawForward(self, value: bool) -> None: ...
    @overload
    @DrawTextFrame.setter
    def DrawTextFrame(self, value: bool) -> None: ...
    @overload
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self, value: float) -> None: ...
    @overload
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self, value: float) -> None: ...
    @overload
    @FixedExtensionLength.setter
    def FixedExtensionLength(self, value: float) -> None: ...
    @overload
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self, value: bool) -> None: ...
    @overload
    @Font.setter
    def Font(self, value: Font) -> None: ...
    @overload
    @FontIndex.setter
    def FontIndex(self, value: int) -> None: ...
    @overload
    @ForceArrowPosition.setter
    def ForceArrowPosition(self, value: ForceArrow) -> None: ...
    @overload
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self, value: bool) -> None: ...
    @overload
    @ForceDimLine.setter
    def ForceDimLine(self, value: bool) -> None: ...
    @overload
    @ForceTextPosition.setter
    def ForceTextPosition(self, value: ForceText) -> None: ...
    @overload
    @FormatWidth.setter
    def FormatWidth(self, value: float) -> None: ...
    @overload
    @LeaderArrowBlockId.setter
    def LeaderArrowBlockId(self, value: Guid) -> None: ...
    @overload
    @LeaderArrowSize.setter
    def LeaderArrowSize(self, value: float) -> None: ...
    @overload
    @LeaderArrowType.setter
    def LeaderArrowType(self, value: ArrowType) -> None: ...
    @overload
    @LeaderCurveStyle.setter
    def LeaderCurveStyle(self, value: LeaderCurveStyle) -> None: ...
    @overload
    @LeaderTextHorizontalAlignment.setter
    def LeaderTextHorizontalAlignment(self, value: TextHorizontalAlignment) -> None: ...
    @overload
    @LengthFactor.setter
    def LengthFactor(self, value: float) -> None: ...
    @overload
    @LengthResolution.setter
    def LengthResolution(self, value: int) -> None: ...
    @overload
    @LengthRoundoff.setter
    def LengthRoundoff(self, value: float) -> None: ...
    @overload
    @MaskColor.setter
    def MaskColor(self, value: Color) -> None: ...
    @overload
    @MaskColorSource.setter
    def MaskColorSource(self, value: MaskType) -> None: ...
    @overload
    @MaskEnabled.setter
    def MaskEnabled(self, value: bool) -> None: ...
    @overload
    @MaskFrame.setter
    def MaskFrame(self, value: MaskFrame) -> None: ...
    @overload
    @MaskOffset.setter
    def MaskOffset(self, value: float) -> None: ...
    @overload
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self, value: bool) -> None: ...
    @overload
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self, value: DimensionStyle) -> None: ...
    @overload
    @PlainText.setter
    def PlainText(self, value: str) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @Prefix.setter
    def Prefix(self, value: str) -> None: ...
    @overload
    @RadiusPoint.setter
    def RadiusPoint(self, value: Point2d) -> None: ...
    @overload
    @RichText.setter
    def RichText(self, value: str) -> None: ...
    @overload
    @Suffix.setter
    def Suffix(self, value: str) -> None: ...
    @overload
    @SuppressExtension1.setter
    def SuppressExtension1(self, value: bool) -> None: ...
    @overload
    @SuppressExtension2.setter
    def SuppressExtension2(self, value: bool) -> None: ...
    @overload
    @Text.setter
    def Text(self, value: str) -> None: ...
    @overload
    @TextAngleType.setter
    def TextAngleType(self, value: LeaderContentAngleStyle) -> None: ...
    @overload
    @TextFit.setter
    def TextFit(self, value: TextFit) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextHeight.setter
    def TextHeight(self, value: float) -> None: ...
    @overload
    @TextIsWrapped.setter
    def TextIsWrapped(self, value: bool) -> None: ...
    @overload
    @TextLocation.setter
    def TextLocation(self, value: TextLocation) -> None: ...
    @overload
    @TextOrientation.setter
    def TextOrientation(self, value: TextOrientation) -> None: ...
    @overload
    @TextPosition.setter
    def TextPosition(self, value: Point2d) -> None: ...
    @overload
    @TextRotation.setter
    def TextRotation(self, value: float) -> None: ...
    @overload
    @TextRotationDegrees.setter
    def TextRotationDegrees(self, value: float) -> None: ...
    @overload
    @TextRotationRadians.setter
    def TextRotationRadians(self, value: float) -> None: ...
    @overload
    @ToleranceFormat.setter
    def ToleranceFormat(self, value: ToleranceDisplayFormat) -> None: ...
    @overload
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self, value: float) -> None: ...
    @overload
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self, value: float) -> None: ...
    @overload
    @ToleranceResolution.setter
    def ToleranceResolution(self, value: int) -> None: ...
    @overload
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self, value: float) -> None: ...
    @overload
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self, value: bool) -> None: ...
    @overload
    @ZeroSuppression.setter
    def ZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @overload
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetBold(self, set_on: bool) -> bool: ...
    @overload
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    @overload
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    @overload
    def SetItalic(self, set_on: bool) -> bool: ...
    @overload
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    @overload
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    @overload
    def SetUnderline(self, set_on: bool) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def UpdateDimensionText(self, style: DimensionStyle, units: UnitSystem) -> None: ...
    @overload
    def WrapText(self) -> None: ...


class RailType(Enum):
    DistanceFromEdge = 0
    RollingBall = 1
    DistanceBetweenRails = 2


class Ray3d:
    @overload
    def __init__(self, position: Point3d, direction: Vector3d): ...
    @overload
    def EpsilonEquals(self, other: Ray3d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, ray: Ray3d) -> bool: ...
    @overload
    @property
    def Direction(self) -> Vector3d: ...
    @overload
    @property
    def Position(self) -> Point3d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def __eq__(a: Ray3d, b: Ray3d) -> bool: ...
    @overload
    def __ne__(a: Ray3d, b: Ray3d) -> bool: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def ToString(self) -> str: ...


class Rectangle3d:
    @overload
    def __init__(self, plane: Plane, width: float, height: float): ...
    @overload
    def __init__(self, plane: Plane, width: Interval, height: Interval): ...
    @overload
    def __init__(self, plane: Plane, cornerA: Point3d, cornerB: Point3d): ...
    @overload
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, point: Point3d, includeInterior: bool) -> Point3d: ...
    @overload
    def Contains(self, pt: Point3d) -> PointContainment: ...
    @overload
    def Contains(self, x: float, y: float) -> PointContainment: ...
    @overload
    def Corner(self, index: int) -> Point3d: ...
    @overload
    @staticmethod
    def CreateFromPolyline(polyline: Iterable[Point3d]) -> Rectangle3d: ...
    @overload
    @staticmethod
    def CreateFromPolyline(polyline: Iterable[Point3d]) -> Tuple[Rectangle3d, float, float]: ...
    @overload
    def EpsilonEquals(self, other: Rectangle3d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Area(self) -> float: ...
    @overload
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def Center(self) -> Point3d: ...
    @overload
    @property
    def Circumference(self) -> float: ...
    @overload
    @property
    def Height(self) -> float: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Unset() -> Rectangle3d: ...
    @overload
    @property
    def Width(self) -> float: ...
    @overload
    @property
    def X(self) -> Interval: ...
    @overload
    @property
    def Y(self) -> Interval: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def MakeIncreasing(self) -> None: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAt(self, x: float, y: float) -> Point3d: ...
    @overload
    def RecenterPlane(self, origin: Point3d) -> None: ...
    @overload
    def RecenterPlane(self, index: int) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @X.setter
    def X(self, value: Interval) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: Interval) -> None: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToPolyline(self) -> Polyline: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...


class ReduceMeshParameters:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Accuracy(self) -> int: ...
    @overload
    @property
    def AllowDistortion(self) -> bool: ...
    @overload
    @property
    def CancelToken(self) -> CancellationToken: ...
    @overload
    @property
    def DesiredPolygonCount(self) -> int: ...
    @overload
    @property
    def Error(self) -> str: ...
    @overload
    @property
    def FaceTags(self) -> Iterable[int]: ...
    @overload
    @property
    def LockedComponents(self) -> Iterable[ComponentIndex]: ...
    @overload
    @property
    def NormalizeMeshSize(self) -> bool: ...
    @overload
    @property
    def ProgressReporter(self) -> IProgress: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @Accuracy.setter
    def Accuracy(self, value: int) -> None: ...
    @overload
    @AllowDistortion.setter
    def AllowDistortion(self, value: bool) -> None: ...
    @overload
    @CancelToken.setter
    def CancelToken(self, value: CancellationToken) -> None: ...
    @overload
    @DesiredPolygonCount.setter
    def DesiredPolygonCount(self, value: int) -> None: ...
    @overload
    @FaceTags.setter
    def FaceTags(self, value: Iterable[int]) -> None: ...
    @overload
    @LockedComponents.setter
    def LockedComponents(self, value: Iterable[ComponentIndex]) -> None: ...
    @overload
    @NormalizeMeshSize.setter
    def NormalizeMeshSize(self, value: bool) -> None: ...
    @overload
    @ProgressReporter.setter
    def ProgressReporter(self, value: IProgress) -> None: ...
    @overload
    def ToString(self) -> str: ...


class RefitTrimKnotMode(Enum):
    # None = 0
    UniformEntireSurface = 1
    UniformPerSpan = 2
    Custom = 3


class RefitTrimSectionMode(Enum):
    NoSections = 0
    DivideAtInputKnots = 1
    DivideAtAddedKnots = 2
    DivideAtAllKnots = 3


class RegionContainment(Enum):
    Disjoint = 0
    MutualIntersection = 1
    AInsideB = 2
    BInsideA = 3


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class RevSurface(Surface):
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(revolutePolyline: Polyline, axisOfRevolution: Line) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revoluteCurve: Curve, axisOfRevolution: Line) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revoluteLine: Line, axisOfRevolution: Line) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revoluteLine: Line, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revolutePolyline: Polyline, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revoluteCurve: Curve, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone) -> RevSurface: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder) -> RevSurface: ...
    @overload
    @staticmethod
    def CreateFromSphere(sphere: Sphere) -> RevSurface: ...
    @overload
    @staticmethod
    def CreateFromTorus(torus: Torus) -> RevSurface: ...
    @overload
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def Degree(self, direction: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    @overload
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    @overload
    def FitCurveToSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], divideIntoSections: bool, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[Iterable[Curve], Curve, Curve]: ...
    @overload
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Angle(self) -> Interval: ...
    @overload
    @property
    def Axis(self) -> Line: ...
    @overload
    @property
    def Curve(self) -> Curve: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def Interval(self) -> Interval: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsTransposed(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    @overload
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    @overload
    def IsAtSeam(self, u: float, v: float) -> int: ...
    @overload
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    @overload
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    @overload
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    @overload
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    @overload
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def RefitSimplySplitSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, knotAdditionMode: RefitTrimKnotMode, numInsertKnots: int, Knots: Iterable[float], sectionMode: RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Point3d, outputSurface: bool, outputCurve: bool, numSections: int, lowerSurface: List, upperSurface: List, edgeCurve: List, FitMeasurement: float, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[bool, int, float, Curve, Curve]: ...
    @overload
    def RefitSplit(self, curve: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], bMeetCurve: bool, divideIntoSections: bool, srfLower: List, srfUpper: List, edgeCurve: List, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[int, Curve, Curve]: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    @overload
    def SpanCount(self, direction: int) -> int: ...
    @overload
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    @overload
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


class RibbonOffsetParameters:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def AlignCrossSections(self) -> bool: ...
    @overload
    @property
    def BlendRadius(self) -> float: ...
    @overload
    @property
    def OffsetDistance(self) -> float: ...
    @overload
    @property
    def OffsetLocation(self) -> Point3d: ...
    @overload
    @property
    def OffsetPlaneVector3d(self) -> Vector3d: ...
    @overload
    @property
    def OffsetTolerance(self) -> float: ...
    @overload
    @property
    def RebuildPointCount(self) -> int: ...
    @overload
    @property
    def RefitTolerance(self) -> float: ...
    @overload
    @property
    def RibbonSurfaceGenerationMethod(self) -> RibbonOffsetSurfaceMethod: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @AlignCrossSections.setter
    def AlignCrossSections(self, value: bool) -> None: ...
    @overload
    @BlendRadius.setter
    def BlendRadius(self, value: float) -> None: ...
    @overload
    @OffsetDistance.setter
    def OffsetDistance(self, value: float) -> None: ...
    @overload
    @OffsetLocation.setter
    def OffsetLocation(self, value: Point3d) -> None: ...
    @overload
    @OffsetPlaneVector3d.setter
    def OffsetPlaneVector3d(self, value: Vector3d) -> None: ...
    @overload
    @OffsetTolerance.setter
    def OffsetTolerance(self, value: float) -> None: ...
    @overload
    @RebuildPointCount.setter
    def RebuildPointCount(self, value: int) -> None: ...
    @overload
    @RefitTolerance.setter
    def RefitTolerance(self, value: float) -> None: ...
    @overload
    @RibbonSurfaceGenerationMethod.setter
    def RibbonSurfaceGenerationMethod(self, value: RibbonOffsetSurfaceMethod) -> None: ...
    @overload
    def ToString(self) -> str: ...


class RibbonOffsetSurfaceMethod(Enum):
    # None = 0
    Sweep2 = 1
    Sweep2NetworkSrf = 2


class RTree:
    @overload
    def __init__(self): ...
    @overload
    def Clear(self) -> None: ...
    @overload
    @staticmethod
    def CreateFromPointArray(points: Iterable[Point3d]) -> RTree: ...
    @overload
    @staticmethod
    def CreateMeshFaceTree(mesh: Mesh) -> RTree: ...
    @overload
    @staticmethod
    def CreatePointCloudTree(cloud: PointCloud) -> RTree: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Count(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Insert(self, point: Point3d, elementId: int) -> bool: ...
    @overload
    def Insert(self, point: Point3d, elementId: IntPtr) -> bool: ...
    @overload
    def Insert(self, box: BoundingBox, elementId: int) -> bool: ...
    @overload
    def Insert(self, box: BoundingBox, elementId: IntPtr) -> bool: ...
    @overload
    def Insert(self, point: Point2d, elementId: int) -> bool: ...
    @overload
    def Insert(self, point: Point2d, elementId: IntPtr) -> bool: ...
    @overload
    @staticmethod
    def Point3dClosestPoints(hayPoints: Iterable[Point3d], needlePts: Iterable[Point3d], limitDistance: float) -> Iterable[Iterable[int]]: ...
    @overload
    @staticmethod
    def Point3dKNeighbors(hayPoints: Iterable[Point3d], needlePts: Iterable[Point3d], amount: int) -> Iterable[Iterable[int]]: ...
    @overload
    @staticmethod
    def PointCloudClosestPoints(pointcloud: PointCloud, needlePts: Iterable[Point3d], limitDistance: float) -> Iterable[Iterable[int]]: ...
    @overload
    @staticmethod
    def PointCloudKNeighbors(pointcloud: PointCloud, needlePts: Iterable[Point3d], amount: int) -> Iterable[Iterable[int]]: ...
    @overload
    def Remove(self, box: BoundingBox, elementId: IntPtr) -> bool: ...
    @overload
    def Remove(self, box: BoundingBox, elementId: int) -> bool: ...
    @overload
    def Remove(self, point: Point3d, elementId: IntPtr) -> bool: ...
    @overload
    def Remove(self, point: Point3d, elementId: int) -> bool: ...
    @overload
    def Remove(self, point: Point2d, elementId: int) -> bool: ...
    @overload
    def Search(self, box: BoundingBox, callback: EventHandler) -> bool: ...
    @overload
    def Search(self, sphere: Sphere, callback: EventHandler) -> bool: ...
    @overload
    def Search(self, sphere: Sphere, callback: EventHandler, tag: object) -> bool: ...
    @overload
    def Search(self, box: BoundingBox, callback: EventHandler, tag: object) -> bool: ...
    @overload
    @staticmethod
    def SearchOverlaps(treeA: RTree, treeB: RTree, tolerance: float, callback: EventHandler) -> bool: ...
    @overload
    def ToString(self) -> str: ...


class RTreeEventArgs:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Cancel(self) -> bool: ...
    @overload
    @property
    def Id(self) -> int: ...
    @overload
    @property
    def IdB(self) -> int: ...
    @overload
    @property
    def IdBPtr(self) -> IntPtr: ...
    @overload
    @property
    def IdPtr(self) -> IntPtr: ...
    @overload
    @property
    def SearchBoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def SearchSphere(self) -> Sphere: ...
    @overload
    @property
    def Tag(self) -> object: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @Cancel.setter
    def Cancel(self, value: bool) -> None: ...
    @overload
    @SearchBoundingBox.setter
    def SearchBoundingBox(self, value: BoundingBox) -> None: ...
    @overload
    @SearchSphere.setter
    def SearchSphere(self, value: Sphere) -> None: ...
    @overload
    @Tag.setter
    def Tag(self, value: object) -> None: ...
    @overload
    def ToString(self) -> str: ...


class ShrinkDisableSide(Enum):
    ShrinkAllSides = 0
    DoNotShrinkWestSide = 1
    DoNotShrinkSouthSide = 2
    DoNotShrinkEastSide = 4
    DoNotShrinkNorthSide = 8


class ShrinkWrapParameters:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def FillHolesInInputObjects(self) -> bool: ...
    @overload
    @property
    def InflateVerticesAndPoints(self) -> bool: ...
    @overload
    @property
    def Offset(self) -> float: ...
    @overload
    @property
    def PolygonOptimization(self) -> int: ...
    @overload
    @property
    def SmoothingIterations(self) -> int: ...
    @overload
    @property
    def TargetEdgeLength(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @FillHolesInInputObjects.setter
    def FillHolesInInputObjects(self, value: bool) -> None: ...
    @overload
    @InflateVerticesAndPoints.setter
    def InflateVerticesAndPoints(self, value: bool) -> None: ...
    @overload
    @Offset.setter
    def Offset(self, value: float) -> None: ...
    @overload
    @PolygonOptimization.setter
    def PolygonOptimization(self, value: int) -> None: ...
    @overload
    @SmoothingIterations.setter
    def SmoothingIterations(self, value: int) -> None: ...
    @overload
    @TargetEdgeLength.setter
    def TargetEdgeLength(self, value: float) -> None: ...
    @overload
    def ToString(self) -> str: ...


class ShutLiningCurveInfo:
    @overload
    def __init__(self, curve: Curve, radius: float, profile: int, pull: bool, isBump: bool, curveIntervals: Iterable[Interval], enabled: bool): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Curve(self) -> Curve: ...
    @overload
    @property
    def CurveIntervals(self) -> ReadOnlyCollection: ...
    @overload
    @property
    def Enabled(self) -> bool: ...
    @overload
    @property
    def IsBump(self) -> bool: ...
    @overload
    @property
    def Profile(self) -> int: ...
    @overload
    @property
    def Pull(self) -> bool: ...
    @overload
    @property
    def Radius(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class SideFill(Enum):
    SideUnset = 0
    SideSurface = 1
    SideVoid = 2
    OtherSurface = 3


from ..DocObjects import ViewportInfo
class Silhouette:
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, perspectiveCameraLocation: Point3d, tolerance: float, angleToleranceRadians: float) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, parallelCameraDirection: Vector3d, tolerance: float, angleToleranceRadians: float) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, viewport: ViewportInfo, tolerance: float, angleToleranceRadians: float) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, perspectiveCameraLocation: Point3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Plane], cancelToken: CancellationToken) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, parallelCameraDirection: Vector3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Plane], cancelToken: CancellationToken) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, viewport: ViewportInfo, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Plane], cancelToken: CancellationToken) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def ComputeDraftCurve(geometry: GeometryBase, draftAngle: float, pullDirection: Vector3d, tolerance: float, angleToleranceRadians: float) -> Iterable[Silhouette]: ...
    @overload
    @staticmethod
    def ComputeDraftCurve(geometry: GeometryBase, draftAngle: float, pullDirection: Vector3d, tolerance: float, angleToleranceRadians: float, cancelToken: CancellationToken) -> Iterable[Silhouette]: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Curve(self) -> Curve: ...
    @overload
    @property
    def GeometryComponentIndex(self) -> ComponentIndex: ...
    @overload
    @property
    def SilhouetteType(self) -> SilhouetteType: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class SilhouetteType(Enum):
    # None = 0
    Projecting = 1
    TangentProjects = 2
    Tangent = 4
    Crease = 8
    Boundary = 16
    NonSilhouetteCrease = 256
    NonSilhouetteTangent = 512
    NonSilhouetteSeam = 1024
    SectionCut = 4096
    MiscellaneousFeature = 8192
    DraftCurve = 32768


class SmoothingCoordinateSystem(Enum):
    World = 0
    CPlane = 1
    Object = 2


class SpaceMorph:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def PreserveStructure(self) -> bool: ...
    @overload
    @property
    def QuickPreview(self) -> bool: ...
    @overload
    @property
    def Tolerance(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def IsMorphable(geometry: GeometryBase) -> bool: ...
    @overload
    def Morph(self, geometry: GeometryBase) -> bool: ...
    @overload
    def Morph(self, plane: Plane) -> Tuple[bool, Plane]: ...
    @overload
    def MorphPoint(self, point: Point3d) -> Point3d: ...
    @overload
    @PreserveStructure.setter
    def PreserveStructure(self, value: bool) -> None: ...
    @overload
    @QuickPreview.setter
    def QuickPreview(self, value: bool) -> None: ...
    @overload
    @Tolerance.setter
    def Tolerance(self, value: float) -> None: ...
    @overload
    def ToString(self) -> str: ...


class Sphere:
    @overload
    def __init__(self, center: Point3d, radius: float): ...
    @overload
    def __init__(self, equatorialPlane: Plane, radius: float): ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def EpsilonEquals(self, other: Sphere, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @staticmethod
    def FitSphereToPoints(points: Iterable[Point3d]) -> Sphere: ...
    @overload
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def Center(self) -> Point3d: ...
    @overload
    @property
    def Diameter(self) -> float: ...
    @overload
    @property
    def EquatorialPlane(self) -> Plane: ...
    @overload
    @property
    def EquitorialPlane(self) -> Plane: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def NorthPole(self) -> Point3d: ...
    @overload
    @property
    def Radius(self) -> float: ...
    @overload
    @property
    def SouthPole(self) -> Point3d: ...
    @overload
    @property
    def Unset() -> Sphere: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def LatitudeDegrees(self, degrees: float) -> Circle: ...
    @overload
    def LatitudeRadians(self, radians: float) -> Circle: ...
    @overload
    def LongitudeDegrees(self, degrees: float) -> Circle: ...
    @overload
    def LongitudeRadians(self, radians: float) -> Circle: ...
    @overload
    def NormalAt(self, longitudeRadians: float, latitudeRadians: float) -> Vector3d: ...
    @overload
    def PointAt(self, longitudeRadians: float, latitudeRadians: float) -> Point3d: ...
    @overload
    def Rotate(self, angleRadians: float, axisOfRotation: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, axisOfRotation: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @overload
    @Center.setter
    def Center(self, value: Point3d) -> None: ...
    @overload
    @Diameter.setter
    def Diameter(self, value: float) -> None: ...
    @overload
    @EquatorialPlane.setter
    def EquatorialPlane(self, value: Plane) -> None: ...
    @overload
    @EquitorialPlane.setter
    def EquitorialPlane(self, value: Plane) -> None: ...
    @overload
    @Radius.setter
    def Radius(self, value: float) -> None: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToRevSurface(self) -> RevSurface: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, delta: Vector3d) -> bool: ...


class SquishDeformation(Enum):
    Free = 0
    StretchMostly = 1
    StretchOnly = 2
    CompressMostly = 3
    CompressOnly = 4
    Custom = 5


class Squisher:
    @overload
    def __init__(self): ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Get2dMesh(self) -> Mesh: ...
    @overload
    def Get3dMesh(self) -> Mesh: ...
    @overload
    def GetAreaConstrainedTrianglesIndices(self) -> Iterable[MeshFace]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetLengthConstrained2dLines(self) -> Iterable[Line]: ...
    @overload
    def GetLengthConstrained3dLines(self) -> Iterable[Line]: ...
    @overload
    def GetMesh2dEdges(self) -> Iterable[Line]: ...
    @overload
    def GetMesh3dEdges(self) -> Iterable[Line]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Is2dPatternSquished(geometry: GeometryBase) -> bool: ...
    @overload
    @staticmethod
    def SquishBack2dMarks(squishedGeometry: GeometryBase, marks: Iterable[GeometryBase]) -> Iterable[GeometryBase]: ...
    @overload
    def SquishCurve(self, curve: Curve) -> PolylineCurve: ...
    @overload
    def SquishMesh(self, sp: SquishParameters, mesh3d: Mesh) -> Mesh: ...
    @overload
    def SquishMesh(self, sp: SquishParameters, mesh3d: Mesh, marks: Iterable[GeometryBase], squished_marks_out: List) -> Mesh: ...
    @overload
    def SquishPoint(self, point: Point3d) -> Tuple[bool, Point3d]: ...
    @overload
    def SquishSurface(self, sp: SquishParameters, surface: Surface) -> Brep: ...
    @overload
    def SquishSurface(self, sp: SquishParameters, surface: Surface, marks: Iterable[GeometryBase], squished_marks_out: List) -> Brep: ...
    @overload
    def SquishTextDot(self, textDot: TextDot) -> TextDot: ...
    @overload
    def ToString(self) -> str: ...


class SquishFlatteningAlgorithm(Enum):
    Geometric = 0
    PhysicalStress = 1


class SquishParameters:
    @overload
    def __init__(self): ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def AbsoluteLimit(self) -> float: ...
    @overload
    @property
    def Algorithm(self) -> SquishFlatteningAlgorithm: ...
    @overload
    @property
    def BoundaryCompressConstant(self) -> float: ...
    @overload
    @property
    def BoundaryStretchConstant(self) -> float: ...
    @overload
    @property
    def Default() -> SquishParameters: ...
    @overload
    @property
    def InteriorCompressConstant(self) -> float: ...
    @overload
    @property
    def InteriorStretchConstant(self) -> float: ...
    @overload
    @property
    def PreserveTopology(self) -> bool: ...
    @overload
    @property
    def SaveMapping(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetSpringConstants(self) -> Tuple[bool, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @AbsoluteLimit.setter
    def AbsoluteLimit(self, value: float) -> None: ...
    @overload
    @Algorithm.setter
    def Algorithm(self, value: SquishFlatteningAlgorithm) -> None: ...
    @overload
    @BoundaryCompressConstant.setter
    def BoundaryCompressConstant(self, value: float) -> None: ...
    @overload
    @BoundaryStretchConstant.setter
    def BoundaryStretchConstant(self, value: float) -> None: ...
    @overload
    @InteriorCompressConstant.setter
    def InteriorCompressConstant(self, value: float) -> None: ...
    @overload
    @InteriorStretchConstant.setter
    def InteriorStretchConstant(self, value: float) -> None: ...
    @overload
    @PreserveTopology.setter
    def PreserveTopology(self, value: bool) -> None: ...
    @overload
    @SaveMapping.setter
    def SaveMapping(self, value: bool) -> None: ...
    @overload
    def SetDeformation(self, deformation: SquishDeformation, bPreserveBoundary: bool, boundaryStretchConstant: float, boundaryCompressConstant: float, interiorStretchConstant: float, interiorCompressConstant: float) -> None: ...
    @overload
    def SetSpringConstants(self, boundaryBias: float, deformationBias: float) -> None: ...
    @overload
    def ToString(self) -> str: ...


from .Collections import SubDFaceList
from .Collections import SubDVertexList
from .Collections import SubDEdgeList
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class SubD(GeometryBase):
    @overload
    def __init__(self): ...
    @overload
    def ClearEvaluationCache(self) -> None: ...
    @overload
    def ComponentFromComponentIndex(self, componentIndex: ComponentIndex) -> SubDComponent: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def CopyEvaluationCache(self, src: SubD) -> Tuple[bool, SubD]: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, circumferenceFaceCount: int, heightFaceCount: int, endCapStyle: SubDEndCapStyle, endCapEdgeTag: SubDEdgeTag, radiusLocation: SubDComponentLocation) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromLoft(curves: Iterable[NurbsCurve], closed: bool, addCorners: bool, addCreases: bool, divisions: int) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromMesh(mesh: Mesh) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromMesh(mesh: Mesh, options: SubDCreationOptions) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromSurface(surface: Surface, method: SubDFromSurfaceMethods, corners: bool) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: NurbsCurve, rail2: NurbsCurve, shapes: Iterable[NurbsCurve], closed: bool, addCorners: bool) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: NurbsCurve, shapes: Iterable[NurbsCurve], closed: bool, addCorners: bool, roadlikeFrame: bool, roadlikeNormal: Vector3d) -> SubD: ...
    @overload
    @staticmethod
    def CreateGlobeSphere(sphere: Sphere, vertexLocation: SubDComponentLocation, axialFaceCount: int, equatorialFaceCount: int) -> SubD: ...
    @overload
    @staticmethod
    def CreateIcosahedron(sphere: Sphere, vertexLocation: SubDComponentLocation) -> SubD: ...
    @overload
    @staticmethod
    def CreateQuadSphere(sphere: Sphere, vertexLocation: SubDComponentLocation, quadSubdivisionLevel: int) -> SubD: ...
    @overload
    @staticmethod
    def CreateTriSphere(sphere: Sphere, vertexLocation: SubDComponentLocation, triSubdivisionLevel: int) -> SubD: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateEdgeCurves(self) -> Iterable[Curve]: ...
    @overload
    def DuplicateEdgeCurves(self, boundaryOnly: bool, interiorOnly: bool, smoothOnly: bool, sharpOnly: bool, creaseOnly: bool, clampEnds: bool) -> Iterable[Curve]: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Flip(self) -> bool: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def Edges(self) -> SubDEdgeList: ...
    @overload
    @property
    def Empty() -> SubD: ...
    @overload
    @property
    def Faces(self) -> SubDFaceList: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    @property
    def Vertices(self) -> SubDVertexList: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def InterpolateSurfacePoints(self, surfacePoints: Iterable[Point3d]) -> bool: ...
    @overload
    def InterpolateSurfacePoints(self, vertexIndices: Iterable[int], surfacePoints: Iterable[Point3d]) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    @staticmethod
    def JoinSubDs(subdsToJoin: Iterable[SubD], tolerance: float, joinedEdgesAreCreases: bool) -> Iterable[SubD]: ...
    @overload
    @staticmethod
    def JoinSubDs(subdsToJoin: Iterable[SubD], tolerance: float, joinedEdgesAreCreases: bool, preserveSymmetry: bool) -> Iterable[SubD]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float) -> bool: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def Offset(self, distance: float, solidify: bool) -> SubD: ...
    @overload
    def PackFaces(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def SetVertexSurfacePoint(self, vertexIndex: int, surfacePoint: Point3d) -> bool: ...
    @overload
    def Subdivide(self) -> bool: ...
    @overload
    def Subdivide(self, faceIndices: Iterable[int]) -> bool: ...
    @overload
    def Subdivide(self, count: int) -> bool: ...
    @overload
    def SurfaceMeshCacheExists(self, bTextureCoordinatesExist: bool, bCurvaturesExist: bool, bColorsExist: bool) -> bool: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToBrep(self, options: SubDToBrepOptions) -> Brep: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def TransformComponents(self, components: Iterable[ComponentIndex], xform: Transform, componentLocation: SubDComponentLocation) -> int: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def UpdateAllTagsAndSectorCoefficients(self) -> int: ...
    @overload
    def UpdateSurfaceMeshCache(self, lazyUpdate: bool) -> int: ...


class SubDAutomaticMeshToSubDContext(Enum):
    Unset = 0
    Rhino5BoxModeTSpline = 1
    FBXMeshWithDivisionLevels = 2


class SubDChainType(Enum):
    Unset = 0
    MixedTag = 1
    EqualEdgeTag = 2
    EqualEdgeAndVertexTag = 3
    EqualEdgeTagAndOrdinary = 4
    EqualEdgeAndVertexTagAndOrdinary = 5


class SubDComponent:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Id(self) -> int: ...
    @overload
    @property
    def IsDamaged(self) -> bool: ...
    @overload
    @property
    def IsDeleted(self) -> bool: ...
    @overload
    @property
    def IsHidden(self) -> bool: ...
    @overload
    @property
    def IsHighlighted(self) -> bool: ...
    @overload
    @property
    def IsLocked(self) -> bool: ...
    @overload
    @property
    def IsSelected(self) -> bool: ...
    @overload
    @property
    def ParentSubD(self) -> SubD: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class SubDComponentLocation(Enum):
    Unset = 0
    ControlNet = 1
    Surface = 2


class SubDCreationOptions:
    @overload
    def __init__(self): ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ConcaveCornerTest(self) -> ConcaveCornerOption: ...
    @overload
    @property
    def ConvexAndConcaveCornersAndInteriorCreases() -> SubDCreationOptions: ...
    @overload
    @property
    def ConvexCornersAndInteriorCreases() -> SubDCreationOptions: ...
    @overload
    @property
    def ConvexCornerTest(self) -> ConvexCornerOption: ...
    @overload
    @property
    def InteriorCreases() -> SubDCreationOptions: ...
    @overload
    @property
    def InteriorCreaseTest(self) -> InteriorCreaseOption: ...
    @overload
    @property
    def InterpolateMeshVertices(self) -> bool: ...
    @overload
    @property
    def MaximumConvexCornerAngleRadians(self) -> float: ...
    @overload
    @property
    def MaximumConvexCornerEdgeCount(self) -> int: ...
    @overload
    @property
    def MinimumConcaveCornerAngleRadians(self) -> float: ...
    @overload
    @property
    def MinimumConcaveCornerEdgeCount(self) -> int: ...
    @overload
    @property
    def Smooth() -> SubDCreationOptions: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @ConcaveCornerTest.setter
    def ConcaveCornerTest(self, value: ConcaveCornerOption) -> None: ...
    @overload
    @ConvexCornerTest.setter
    def ConvexCornerTest(self, value: ConvexCornerOption) -> None: ...
    @overload
    @InteriorCreaseTest.setter
    def InteriorCreaseTest(self, value: InteriorCreaseOption) -> None: ...
    @overload
    @InterpolateMeshVertices.setter
    def InterpolateMeshVertices(self, value: bool) -> None: ...
    @overload
    @MaximumConvexCornerAngleRadians.setter
    def MaximumConvexCornerAngleRadians(self, value: float) -> None: ...
    @overload
    @MaximumConvexCornerEdgeCount.setter
    def MaximumConvexCornerEdgeCount(self, value: int) -> None: ...
    @overload
    @MinimumConcaveCornerAngleRadians.setter
    def MinimumConcaveCornerAngleRadians(self, value: float) -> None: ...
    @overload
    @MinimumConcaveCornerEdgeCount.setter
    def MinimumConcaveCornerEdgeCount(self, value: int) -> None: ...
    @overload
    def ToString(self) -> str: ...


class SubDDisplayParameters:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, info: SerializationInfo, context: StreamingContext): ...
    @overload
    @staticmethod
    def AbsoluteDisplayDensityFromSubD(adaptiveSubDDisplayDensity: int, subd: SubD) -> int: ...
    @overload
    @staticmethod
    def AbsoluteDisplayDensityFromSubDFaceCount(adaptiveSubDDisplayDensity: int, subDFaceCount: int) -> int: ...
    @overload
    @staticmethod
    def ClampDisplayDensity(displayDensity: int) -> int: ...
    @overload
    @staticmethod
    def Coarse() -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def CreateFromAbsoluteDisplayDensity(absoluteSubDDisplayDensity: int) -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def CreateFromDisplayDensity(adaptiveSubDDisplayDensity: int) -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def CreateFromMeshDensity(normalizedMeshDensity: float) -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def Default() -> SubDDisplayParameters: ...
    @overload
    def DisplayDensity(self, subd: SubD) -> int: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    @staticmethod
    def Empty() -> SubDDisplayParameters: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @staticmethod
    def ExtraCoarse() -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def ExtraFine() -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def Fine() -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def FromEncodedString(value: str) -> SubDDisplayParameters: ...
    @overload
    @property
    def AdaptiveDisplayMeshQuadMaximum() -> int: ...
    @overload
    @property
    def DisplayDensityIsAbsolute(self) -> bool: ...
    @overload
    @property
    def DisplayDensityIsAdaptive(self) -> bool: ...
    @overload
    @property
    def MeshLocation(self) -> SubDComponentLocation: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Medium() -> SubDDisplayParameters: ...
    @overload
    @MeshLocation.setter
    def MeshLocation(self, value: SubDComponentLocation) -> None: ...
    @overload
    def SetAbsoluteDisplayDensity(self, absoluteDisplayDensity: int) -> None: ...
    @overload
    def SetAdaptiveDisplayDensity(self, adaptiveDisplayDensity: int) -> None: ...
    @overload
    def ToEncodedString(self) -> str: ...
    @overload
    def ToString(self) -> str: ...


class SubDEdge(SubDComponent):
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def FaceAt(self, index: int) -> SubDFace: ...
    @overload
    @property
    def ControlNetLine(self) -> Line: ...
    @overload
    @property
    def FaceCount(self) -> int: ...
    @overload
    @property
    def Id(self) -> int: ...
    @overload
    @property
    def IsDamaged(self) -> bool: ...
    @overload
    @property
    def IsDeleted(self) -> bool: ...
    @overload
    @property
    def IsHidden(self) -> bool: ...
    @overload
    @property
    def IsHighlighted(self) -> bool: ...
    @overload
    @property
    def IsLocked(self) -> bool: ...
    @overload
    @property
    def IsSelected(self) -> bool: ...
    @overload
    @property
    def ParentSubD(self) -> SubD: ...
    @overload
    @property
    def Tag(self) -> SubDEdgeTag: ...
    @overload
    @property
    def VertexFrom(self) -> SubDVertex: ...
    @overload
    @property
    def VertexTo(self) -> SubDVertex: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @Tag.setter
    def Tag(self, value: SubDEdgeTag) -> None: ...
    @overload
    def ToNurbsCurve(self, clampEnds: bool) -> NurbsCurve: ...
    @overload
    def ToString(self) -> str: ...


class SubDEdgeTag(Enum):
    Unset = 0
    Smooth = 1
    Crease = 2
    SmoothX = 4


class SubDEdgeType(Enum):
    Unset = 0
    Wire = 1
    Boundary = 2
    InteriorSmooth = 4
    InteriorSharp = 8
    InteriorCrease = 16
    InteriorMask = 28
    Nonmanifold = 32
    ValidTypesMask = 63
    Invalid = 64


class SubDEndCapStyle(Enum):
    Unset = 0
    # None = 1
    Triangles = 2
    Quads = 3
    Ngon = 4


class SubDFace(SubDComponent):
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def EdgeAt(self, index: int) -> SubDEdge: ...
    @overload
    def EdgeDirectionMatchesFaceOrientation(self, index: int) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def ControlNetCenterFrame(self) -> Plane: ...
    @overload
    @property
    def ControlNetCenterNormal(self) -> Vector3d: ...
    @overload
    @property
    def ControlNetCenterPoint(self) -> Point3d: ...
    @overload
    @property
    def EdgeCount(self) -> int: ...
    @overload
    @property
    def Id(self) -> int: ...
    @overload
    @property
    def IsDamaged(self) -> bool: ...
    @overload
    @property
    def IsDeleted(self) -> bool: ...
    @overload
    @property
    def IsHidden(self) -> bool: ...
    @overload
    @property
    def IsHighlighted(self) -> bool: ...
    @overload
    @property
    def IsLocked(self) -> bool: ...
    @overload
    @property
    def IsSelected(self) -> bool: ...
    @overload
    @property
    def LimitSurfaceCenterPoint(self) -> Point3d: ...
    @overload
    @property
    def ParentSubD(self) -> SubD: ...
    @overload
    @property
    def PerFaceColor(self) -> Color: ...
    @overload
    @property
    def SurfaceCenterFrame(self) -> Plane: ...
    @overload
    @property
    def SurfaceCenterNormal(self) -> Vector3d: ...
    @overload
    @property
    def VertexCount(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @PerFaceColor.setter
    def PerFaceColor(self, value: Color) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def VertexAt(self, index: int) -> SubDVertex: ...


class SubDFriendlyKnotType(Enum):
    Unset = 0
    UnclampedUniform = 1
    ClampedUniform = 2
    ClampedPiecewiseUniform = 4
    Unfriendly = 127


class SubDFromSurfaceMethods(Enum):
    Unset = 0
    SubDFriendlyFit = 1
    FromNurbsControlNet = 2


class SubDHashType(Enum):
    Unset = 0
    TopologyAndEdgeCreases = 1
    Geometry = 2
    Topology = 3


class SubDPatchStyle(Enum):
    Unset = 0
    Automatic = 1
    SingleFace = 2
    TriangleFan = 3
    QuadOrTriangleFan = 4
    Triangulated = 5


class SubDSurfaceInterpolator:
    @overload
    def __init__(self): ...
    @overload
    def Clear(self) -> None: ...
    @overload
    @staticmethod
    def CreateFromMarkedVertices(subd: SubD, interpolatedVerticesMark: bool) -> Tuple[SubDSurfaceInterpolator, int]: ...
    @overload
    @staticmethod
    def CreateFromSelectedVertices(subd: SubD) -> Tuple[SubDSurfaceInterpolator, int]: ...
    @overload
    @staticmethod
    def CreateFromSubD(subd: SubD) -> Tuple[SubDSurfaceInterpolator, int]: ...
    @overload
    @staticmethod
    def CreateFromVertexIdList(subd: SubD, vertexIndices: Iterable[int]) -> Tuple[SubDSurfaceInterpolator, int]: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def FixedVertexCount(self) -> int: ...
    @overload
    @property
    def ContextId(self) -> Guid: ...
    @overload
    @property
    def MaximumRecommendedInterpolatedVertexCount() -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def InterpolatedVertexCount(self) -> int: ...
    @overload
    def InterpolatedVertexIndex(self, vertexId: int) -> int: ...
    @overload
    def IsInterpolatedVertex(self, vertex: SubDVertex) -> bool: ...
    @overload
    def IsInterpolatedVertex(self, vertexId: int) -> bool: ...
    @overload
    @ContextId.setter
    def ContextId(self, value: Guid) -> None: ...
    @overload
    def Solve(self, surfacePoints: Iterable[Point3d]) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, transform: Transform) -> None: ...
    @overload
    def VertexIdList(self) -> Iterable[int]: ...


class SubDToBrepOptions:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, packFaces: bool, vertexProcess: ExtraordinaryVertexProcessOption): ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Default() -> SubDToBrepOptions: ...
    @overload
    @property
    def DefaultPacked() -> SubDToBrepOptions: ...
    @overload
    @property
    def DefaultUnpacked() -> SubDToBrepOptions: ...
    @overload
    @property
    def ExtraordinaryVertexProcess(self) -> ExtraordinaryVertexProcessOption: ...
    @overload
    @property
    def PackFaces(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @ExtraordinaryVertexProcess.setter
    def ExtraordinaryVertexProcess(self, value: ExtraordinaryVertexProcessOption) -> None: ...
    @overload
    @PackFaces.setter
    def PackFaces(self, value: bool) -> None: ...
    @overload
    def ToString(self) -> str: ...


class SubDVertex(SubDComponent):
    @overload
    def EdgeAt(self, index: int) -> SubDEdge: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def FaceAt(self, index: int) -> SubDFace: ...
    @overload
    @property
    def ControlNetPoint(self) -> Point3d: ...
    @overload
    @property
    def EdgeCount(self) -> int: ...
    @overload
    @property
    def Edges(self) -> Iterable[SubDEdge]: ...
    @overload
    @property
    def FaceCount(self) -> int: ...
    @overload
    @property
    def Id(self) -> int: ...
    @overload
    @property
    def IsDamaged(self) -> bool: ...
    @overload
    @property
    def IsDeleted(self) -> bool: ...
    @overload
    @property
    def IsHidden(self) -> bool: ...
    @overload
    @property
    def IsHighlighted(self) -> bool: ...
    @overload
    @property
    def IsLocked(self) -> bool: ...
    @overload
    @property
    def IsSelected(self) -> bool: ...
    @overload
    @property
    def Next(self) -> SubDVertex: ...
    @overload
    @property
    def ParentSubD(self) -> SubD: ...
    @overload
    @property
    def Previous(self) -> SubDVertex: ...
    @overload
    @property
    def Tag(self) -> SubDVertexTag: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @ControlNetPoint.setter
    def ControlNetPoint(self, value: Point3d) -> None: ...
    @overload
    @Tag.setter
    def Tag(self, value: SubDVertexTag) -> None: ...
    @overload
    def SetControlNetPoint(self, position: Point3d, bClearNeighborhoodCache: bool) -> bool: ...
    @overload
    def SurfacePoint(self) -> Point3d: ...
    @overload
    def ToString(self) -> str: ...


class SubDVertexFacetType(Enum):
    Unset = 0
    Tri = 3
    Quad = 4
    Ngon = 5
    Mixed = 255


class SubDVertexTag(Enum):
    Unset = 0
    Smooth = 1
    Crease = 2
    Corner = 3
    Dart = 4


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class SumSurface(Surface):
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(curveA: Curve, curveB: Curve) -> SumSurface: ...
    @overload
    @staticmethod
    def Create(curve: Curve, extrusionDirection: Vector3d) -> SumSurface: ...
    @overload
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def Degree(self, direction: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    @overload
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    @overload
    def FitCurveToSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], divideIntoSections: bool, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[Iterable[Curve], Curve, Curve]: ...
    @overload
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    @overload
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    @overload
    def IsAtSeam(self, u: float, v: float) -> int: ...
    @overload
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    @overload
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    @overload
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    @overload
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    @overload
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def RefitSimplySplitSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, knotAdditionMode: RefitTrimKnotMode, numInsertKnots: int, Knots: Iterable[float], sectionMode: RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Point3d, outputSurface: bool, outputCurve: bool, numSections: int, lowerSurface: List, upperSurface: List, edgeCurve: List, FitMeasurement: float, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[bool, int, float, Curve, Curve]: ...
    @overload
    def RefitSplit(self, curve: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], bMeetCurve: bool, divideIntoSections: bool, srfLower: List, srfUpper: List, edgeCurve: List, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[int, Curve, Curve]: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    @overload
    def SpanCount(self, direction: int) -> int: ...
    @overload
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    @overload
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class Surface(GeometryBase):
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def CreateExtrusion(profile: Curve, direction: Vector3d) -> Surface: ...
    @overload
    @staticmethod
    def CreateExtrusionToPoint(profile: Curve, apexPoint: Point3d) -> Surface: ...
    @overload
    @staticmethod
    def CreatePeriodicSurface(surface: Surface, direction: int) -> Surface: ...
    @overload
    @staticmethod
    def CreatePeriodicSurface(surface: Surface, direction: int, bSmooth: bool) -> Surface: ...
    @overload
    @staticmethod
    def CreateRollingBallFillet(surfaceA: Surface, surfaceB: Surface, radius: float, tolerance: float) -> Iterable[Surface]: ...
    @overload
    @staticmethod
    def CreateRollingBallFillet(surfaceA: Surface, flipA: bool, surfaceB: Surface, flipB: bool, radius: float, tolerance: float) -> Iterable[Surface]: ...
    @overload
    @staticmethod
    def CreateRollingBallFillet(surfaceA: Surface, uvA: Point2d, surfaceB: Surface, uvB: Point2d, radius: float, tolerance: float) -> Iterable[Surface]: ...
    @overload
    @staticmethod
    def CreateSoftEditSurface(surface: Surface, uv: Point2d, delta: Vector3d, uLength: float, vLength: float, tolerance: float, fixEnds: bool) -> Surface: ...
    @overload
    @staticmethod
    def CreateTweenSurfacesWithSampling(surface0: Surface, surface1: Surface, numSurfaces: int, numSamples: int, tolerance: float) -> Iterable[Surface]: ...
    @overload
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def Degree(self, direction: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    @overload
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    @overload
    def FitCurveToSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], divideIntoSections: bool, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[Iterable[Curve], Curve, Curve]: ...
    @overload
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    @overload
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    @overload
    def IsAtSeam(self, u: float, v: float) -> int: ...
    @overload
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    @overload
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    @overload
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    @overload
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    @overload
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def RefitSimplySplitSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, knotAdditionMode: RefitTrimKnotMode, numInsertKnots: int, Knots: Iterable[float], sectionMode: RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Point3d, outputSurface: bool, outputCurve: bool, numSections: int, lowerSurface: List, upperSurface: List, edgeCurve: List, FitMeasurement: float, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[bool, int, float, Curve, Curve]: ...
    @overload
    def RefitSplit(self, curve: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], bMeetCurve: bool, divideIntoSections: bool, srfLower: List, srfUpper: List, edgeCurve: List, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[int, Curve, Curve]: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    @overload
    def SpanCount(self, direction: int) -> int: ...
    @overload
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    @overload
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


class SurfaceCurvature:
    @overload
    def Direction(self, direction: int) -> Vector3d: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Gaussian(self) -> float: ...
    @overload
    @property
    def Mean(self) -> float: ...
    @overload
    @property
    def Normal(self) -> Vector3d: ...
    @overload
    @property
    def Point(self) -> Point3d: ...
    @overload
    @property
    def UVPoint(self) -> Point2d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Kappa(self, direction: int) -> float: ...
    @overload
    def OsculatingCircle(self, direction: int) -> Circle: ...
    @overload
    def ToString(self) -> str: ...


class SurfaceFilletBase:
    @overload
    @staticmethod
    def CreateG2ChordalQuinticFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: List, trimmedBrepsB: List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalCubicArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: List, trimmedBrepsB: List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalCubicFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: List, trimmedBrepsB: List, rail_degree: int, TanSlider: float, bTrim: bool, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalQuarticArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: List, trimmedBrepsB: List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalQuarticFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: List, trimmedBrepsB: List, rail_degree: int, TanSlider: float, InnerSlider: float, bTrim: bool, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalQuinticArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: List, trimmedBrepsB: List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalQuinticFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: List, trimmedBrepsB: List, rail_degree: int, TanSlider: float, InnerSlider: float, bTrim: bool, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    @staticmethod
    def CreateRationalArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: List, trimmedBrepsB: List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def G2ChordalQuintic(self, railDegree: int, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IsInitialized(self) -> bool: ...
    @overload
    def NonRationalCubic(self, railDegree: int, TanSlider: float, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    def NonRationalCubicArcs(self, railDegree: int, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    def NonRationalQuartic(self, railDegree: int, TanSlider: float, InnerSlider: float, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    def NonRationalQuarticArcs(self, railDegree: int, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    def NonRationalQuintic(self, railDegree: int, TanSlider: float, InnerSlider: float, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    def NonRationalQuinticArcs(self, railDegree: int, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    def RationalArcs(self, railDegree: int, bExtend: bool, Fillets: List) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def TrimBreps(self, bExtend: bool, TrimmedBreps0: List, TrimmedBreps1: List) -> bool: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class SurfaceProxy(Surface):
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def Degree(self, direction: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Iterable[Vector3d]]: ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    @overload
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    @overload
    def FitCurveToSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], divideIntoSections: bool, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[Iterable[Curve], Curve, Curve]: ...
    @overload
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsSolid(self) -> bool: ...
    @overload
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetSpanVector(self, direction: int) -> Iterable[float]: ...
    @overload
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    @overload
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def HasNurbsForm(self) -> int: ...
    @overload
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    @overload
    def IsAtSeam(self, u: float, v: float) -> int: ...
    @overload
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    @overload
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    @overload
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    @overload
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    @overload
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def RefitSimplySplitSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, knotAdditionMode: RefitTrimKnotMode, numInsertKnots: int, Knots: Iterable[float], sectionMode: RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Point3d, outputSurface: bool, outputCurve: bool, numSections: int, lowerSurface: List, upperSurface: List, edgeCurve: List, FitMeasurement: float, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[bool, int, float, Curve, Curve]: ...
    @overload
    def RefitSplit(self, curve: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Iterable[float], bMeetCurve: bool, divideIntoSections: bool, srfLower: List, srfUpper: List, edgeCurve: List, trimCurveOnSurface: Curve, splitCurve: Curve) -> Tuple[int, Curve, Curve]: ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    @overload
    def SpanCount(self, direction: int) -> int: ...
    @overload
    def Split(self, direction: int, parameter: float) -> Iterable[Surface]: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    @overload
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...


class SweepBlend(Enum):
    Local = 0
    Global = 1


class SweepFrame(Enum):
    Freeform = 0
    Roadlike = 1


class SweepMiter(Enum):
    # None = 0
    Trimmed = 1
    Untrimmed = 2


class SweepOneRail:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def AngleToleranceRadians(self) -> float: ...
    @overload
    @property
    def ClosedSweep(self) -> bool: ...
    @overload
    @property
    def GlobalShapeBlending(self) -> bool: ...
    @overload
    @property
    def IsFreeform(self) -> bool: ...
    @overload
    @property
    def IsRoadlike(self) -> bool: ...
    @overload
    @property
    def IsRoadlikeFront(self) -> bool: ...
    @overload
    @property
    def IsRoadlikeTop(self) -> bool: ...
    @overload
    @property
    def IsRoadlineRight(self) -> bool: ...
    @overload
    @property
    def MiterType(self) -> int: ...
    @overload
    @property
    def SweepTolerance(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSections: Iterable[Curve]) -> Iterable[Brep]: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSection: Curve) -> Iterable[Brep]: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSection: Curve, crossSectionParameter: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSections: Iterable[Curve], crossSectionParameters: Iterable[float]) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSections: Iterable[Curve], rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSection: Curve, rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSections: Iterable[Curve], crossSectionParameters: Iterable[float], rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSection: Curve, crossSectionParameter: float, rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSection: Curve, refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSections: Iterable[Curve], refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSections: Iterable[Curve], crossSectionParameters: Iterable[float], refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSection: Curve, crossSectionParameter: float, refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    @AngleToleranceRadians.setter
    def AngleToleranceRadians(self, value: float) -> None: ...
    @overload
    @ClosedSweep.setter
    def ClosedSweep(self, value: bool) -> None: ...
    @overload
    @GlobalShapeBlending.setter
    def GlobalShapeBlending(self, value: bool) -> None: ...
    @overload
    @MiterType.setter
    def MiterType(self, value: int) -> None: ...
    @overload
    @SweepTolerance.setter
    def SweepTolerance(self, value: float) -> None: ...
    @overload
    def SetRoadlikeUpDirection(self, up: Vector3d) -> None: ...
    @overload
    def SetToRoadlikeFront(self) -> None: ...
    @overload
    def SetToRoadlikeRight(self) -> None: ...
    @overload
    def SetToRoadlikeTop(self) -> None: ...
    @overload
    def ToString(self) -> str: ...


class SweepRebuild(Enum):
    # None = 0
    Rebuild = 1
    Refit = 2


class SweepTwoRail:
    @overload
    def __init__(self): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def AngleToleranceRadians(self) -> float: ...
    @overload
    @property
    def AutoAdjust(self) -> bool: ...
    @overload
    @property
    def ClosedSweep(self) -> bool: ...
    @overload
    @property
    def MaintainHeight(self) -> bool: ...
    @overload
    @property
    def SweepTolerance(self) -> float: ...
    @overload
    @property
    def UseLegacySweeper(self) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve]) -> Iterable[Brep]: ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSection: Curve) -> Iterable[Brep]: ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], crossSectionParameters1: Iterable[float], crossSectionParameters2: Iterable[float]) -> Iterable[Brep]: ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSection: Curve, rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float, rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], crossSectionParametersRail1: Iterable[float], crossSectionParametersRail2: Iterable[float], rebuildCount: int) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSection: Curve, refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float, refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], crossSectionParametersRail1: Iterable[float], crossSectionParametersRail2: Iterable[float], refitTolerance: float) -> Iterable[Brep]: ...
    @overload
    @AngleToleranceRadians.setter
    def AngleToleranceRadians(self, value: float) -> None: ...
    @overload
    @AutoAdjust.setter
    def AutoAdjust(self, value: bool) -> None: ...
    @overload
    @ClosedSweep.setter
    def ClosedSweep(self, value: bool) -> None: ...
    @overload
    @MaintainHeight.setter
    def MaintainHeight(self, value: bool) -> None: ...
    @overload
    @SweepTolerance.setter
    def SweepTolerance(self, value: float) -> None: ...
    @overload
    @UseLegacySweeper.setter
    def UseLegacySweeper(self, value: bool) -> None: ...
    @overload
    def ToString(self) -> str: ...


from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class TextDot(GeometryBase):
    @overload
    def __init__(self, text: str, location: Point3d): ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def FontFace(self) -> str: ...
    @overload
    @property
    def FontHeight(self) -> int: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def Point(self) -> Point3d: ...
    @overload
    @property
    def SecondaryText(self) -> str: ...
    @overload
    @property
    def Text(self) -> str: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @FontFace.setter
    def FontFace(self, value: str) -> None: ...
    @overload
    @FontHeight.setter
    def FontHeight(self, value: int) -> None: ...
    @overload
    @Point.setter
    def Point(self, value: Point3d) -> None: ...
    @overload
    @SecondaryText.setter
    def SecondaryText(self, value: str) -> None: ...
    @overload
    @Text.setter
    def Text(self, value: str) -> None: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...


from ..DocObjects import DimensionStyle
from ..DocObjects import TextHorizontalAlignment
from ..DocObjects import TextVerticalAlignment
from ..DocObjects import TextOrientation
from ..DocObjects import Field
from ..DocObjects import MaskType
from ..DocObjects import MaskFrame
from ..DocObjects import Font
from ..DocObjects import LengthDisplay
from ..DocObjects import ObjectType
from ..DocObjects.Custom import UserDataList
from ..Collections import ArchivableDictionary
from ..FileIO import SerializationOptions
class TextEntity(AnnotationBase):
    @overload
    def __init__(self): ...
    @overload
    def ClearPropertyOverrides(self) -> bool: ...
    @overload
    def ComponentIndex(self) -> ComponentIndex: ...
    @overload
    @staticmethod
    def Create(text: str, plane: Plane, style: DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> TextEntity: ...
    @overload
    def CreateCurves(self, dimstyle: DimensionStyle, allowOpen: bool, smallCapsScale: float, spacing: float) -> Iterable[Curve]: ...
    @overload
    def CreateCurvesGrouped(self, dimstyle: DimensionStyle, allowOpen: bool, smallCapsScale: float, spacing: float) -> List: ...
    @overload
    def CreateExtrusions(self, dimstyle: DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> Iterable[Extrusion]: ...
    @overload
    def CreateExtrusionsGrouped(self, dimstyle: DimensionStyle, smallCapsScale: float, height: float, spacing: float) -> List: ...
    @overload
    def CreatePolySurfaces(self, dimstyle: DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> Iterable[Brep]: ...
    @overload
    def CreatePolysurfacesGrouped(self, dimstyle: DimensionStyle, smallCapsScale: float, height: float, spacing: float) -> List: ...
    @overload
    def CreateSurfaces(self, dimstyle: DimensionStyle, smallCapsScale: float, spacing: float) -> Iterable[Brep]: ...
    @overload
    def CreateSurfacesGrouped(self, dimstyle: DimensionStyle, smallCapsScale: float, spacing: float) -> List: ...
    @overload
    @staticmethod
    def CreateWithRichText(richTextString: str, plane: Plane, style: DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> TextEntity: ...
    @overload
    def DataCRC(self, currentRemainder: int) -> int: ...
    @overload
    def DeleteAllUserStrings(self) -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Duplicate(self) -> GeometryBase: ...
    @overload
    def DuplicateShallow(self) -> GeometryBase: ...
    @overload
    def EnsurePrivateCopy(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Explode(self) -> Iterable[Curve]: ...
    @overload
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @overload
    @property
    def DecimalSeparator(self) -> Char: ...
    @overload
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @overload
    @property
    def DimensionScale(self) -> float: ...
    @overload
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def DimensionStyleId(self) -> Guid: ...
    @overload
    @property
    def Disposed(self) -> bool: ...
    @overload
    @property
    def DrawForward(self) -> bool: ...
    @overload
    @property
    def DrawTextFrame(self) -> bool: ...
    @overload
    @property
    def FirstCharFont(self) -> Font: ...
    @overload
    @property
    def Font(self) -> Font: ...
    @overload
    @property
    def FontIndex(self) -> int: ...
    @overload
    @property
    def FormatWidth(self) -> float: ...
    @overload
    @property
    def HasBrepForm(self) -> bool: ...
    @overload
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @overload
    @property
    def HasUserData(self) -> bool: ...
    @overload
    @property
    def IsDeformable(self) -> bool: ...
    @overload
    @property
    def IsDocumentControlled(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Justification(self) -> TextJustification: ...
    @overload
    @property
    def MaskColor(self) -> Color: ...
    @overload
    @property
    def MaskColorSource(self) -> MaskType: ...
    @overload
    @property
    def MaskEnabled(self) -> bool: ...
    @overload
    @property
    def MaskFrame(self) -> MaskFrame: ...
    @overload
    @property
    def MaskOffset(self) -> float: ...
    @overload
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @overload
    @property
    def ObjectType(self) -> ObjectType: ...
    @overload
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @overload
    @property
    def PlainText(self) -> str: ...
    @overload
    @property
    def PlainTextWithFields(self) -> str: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def RichText(self) -> str: ...
    @overload
    @property
    def Text(self) -> str: ...
    @overload
    @property
    def TextFormula(self) -> str: ...
    @overload
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @overload
    @property
    def TextHeight(self) -> float: ...
    @overload
    @property
    def TextHorizontalAlignment(self) -> TextHorizontalAlignment: ...
    @overload
    @property
    def TextIsWrapped(self) -> bool: ...
    @overload
    @property
    def TextModelWidth(self) -> float: ...
    @overload
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @overload
    @property
    def TextRotationDegrees(self) -> float: ...
    @overload
    @property
    def TextRotationRadians(self) -> float: ...
    @overload
    @property
    def TextVerticalAlignment(self) -> TextVerticalAlignment: ...
    @overload
    @property
    def UserData(self) -> UserDataList: ...
    @overload
    @property
    def UserDictionary(self) -> ArchivableDictionary: ...
    @overload
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @overload
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @overload
    def GetPlainTextWithRunMap(self, map: Iterable[int]) -> Tuple[str, Iterable[int]]: ...
    @overload
    def GetTextTransform(self, textscale: float, dimstyle: DimensionStyle) -> Transform: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings(self) -> NameValueCollection: ...
    @overload
    def IsAllBold(self) -> bool: ...
    @overload
    def IsAllItalic(self) -> bool: ...
    @overload
    def IsAllUnderlined(self) -> bool: ...
    @overload
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    @overload
    def IsValidWithLog(self) -> Tuple[bool, str]: ...
    @overload
    def MakeDeformable(self) -> bool: ...
    @overload
    def MemoryEstimate(self) -> int: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DecimalSeparator.setter
    def DecimalSeparator(self, value: Char) -> None: ...
    @overload
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @overload
    @DimensionScale.setter
    def DimensionScale(self, value: float) -> None: ...
    @overload
    @DimensionStyleId.setter
    def DimensionStyleId(self, value: Guid) -> None: ...
    @overload
    @DrawForward.setter
    def DrawForward(self, value: bool) -> None: ...
    @overload
    @DrawTextFrame.setter
    def DrawTextFrame(self, value: bool) -> None: ...
    @overload
    @Font.setter
    def Font(self, value: Font) -> None: ...
    @overload
    @FontIndex.setter
    def FontIndex(self, value: int) -> None: ...
    @overload
    @FormatWidth.setter
    def FormatWidth(self, value: float) -> None: ...
    @overload
    @Justification.setter
    def Justification(self, value: TextJustification) -> None: ...
    @overload
    @MaskColor.setter
    def MaskColor(self, value: Color) -> None: ...
    @overload
    @MaskColorSource.setter
    def MaskColorSource(self, value: MaskType) -> None: ...
    @overload
    @MaskEnabled.setter
    def MaskEnabled(self, value: bool) -> None: ...
    @overload
    @MaskFrame.setter
    def MaskFrame(self, value: MaskFrame) -> None: ...
    @overload
    @MaskOffset.setter
    def MaskOffset(self, value: float) -> None: ...
    @overload
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self, value: bool) -> None: ...
    @overload
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self, value: DimensionStyle) -> None: ...
    @overload
    @PlainText.setter
    def PlainText(self, value: str) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    @RichText.setter
    def RichText(self, value: str) -> None: ...
    @overload
    @Text.setter
    def Text(self, value: str) -> None: ...
    @overload
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @overload
    @TextHeight.setter
    def TextHeight(self, value: float) -> None: ...
    @overload
    @TextHorizontalAlignment.setter
    def TextHorizontalAlignment(self, value: TextHorizontalAlignment) -> None: ...
    @overload
    @TextIsWrapped.setter
    def TextIsWrapped(self, value: bool) -> None: ...
    @overload
    @TextOrientation.setter
    def TextOrientation(self, value: TextOrientation) -> None: ...
    @overload
    @TextRotationDegrees.setter
    def TextRotationDegrees(self, value: float) -> None: ...
    @overload
    @TextRotationRadians.setter
    def TextRotationRadians(self, value: float) -> None: ...
    @overload
    @TextVerticalAlignment.setter
    def TextVerticalAlignment(self, value: TextVerticalAlignment) -> None: ...
    @overload
    def SetBold(self, set_on: bool) -> bool: ...
    @overload
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    @overload
    def SetItalic(self, set_on: bool) -> bool: ...
    @overload
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    @overload
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    @overload
    def SetUnderline(self, set_on: bool) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def ToJSON(self, options: SerializationOptions) -> str: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Transform(self, transform: Transform, style: DimensionStyle) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    @overload
    def WrapText(self) -> None: ...


class TextJustification(Enum):
    # None = 0
    Left = 1
    Center = 2
    Right = 4
    Bottom = 65536
    BottomLeft = 65537
    BottomCenter = 65538
    BottomRight = 65540
    Middle = 131072
    MiddleLeft = 131073
    MiddleCenter = 131074
    MiddleRight = 131076
    Top = 262144
    TopLeft = 262145
    TopCenter = 262146
    TopRight = 262148


class TextRunType(Enum):
    # None = 0
    Text = 1
    Newline = 2
    Paragraph = 3
    Column = 4
    Field = 5
    Fontdef = 6
    Header = 7


class TextureCoordinateOption(Enum):
    Unset = 0
    # None = 1
    Automatic = 2
    Packed = 3
    CopyMapping = 4
    CopyCoordinates = 5


class Torus:
    @overload
    def __init__(self, basePlane: Plane, majorRadius: float, minorRadius: float): ...
    @overload
    def EpsilonEquals(self, other: Torus, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def MajorRadius(self) -> float: ...
    @overload
    @property
    def MinorRadius(self) -> float: ...
    @overload
    @property
    def Plane(self) -> Plane: ...
    @overload
    @property
    def Unset() -> Torus: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @MajorRadius.setter
    def MajorRadius(self, value: float) -> None: ...
    @overload
    @MinorRadius.setter
    def MinorRadius(self, value: float) -> None: ...
    @overload
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @overload
    def ToBrep(self) -> Brep: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToRevSurface(self) -> RevSurface: ...
    @overload
    def ToString(self) -> str: ...


class Transform:
    @overload
    def __init__(self, diagonalValue: float): ...
    @overload
    def __init__(self, value: Transform): ...
    @overload
    def Affineize(self) -> None: ...
    @overload
    @staticmethod
    def ChangeBasis(plane0: Plane, plane1: Plane) -> Transform: ...
    @overload
    @staticmethod
    def ChangeBasis(X0: Vector3d, Y0: Vector3d, Z0: Vector3d, X1: Vector3d, Y1: Vector3d, Z1: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def ChangeBasis(P0: Point3d, X0: Vector3d, Y0: Vector3d, Z0: Vector3d, P1: Point3d, X1: Vector3d, Y1: Vector3d, Z1: Vector3d) -> Transform: ...
    @overload
    def Clone(self) -> Transform: ...
    @overload
    def CompareTo(self, other: Transform) -> int: ...
    @overload
    def DecomposeAffine(self) -> Tuple[bool, Vector3d, Transform]: ...
    @overload
    def DecomposeAffine(self) -> Tuple[bool, Transform, Vector3d]: ...
    @overload
    def DecomposeAffine(self) -> Tuple[bool, Vector3d, Transform, Transform, Vector3d]: ...
    @overload
    def DecomposeRigid(self, tolerance: float) -> Tuple[TransformRigidType, Vector3d, Transform]: ...
    @overload
    def DecomposeSimilarity(self, tolerance: float) -> Tuple[TransformSimilarityType, Vector3d, float, Transform]: ...
    @overload
    def DecomposeSymmetric(self) -> Tuple[bool, Transform, Vector3d]: ...
    @overload
    def DecomposeTextureMapping(self) -> Tuple[Vector3d, Vector3d, Vector3d]: ...
    @overload
    @staticmethod
    def Diagonal(diagonal: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def Diagonal(d0: float, d1: float, d2: float) -> Transform: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: Transform) -> bool: ...
    @overload
    @property
    def Determinant(self) -> float: ...
    @overload
    @property
    def Identity() -> Transform: ...
    @overload
    @property
    def IsAffine(self) -> bool: ...
    @overload
    @property
    def IsIdentity(self) -> bool: ...
    @overload
    @property
    def IsLinear(self) -> bool: ...
    @overload
    @property
    def IsRotation(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def IsZero(self) -> bool: ...
    @overload
    @property
    def IsZero4x4(self) -> bool: ...
    @overload
    @property
    def IsZeroTransformation(self) -> bool: ...
    @overload
    @property
    def Item(self, row: int, column: int) -> float: ...
    @overload
    @property
    def M00(self) -> float: ...
    @overload
    @property
    def M01(self) -> float: ...
    @overload
    @property
    def M02(self) -> float: ...
    @overload
    @property
    def M03(self) -> float: ...
    @overload
    @property
    def M10(self) -> float: ...
    @overload
    @property
    def M11(self) -> float: ...
    @overload
    @property
    def M12(self) -> float: ...
    @overload
    @property
    def M13(self) -> float: ...
    @overload
    @property
    def M20(self) -> float: ...
    @overload
    @property
    def M21(self) -> float: ...
    @overload
    @property
    def M22(self) -> float: ...
    @overload
    @property
    def M23(self) -> float: ...
    @overload
    @property
    def M30(self) -> float: ...
    @overload
    @property
    def M31(self) -> float: ...
    @overload
    @property
    def M32(self) -> float: ...
    @overload
    @property
    def M33(self) -> float: ...
    @overload
    @property
    def RigidType(self) -> TransformRigidType: ...
    @overload
    @property
    def SimilarityType(self) -> TransformSimilarityType: ...
    @overload
    @property
    def Unset() -> Transform: ...
    @overload
    @property
    def ZeroTransformation() -> Transform: ...
    @overload
    def GetEulerZYZ(self) -> Tuple[bool, float, float, float]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetQuaternion(self) -> Tuple[bool, Quaternion]: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def GetYawPitchRoll(self) -> Tuple[bool, float, float, float]: ...
    @overload
    def IsRigid(self, tolerance: float) -> TransformRigidType: ...
    @overload
    def IsSimilarity(self, tolerance: float) -> TransformSimilarityType: ...
    @overload
    def IsZeroTransformationWithTolerance(self, zeroTolerance: float) -> bool: ...
    @overload
    def Linearize(self) -> None: ...
    @overload
    @staticmethod
    def Mirror(mirrorPlane: Plane) -> Transform: ...
    @overload
    @staticmethod
    def Mirror(pointOnMirrorPlane: Point3d, normalToMirrorPlane: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def Multiply(a: Transform, b: Transform) -> Transform: ...
    @overload
    def __eq__(a: Transform, b: Transform) -> bool: ...
    @overload
    def __ne__(a: Transform, b: Transform) -> bool: ...
    @overload
    def __mul__(m: Transform, p: Point3d) -> Point3d: ...
    @overload
    def __mul__(a: Transform, b: Transform) -> Transform: ...
    @overload
    def __mul__(m: Transform, v: Vector3d) -> Vector3d: ...
    @overload
    def Orthogonalize(self, tolerance: float) -> bool: ...
    @overload
    @staticmethod
    def PlanarProjection(plane: Plane) -> Transform: ...
    @overload
    @staticmethod
    def PlaneToPlane(plane0: Plane, plane1: Plane) -> Transform: ...
    @overload
    @staticmethod
    def ProjectAlong(plane: Plane, direction: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(angleRadians: float, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(startDirection: Vector3d, endDirection: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(sinAngle: float, cosAngle: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(x0: Vector3d, y0: Vector3d, z0: Vector3d, x1: Vector3d, y1: Vector3d, z1: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def RotationZYX(yaw: float, pitch: float, roll: float) -> Transform: ...
    @overload
    @staticmethod
    def RotationZYZ(alpha: float, beta: float, gamma: float) -> Transform: ...
    @overload
    @staticmethod
    def Scale(anchor: Point3d, scaleFactor: float) -> Transform: ...
    @overload
    @staticmethod
    def Scale(plane: Plane, xScaleFactor: float, yScaleFactor: float, zScaleFactor: float) -> Transform: ...
    @overload
    @Item.setter
    def Item(self, row: int, column: int, value: float) -> None: ...
    @overload
    @M00.setter
    def M00(self, value: float) -> None: ...
    @overload
    @M01.setter
    def M01(self, value: float) -> None: ...
    @overload
    @M02.setter
    def M02(self, value: float) -> None: ...
    @overload
    @M03.setter
    def M03(self, value: float) -> None: ...
    @overload
    @M10.setter
    def M10(self, value: float) -> None: ...
    @overload
    @M11.setter
    def M11(self, value: float) -> None: ...
    @overload
    @M12.setter
    def M12(self, value: float) -> None: ...
    @overload
    @M13.setter
    def M13(self, value: float) -> None: ...
    @overload
    @M20.setter
    def M20(self, value: float) -> None: ...
    @overload
    @M21.setter
    def M21(self, value: float) -> None: ...
    @overload
    @M22.setter
    def M22(self, value: float) -> None: ...
    @overload
    @M23.setter
    def M23(self, value: float) -> None: ...
    @overload
    @M30.setter
    def M30(self, value: float) -> None: ...
    @overload
    @M31.setter
    def M31(self, value: float) -> None: ...
    @overload
    @M32.setter
    def M32(self, value: float) -> None: ...
    @overload
    @M33.setter
    def M33(self, value: float) -> None: ...
    @overload
    @staticmethod
    def Shear(plane: Plane, x: Vector3d, y: Vector3d, z: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def TextureMapping(offset: Vector3d, repeat: Vector3d, rotation: Vector3d) -> Transform: ...
    @overload
    def ToDoubleArray(self, rowDominant: bool) -> Iterable[float]: ...
    @overload
    def ToFloatArray(self, rowDominant: bool) -> Iterable[float]: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def TransformBoundingBox(self, bbox: BoundingBox) -> BoundingBox: ...
    @overload
    def TransformList(self, points: Iterable[Point3d]) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def Translation(motion: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def Translation(dx: float, dy: float, dz: float) -> Transform: ...
    @overload
    def Transpose(self) -> Transform: ...
    @overload
    def TryGetInverse(self) -> Tuple[bool, Transform]: ...


class TransformRigidType(Enum):
    NotRigid = 0
    Rigid = 1
    RigidReversing = -1


class TransformSimilarityType(Enum):
    NotSimilarity = 0
    OrientationPreserving = 1
    OrientationReversing = -1


class Triangle3d:
    @overload
    def __init__(self, a: Point3d, b: Point3d, c: Point3d): ...
    @overload
    def BarycentricCoordsAt(self, point: Point3d) -> Tuple[Point2d, float]: ...
    @overload
    def ClosestParameterOnBoundary(self, point: Point3d) -> float: ...
    @overload
    def ClosestPointOnBoundary(self, point: Point3d) -> Point3d: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def A(self) -> Point3d: ...
    @overload
    @property
    def AB(self) -> Line: ...
    @overload
    @property
    def AltitudeA(self) -> Line: ...
    @overload
    @property
    def AltitudeB(self) -> Line: ...
    @overload
    @property
    def AltitudeC(self) -> Line: ...
    @overload
    @property
    def AngleA(self) -> float: ...
    @overload
    @property
    def AngleB(self) -> float: ...
    @overload
    @property
    def AngleC(self) -> float: ...
    @overload
    @property
    def Area(self) -> float: ...
    @overload
    @property
    def AreaCenter(self) -> Point3d: ...
    @overload
    @property
    def B(self) -> Point3d: ...
    @overload
    @property
    def BC(self) -> Line: ...
    @overload
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @overload
    @property
    def C(self) -> Point3d: ...
    @overload
    @property
    def CA(self) -> Line: ...
    @overload
    @property
    def Circumcenter(self) -> Point3d: ...
    @overload
    @property
    def Circumcircle(self) -> Circle: ...
    @overload
    @property
    def MedianA(self) -> Line: ...
    @overload
    @property
    def MedianB(self) -> Line: ...
    @overload
    @property
    def MedianC(self) -> Line: ...
    @overload
    @property
    def Orthocenter(self) -> Point3d: ...
    @overload
    @property
    def Perimeter(self) -> float: ...
    @overload
    @property
    def PerpendicularAB(self) -> Line: ...
    @overload
    @property
    def PerpendicularBC(self) -> Line: ...
    @overload
    @property
    def PerpendicularCA(self) -> Line: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def PointAlongBoundary(self, t: float) -> Point3d: ...
    @overload
    def PointAtBarycentricCoords(self, coords: Point2d) -> Point3d: ...
    @overload
    def PointOnInterior(self, u: float, v: float) -> Point3d: ...
    @overload
    def ToMesh(self) -> Mesh: ...
    @overload
    def ToPolyline(self) -> Polyline: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, transform: Transform) -> Triangle3d: ...
    @overload
    @staticmethod
    def TrySmallestEnclosingTriangle(points: Iterable[Point2d], tolerance: float) -> Tuple[bool, Triangle3d]: ...
    @overload
    def WithA(self, a: Point3d) -> Triangle3d: ...
    @overload
    def WithB(self, b: Point3d) -> Triangle3d: ...
    @overload
    def WithC(self, c: Point3d) -> Triangle3d: ...


class Unroller:
    @overload
    def __init__(self, surface: Surface): ...
    @overload
    def __init__(self, brep: Brep): ...
    @overload
    def AddFollowingGeometry(self, curves: Iterable[Curve]) -> None: ...
    @overload
    def AddFollowingGeometry(self, curve: Curve) -> None: ...
    @overload
    def AddFollowingGeometry(self, points: Iterable[Point3d]) -> None: ...
    @overload
    def AddFollowingGeometry(self, point: Point3d) -> None: ...
    @overload
    def AddFollowingGeometry(self, point: Point) -> None: ...
    @overload
    def AddFollowingGeometry(self, dots: Iterable[TextDot]) -> None: ...
    @overload
    def AddFollowingGeometry(self, dot: TextDot) -> None: ...
    @overload
    def AddFollowingGeometry(self, dotLocations: Iterable[Point3d], dotText: Iterable[str]) -> None: ...
    @overload
    def AddFollowingGeometry(self, dotLocation: Point3d, dotText: str) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def FollowingGeometryIndex(self, curve: Curve) -> int: ...
    @overload
    def FollowingGeometryIndex(self, dot: TextDot) -> int: ...
    @overload
    @property
    def AbsoluteTolerance(self) -> float: ...
    @overload
    @property
    def ExplodeOutput(self) -> bool: ...
    @overload
    @property
    def ExplodeSpacing(self) -> float: ...
    @overload
    @property
    def RelativeTolerance(self) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def PerformUnroll(self, flatbreps: List) -> int: ...
    @overload
    def PerformUnroll(self) -> Tuple[Iterable[Brep], Iterable[Curve], Iterable[Point3d], Iterable[TextDot]]: ...
    @overload
    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, value: float) -> None: ...
    @overload
    @ExplodeOutput.setter
    def ExplodeOutput(self, value: bool) -> None: ...
    @overload
    @ExplodeSpacing.setter
    def ExplodeSpacing(self, value: float) -> None: ...
    @overload
    @RelativeTolerance.setter
    def RelativeTolerance(self, value: float) -> None: ...
    @overload
    def ToString(self) -> str: ...


class Vector2d:
    @overload
    def __init__(self, x: float, y: float): ...
    @overload
    @staticmethod
    def Add(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    @overload
    def CompareTo(self, other: Vector2d) -> int: ...
    @overload
    @staticmethod
    def Divide(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    def EpsilonEquals(self, other: Vector2d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, vector: Vector2d) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def Length(self) -> float: ...
    @overload
    @property
    def SquareLength(self) -> float: ...
    @overload
    @property
    def Unset() -> Vector2d: ...
    @overload
    @property
    def X(self) -> float: ...
    @overload
    @property
    def Y(self) -> float: ...
    @overload
    @property
    def Zero() -> Vector2d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IsTiny(self) -> bool: ...
    @overload
    def IsTiny(self, tolerance: float) -> bool: ...
    @overload
    @staticmethod
    def Multiply(vector1: Vector2d, vector2: Vector2d) -> float: ...
    @overload
    @staticmethod
    def Multiply(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    @staticmethod
    def Multiply(t: float, vector: Vector2d) -> Vector2d: ...
    @overload
    @staticmethod
    def Negate(vector: Vector2d) -> Vector2d: ...
    @overload
    def __add__(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    @overload
    def __truediv__(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    def __eq__(a: Vector2d, b: Vector2d) -> bool: ...
    @overload
    def __gt__(a: Vector2d, b: Vector2d) -> bool: ...
    @overload
    def __ge__(a: Vector2d, b: Vector2d) -> bool: ...
    @overload
    def __ne__(a: Vector2d, b: Vector2d) -> bool: ...
    @overload
    def __lt__(a: Vector2d, b: Vector2d) -> bool: ...
    @overload
    def __le__(a: Vector2d, b: Vector2d) -> bool: ...
    @overload
    def __rmul__(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    def __mul__(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    def __mul__(vector1: Vector2d, vector2: Vector2d) -> float: ...
    @overload
    def __sub__(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    @overload
    def __neg__(vector: Vector2d) -> Vector2d: ...
    @overload
    def Rotate(self, angleRadians: float) -> bool: ...
    @overload
    @X.setter
    def X(self, value: float) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    @staticmethod
    def Subtract(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @overload
    def Unitize(self) -> bool: ...


class Vector2f:
    @overload
    def __init__(self, x: float, y: float): ...
    @overload
    @staticmethod
    def Add(point: Point2f, vector: Vector2f) -> Point2f: ...
    @overload
    @staticmethod
    def Add(vector1: Vector2f, vector2: Vector2f) -> Vector2f: ...
    @overload
    def CompareTo(self, other: Vector2f) -> int: ...
    @overload
    def EpsilonEquals(self, other: Vector2f, epsilon: float) -> bool: ...
    @overload
    def Equals(self, vector: Vector2f) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def IsUnitVector(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def IsZero(self) -> bool: ...
    @overload
    @property
    def Length(self) -> float: ...
    @overload
    @property
    def SquareLength(self) -> float: ...
    @overload
    @property
    def Unset() -> Vector2f: ...
    @overload
    @property
    def X(self) -> float: ...
    @overload
    @property
    def XAxis() -> Vector2f: ...
    @overload
    @property
    def Y(self) -> float: ...
    @overload
    @property
    def YAxis() -> Vector2f: ...
    @overload
    @property
    def Zero() -> Vector2f: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Multiply(point1: Vector2f, point2: Vector2f) -> float: ...
    @overload
    @staticmethod
    def Negate(vector: Vector2f) -> Vector2f: ...
    @overload
    def __add__(a: Vector2f, b: Vector2f) -> Vector2f: ...
    @overload
    def __radd__(vector: Vector2f, point: Point2f) -> Point2f: ...
    @overload
    def __eq__(a: Vector2f, b: Vector2f) -> bool: ...
    @overload
    def __gt__(a: Vector2f, b: Vector2f) -> bool: ...
    @overload
    def __ge__(a: Vector2f, b: Vector2f) -> bool: ...
    @overload
    def __ne__(a: Vector2f, b: Vector2f) -> bool: ...
    @overload
    def __lt__(a: Vector2f, b: Vector2f) -> bool: ...
    @overload
    def __le__(a: Vector2f, b: Vector2f) -> bool: ...
    @overload
    def __mul__(point1: Vector2f, point2: Vector2f) -> float: ...
    @overload
    def __sub__(a: Vector2f, b: Vector2f) -> Vector2f: ...
    @overload
    def __neg__(vector: Vector2f) -> Vector2f: ...
    @overload
    def PerpendicularTo(self, other: Vector2f) -> bool: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    @X.setter
    def X(self, value: float) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    @staticmethod
    def Subtract(vector1: Vector2f, vector2: Vector2f) -> Vector2f: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @overload
    def Unitize(self) -> bool: ...


class Vector3d:
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, vector: Vector3f): ...
    @overload
    def __init__(self, vector: Vector3d): ...
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    @staticmethod
    def Add(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    @overload
    @staticmethod
    def AreOrthogonal(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    @overload
    @staticmethod
    def AreOrthonormal(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    @overload
    @staticmethod
    def AreRighthanded(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    @overload
    def CompareTo(self, other: Vector3d) -> int: ...
    @overload
    @staticmethod
    def CrossProduct(a: Vector3d, b: Vector3d) -> Vector3d: ...
    @overload
    @staticmethod
    def Divide(vector: Vector3d, t: float) -> Vector3d: ...
    @overload
    def EpsilonEquals(self, other: Vector3d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, vector: Vector3d) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def IsUnitVector(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def IsZero(self) -> bool: ...
    @overload
    @overload
    @property
    def Length(self) -> float: ...
    @overload
    @property
    def MaximumCoordinate(self) -> float: ...
    @overload
    @property
    def MinimumCoordinate(self) -> float: ...
    @overload
    @property
    def SquareLength(self) -> float: ...
    @overload
    @property
    def Unset() -> Vector3d: ...
    @overload
    @property
    def X(self) -> float: ...
    @overload
    @property
    def XAxis() -> Vector3d: ...
    @overload
    @property
    def Y(self) -> float: ...
    @overload
    @property
    def YAxis() -> Vector3d: ...
    @overload
    @property
    def Z(self) -> float: ...
    @overload
    @property
    def ZAxis() -> Vector3d: ...
    @overload
    @property
    def Zero() -> Vector3d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def IsParallelTo(self, other: Vector3d) -> int: ...
    @overload
    def IsParallelTo(self, other: Vector3d, angleTolerance: float) -> int: ...
    @overload
    def IsPerpendicularTo(self, other: Vector3d) -> bool: ...
    @overload
    def IsPerpendicularTo(self, other: Vector3d, angleTolerance: float) -> bool: ...
    @overload
    def IsTiny(self) -> bool: ...
    @overload
    def IsTiny(self, tolerance: float) -> bool: ...
    @overload
    @staticmethod
    def Multiply(vector: Vector3d, t: float) -> Vector3d: ...
    @overload
    @staticmethod
    def Multiply(t: float, vector: Vector3d) -> Vector3d: ...
    @overload
    @staticmethod
    def Multiply(vector1: Vector3d, vector2: Vector3d) -> float: ...
    @overload
    @staticmethod
    def Negate(vector: Vector3d) -> Vector3d: ...
    @overload
    def __add__(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    @overload
    def __truediv__(vector: Vector3d, t: float) -> Vector3d: ...
    @overload
    def __eq__(a: Vector3d, b: Vector3d) -> bool: ...
    @overload
    def __gt__(a: Vector3d, b: Vector3d) -> bool: ...
    @overload
    def __ge__(a: Vector3d, b: Vector3d) -> bool: ...
    @overload
    def op_Implicit(vector: Vector3f) -> Vector3d: ...
    @overload
    def __ne__(a: Vector3d, b: Vector3d) -> bool: ...
    @overload
    def __lt__(a: Vector3d, b: Vector3d) -> bool: ...
    @overload
    def __le__(a: Vector3d, b: Vector3d) -> bool: ...
    @overload
    def __mul__(vector: Vector3d, t: float) -> Vector3d: ...
    @overload
    def __mul__(vector1: Vector3d, vector2: Vector3d) -> float: ...
    @overload
    def __rmul__(vector: Vector3d, t: float) -> Vector3d: ...
    @overload
    def __sub__(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    @overload
    def __neg__(vector: Vector3d) -> Vector3d: ...
    @overload
    def PerpendicularTo(self, other: Vector3d) -> bool: ...
    @overload
    def PerpendicularTo(self, point0: Point3d, point1: Point3d, point2: Point3d) -> bool: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d) -> bool: ...
    @overload
    @property
    def Item(self) -> MutableSequence[float]: ...
    @overload
    @X.setter
    def X(self, value: float) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    @Z.setter
    def Z(self, value: float) -> None: ...
    @overload
    @staticmethod
    def Subtract(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @overload
    def Transform(self, transformation: Transform) -> None: ...
    @overload
    def Unitize(self) -> bool: ...
    @overload
    @staticmethod
    def VectorAngle(a: Vector3d, b: Vector3d) -> float: ...
    @overload
    @staticmethod
    def VectorAngle(v1: Vector3d, v2: Vector3d, vNormal: Vector3d) -> float: ...
    @overload
    @staticmethod
    def VectorAngle(a: Vector3d, b: Vector3d, plane: Plane) -> float: ...


class Vector3f:
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    @staticmethod
    def Add(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    @overload
    @staticmethod
    def Add(point: Point3f, vector: Vector3f) -> Point3f: ...
    @overload
    def CompareTo(self, other: Vector3f) -> int: ...
    @overload
    @staticmethod
    def CrossProduct(a: Vector3f, b: Vector3f) -> Vector3f: ...
    @overload
    @staticmethod
    def Divide(vector: Vector3f, t: float) -> Vector3f: ...
    @overload
    @staticmethod
    def Divide(vector: Vector3f, t: float) -> Vector3f: ...
    @overload
    def EpsilonEquals(self, other: Vector3f, epsilon: float) -> bool: ...
    @overload
    def Equals(self, vector: Vector3f) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def IsUnitVector(self) -> bool: ...
    @overload
    @property
    def IsValid(self) -> bool: ...
    @overload
    @property
    def IsZero(self) -> bool: ...
    @overload
    @property
    def Length(self) -> float: ...
    @overload
    @property
    def SquareLength(self) -> float: ...
    @overload
    @property
    def Unset() -> Vector3f: ...
    @overload
    @property
    def X(self) -> float: ...
    @overload
    @property
    def XAxis() -> Vector3f: ...
    @overload
    @property
    def Y(self) -> float: ...
    @overload
    @property
    def YAxis() -> Vector3f: ...
    @overload
    @property
    def Z(self) -> float: ...
    @overload
    @property
    def ZAxis() -> Vector3f: ...
    @overload
    @property
    def Zero() -> Vector3f: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Multiply(t: float, vector: Vector3f) -> Vector3f: ...
    @overload
    @staticmethod
    def Multiply(vector: Vector3f, t: float) -> Vector3f: ...
    @overload
    @staticmethod
    def Multiply(point1: Vector3f, point2: Vector3f) -> float: ...
    @overload
    @staticmethod
    def Negate(vector: Vector3f) -> Vector3f: ...
    @overload
    def __add__(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    @overload
    def __radd__(vector: Vector3f, point: Point3f) -> Point3f: ...
    @overload
    def __truediv__(vector: Vector3f, t: float) -> Vector3f: ...
    @overload
    def __truediv__(vector: Vector3f, t: float) -> Vector3f: ...
    @overload
    def __eq__(a: Vector3f, b: Vector3f) -> bool: ...
    @overload
    def op_Explicit(vector: Vector3d) -> Vector3f: ...
    @overload
    def __gt__(a: Vector3f, b: Vector3f) -> bool: ...
    @overload
    def __ge__(a: Vector3f, b: Vector3f) -> bool: ...
    @overload
    def __ne__(a: Vector3f, b: Vector3f) -> bool: ...
    @overload
    def __lt__(a: Vector3f, b: Vector3f) -> bool: ...
    @overload
    def __le__(a: Vector3f, b: Vector3f) -> bool: ...
    @overload
    def __rmul__(vector: Vector3f, t: float) -> Vector3f: ...
    @overload
    def __mul__(vector: Vector3f, t: float) -> Vector3f: ...
    @overload
    def __mul__(point1: Vector3f, point2: Vector3f) -> float: ...
    @overload
    def __sub__(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    @overload
    def __neg__(vector: Vector3f) -> Vector3f: ...
    @overload
    def PerpendicularTo(self, other: Vector3f) -> bool: ...
    @overload
    def Reverse(self) -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3f) -> bool: ...
    @overload
    @X.setter
    def X(self, value: float) -> None: ...
    @overload
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    @Z.setter
    def Z(self, value: float) -> None: ...
    @overload
    @staticmethod
    def Subtract(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @overload
    def Transform(self, transformation: Transform) -> None: ...
    @overload
    def Unitize(self) -> bool: ...


class Visibility(Enum):
    Unset = 0
    Visible = 1
    Hidden = 2
    Duplicate = 3


class Visibility(Enum):
    Unset = 0
    Visible = 1
    Hidden = 2
    Duplicate = 3
    Projecting = 4
    Clipped = 5


class VolumeMassProperties:
    @overload
    def CentroidCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    def CentroidCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Iterable[GeometryBase]) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Iterable[GeometryBase], volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool, relativeTolerance: float, absoluteTolerance: float) -> VolumeMassProperties: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @property
    def Centroid(self) -> Point3d: ...
    @overload
    @property
    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...
    @overload
    @property
    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def CentroidError(self) -> Vector3d: ...
    @overload
    @property
    def Volume(self) -> float: ...
    @overload
    @property
    def VolumeError(self) -> float: ...
    @overload
    @property
    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesProductMoments(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...
    @overload
    @property
    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def Sum(self, summand: VolumeMassProperties) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def WorldCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    @overload
    def WorldCoordinatesPrincipalMomentsOfInertia(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
