from typing import overload, Any, Iterable, Iterator, Sequence, MutableSequence, Callable
from enum import Enum

from Rhino.DocObjects import RhinoObject
from Rhino.FileIO import TextLog
from Rhino.Geometry import Arc
from Rhino.Geometry import BoundingBox
from Rhino.Geometry import Box
from Rhino.Geometry import Brep
from Rhino.Geometry import BrepFace
from Rhino.Geometry import Circle
from Rhino.Geometry import Curve
from Rhino.Geometry import Cylinder
from Rhino.Geometry import Interval
from Rhino.Geometry import Line
from Rhino.Geometry import Mesh
from Rhino.Geometry import MeshingParameters
from Rhino.Geometry import MeshType
from Rhino.Geometry import Plane
from Rhino.Geometry import Point3d
from Rhino.Geometry import Polyline
from Rhino.Geometry import PolylineCurve
from Rhino.Geometry import Ray3d
from Rhino.Geometry import Sphere
from Rhino.Geometry import Surface
from Rhino.Geometry import Vector3d
from System import IFormatProvider
from System import IProgress
from System import TypeCode
from System.Threading import CancellationToken



class ArcArcIntersection(Enum):
    # None = 0
    Single = 1
    Multiple = 2
    Overlap = 3


class CircleCircleIntersection(Enum):
    # None = 0
    Single = 1
    Multiple = 2
    Overlap = 3


class CurveIntersections:
    def __iter__(self) -> Iterator[IntersectionEvent]: ...
    def __getitem__(self, index: int) -> IntersectionEvent: ...
    def __setitem__(self, index: int, value: IntersectionEvent): ...
    @overload
    def CopyTo(self, array: Iterable[IntersectionEvent], arrayIndex: int) -> None: ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> Sequence[IntersectionEvent]: ...
    @overload
    def GetEnumerator(self) -> Iterator[IntersectionEvent]: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class Intersection:
    @overload
    @staticmethod
    def ArcArc(arcA: Arc, arcB: Arc) -> tuple[ArcArcIntersection, Point3d, Point3d]: ...
    @overload
    @staticmethod
    def BrepBrep(brepA: Brep, brepB: Brep, tolerance: float) -> tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def BrepBrep(brepA: Brep, brepB: Brep, tolerance: float, joinCurves: bool) -> tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def BrepPlane(brep: Brep, plane: Plane, tolerance: float) -> tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def BrepSurface(brep: Brep, surface: Surface, tolerance: float) -> tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def BrepSurface(brep: Brep, surface: Surface, tolerance: float, joinCurves: bool) -> tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def CircleCircle(circleA: Circle, circleB: Circle) -> tuple[CircleCircleIntersection, Point3d, Point3d]: ...
    @overload
    @staticmethod
    def CurveBrep(curve: Curve, brep: Brep, tolerance: float) -> tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def CurveBrep(curve: Curve, brep: Brep, tolerance: float, angleTolerance: float) -> tuple[bool, Iterable[float]]: ...
    @overload
    @staticmethod
    def CurveBrep(curve: Curve, brep: Brep, tolerance: float) -> tuple[bool, Iterable[Curve], Iterable[Point3d], Iterable[float]]: ...
    @overload
    @staticmethod
    def CurveBrepFace(curve: Curve, face: BrepFace, tolerance: float) -> tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    @staticmethod
    def CurveCurve(curveA: Curve, curveB: Curve, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurveCurveValidate(curveA: Curve, curveB: Curve, tolerance: float, overlapTolerance: float) -> tuple[CurveIntersections, Iterable[int], TextLog]: ...
    @overload
    @staticmethod
    def CurveLine(curve: Curve, line: Line, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurvePlane(curve: Curve, plane: Plane, tolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurveSelf(curve: Curve, tolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurveSurface(curve: Curve, surface: Surface, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurveSurface(curve: Curve, curveDomain: Interval, surface: Surface, tolerance: float, overlapTolerance: float) -> CurveIntersections: ...
    @overload
    @staticmethod
    def CurveSurfaceValidate(curve: Curve, surface: Surface, tolerance: float, overlapTolerance: float) -> tuple[CurveIntersections, Iterable[int], TextLog]: ...
    @overload
    @staticmethod
    def CurveSurfaceValidate(curve: Curve, curveDomain: Interval, surface: Surface, tolerance: float, overlapTolerance: float) -> tuple[CurveIntersections, Iterable[int], TextLog]: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    @classmethod
    def MeshIntersectionsTolerancesCoefficient(cls) -> float: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def LineBox(line: Line, box: BoundingBox, tolerance: float) -> tuple[bool, Interval]: ...
    @overload
    @staticmethod
    def LineBox(line: Line, box: Box, tolerance: float) -> tuple[bool, Interval]: ...
    @overload
    @staticmethod
    def LineCircle(line: Line, circle: Circle) -> tuple[LineCircleIntersection, float, Point3d, float, Point3d]: ...
    @overload
    @staticmethod
    def LineCylinder(line: Line, cylinder: Cylinder) -> tuple[LineCylinderIntersection, Point3d, Point3d]: ...
    @overload
    @staticmethod
    def LineLine(lineA: Line, lineB: Line) -> tuple[bool, float, float]: ...
    @overload
    @staticmethod
    def LineLine(lineA: Line, lineB: Line, tolerance: float, finiteSegments: bool) -> tuple[bool, float, float]: ...
    @overload
    @staticmethod
    def LinePlane(line: Line, plane: Plane) -> tuple[bool, float]: ...
    @overload
    @staticmethod
    def LineSphere(line: Line, sphere: Sphere) -> tuple[LineSphereIntersection, Point3d, Point3d]: ...
    @overload
    @staticmethod
    def MeshLine(mesh: Mesh, line: Line) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def MeshLine(mesh: Mesh, line: Line) -> tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def MeshLineSorted(mesh: Mesh, line: Line) -> tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def MeshMesh(meshes: Iterable[Mesh], tolerance: float, overlapsPolylines: bool, overlapsMesh: bool, textLog: TextLog, cancel: CancellationToken, progress: IProgress) -> tuple[bool, Iterable[Polyline], Iterable[Polyline], Mesh]: ...
    @overload
    @staticmethod
    def MeshMeshAccurate(meshA: Mesh, meshB: Mesh, tolerance: float) -> Iterable[Polyline]: ...
    @overload
    @staticmethod
    def MeshMeshFast(meshA: Mesh, meshB: Mesh) -> Iterable[Line]: ...
    @overload
    @staticmethod
    def MeshMeshPredicate(meshes: Iterable[Mesh], tolerance: float, textLog: TextLog) -> tuple[bool, Iterable[int]]: ...
    @overload
    @staticmethod
    def MeshPlane(mesh: Mesh, planes: Iterable[Plane]) -> Iterable[Polyline]: ...
    @overload
    @staticmethod
    def MeshPlane(mesh: Mesh, plane: Plane) -> Iterable[Polyline]: ...
    @overload
    @staticmethod
    def MeshPlane(mesh: Mesh, cache: MeshIntersectionCache, plane: Plane, tolerance: float) -> Iterable[Polyline]: ...
    @overload
    @staticmethod
    def MeshPlane(mesh: Mesh, cache: MeshIntersectionCache, planes: Iterable[Plane], tolerance: float) -> Iterable[Polyline]: ...
    @overload
    @staticmethod
    def MeshPolyline(mesh: Mesh, curve: PolylineCurve) -> tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def MeshPolylineSorted(mesh: Mesh, curve: PolylineCurve) -> tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def MeshRay(mesh: Mesh, ray: Ray3d) -> float: ...
    @overload
    @staticmethod
    def MeshRay(mesh: Mesh, ray: Ray3d) -> tuple[float, Iterable[int]]: ...
    @overload
    @staticmethod
    def PlaneBoundingBox(plane: Plane, boundingBox: BoundingBox) -> tuple[bool, Polyline]: ...
    @overload
    @staticmethod
    def PlaneCircle(plane: Plane, circle: Circle) -> tuple[PlaneCircleIntersection, float, float]: ...
    @overload
    @staticmethod
    def PlanePlane(planeA: Plane, planeB: Plane) -> tuple[bool, Line]: ...
    @overload
    @staticmethod
    def PlanePlanePlane(planeA: Plane, planeB: Plane, planeC: Plane) -> tuple[bool, Point3d]: ...
    @overload
    @staticmethod
    def PlaneSphere(plane: Plane, sphere: Sphere) -> tuple[PlaneSphereIntersection, Circle]: ...
    @overload
    @staticmethod
    def ProjectPointsToBreps(breps: Iterable[Brep], points: Iterable[Point3d], direction: Vector3d, tolerance: float) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def ProjectPointsToBrepsEx(breps: Iterable[Brep], points: Iterable[Point3d], direction: Vector3d, tolerance: float) -> tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def ProjectPointsToMeshes(meshes: Iterable[Mesh], points: Iterable[Point3d], direction: Vector3d, tolerance: float) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def ProjectPointsToMeshesEx(meshes: Iterable[Mesh], points: Iterable[Point3d], direction: Vector3d, tolerance: float) -> tuple[Iterable[Point3d], Iterable[int]]: ...
    @overload
    @staticmethod
    def RayShoot(ray: Ray3d, geometry: Iterable[GeometryBase], maxReflections: int) -> Iterable[Point3d]: ...
    @overload
    @staticmethod
    def RayShoot(geometry: Iterable[GeometryBase], ray: Ray3d, maxReflections: int) -> Iterable[RayShootEvent]: ...
    @overload
    @staticmethod
    def SphereSphere(sphereA: Sphere, sphereB: Sphere) -> tuple[SphereSphereIntersection, Circle]: ...
    @overload
    @staticmethod
    def SurfaceSurface(surfaceA: Surface, surfaceB: Surface, tolerance: float) -> tuple[bool, Iterable[Curve], Iterable[Point3d]]: ...
    @overload
    def ToString(self) -> str: ...


class IntersectionEvent:
    @overload
    def __init__(self): ...
    @overload
    @staticmethod
    def CompareEquivalent(eventA: IntersectionEvent, eventB: IntersectionEvent, relativePointTolerance: float) -> bool: ...
    @overload
    @staticmethod
    def CompareEquivalent(eventA: IntersectionEvent, eventB: IntersectionEvent, relativePointTolerance: float, log: TextLog) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def IsOverlap(self) -> bool: ...
    @property
    def IsPoint(self) -> bool: ...
    @property
    def OverlapA(self) -> Interval: ...
    @property
    def OverlapB(self) -> Interval: ...
    @property
    def ParameterA(self) -> float: ...
    @property
    def ParameterB(self) -> float: ...
    @property
    def PointA(self) -> Point3d: ...
    @property
    def PointA2(self) -> Point3d: ...
    @property
    def PointB(self) -> Point3d: ...
    @property
    def PointB2(self) -> Point3d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def SurfaceOverlapParameter(self) -> tuple[Interval, Interval]: ...
    @overload
    def SurfacePointParameter(self) -> tuple[float, float]: ...
    @overload
    def ToString(self) -> str: ...


class LineCircleIntersection(Enum):
    # None = 0
    Single = 1
    Multiple = 2


class LineCylinderIntersection(Enum):
    # None = 0
    Single = 1
    Multiple = 2
    Overlap = 3


class LineSphereIntersection(Enum):
    # None = 0
    Single = 1
    Multiple = 2


class MeshClash:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @staticmethod
    def FindDetail(objA: RhinoObject, objB: RhinoObject, distance: float) -> Iterable[Mesh]: ...
    @overload
    @staticmethod
    def FindDetail(objA: RhinoObject, objB: RhinoObject, distance: float, meshType: MeshType, meshingParameters: MeshingParameters) -> Iterable[Mesh]: ...
    @property
    def ClashPoint(self) -> Point3d: ...
    @property
    def ClashRadius(self) -> float: ...
    @property
    def MeshA(self) -> Mesh: ...
    @property
    def MeshB(self) -> Mesh: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    @staticmethod
    def Search(setA: Iterable[RhinoObject], setB: Iterable[RhinoObject], distance: float) -> Iterable[MeshInterference]: ...
    @overload
    @staticmethod
    def Search(setA: Iterable[Mesh], setB: Iterable[Mesh], distance: float, maxEventCount: int) -> Iterable[MeshClash]: ...
    @overload
    @staticmethod
    def Search(meshA: Mesh, setB: Iterable[Mesh], distance: float, maxEventCount: int) -> Iterable[MeshClash]: ...
    @overload
    @staticmethod
    def Search(meshA: Mesh, meshB: Mesh, distance: float, maxEventCount: int) -> Iterable[MeshClash]: ...
    @overload
    @staticmethod
    def Search(setA: Iterable[RhinoObject], setB: Iterable[RhinoObject], distance: float, meshType: MeshType, meshingParameters: MeshingParameters) -> Iterable[MeshInterference]: ...
    @overload
    def ToString(self) -> str: ...


class MeshInterference:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def HitPoints(self) -> Iterable[Point3d]: ...
    @property
    def IndexA(self) -> int: ...
    @property
    def IndexB(self) -> int: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @HitPoints.setter
    def HitPoints(self, value: Iterable[Point3d]) -> None: ...
    @IndexA.setter
    def IndexA(self, value: int) -> None: ...
    @IndexB.setter
    def IndexB(self, value: int) -> None: ...
    @overload
    def ToString(self) -> str: ...


class MeshIntersectionCache:
    @overload
    def __init__(self): ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @overload
    def ToString(self) -> str: ...


class PlaneCircleIntersection(Enum):
    # None = 0
    Tangent = 1
    Secant = 2
    Parallel = 3
    Coincident = 4


class PlaneSphereIntersection(Enum):
    # None = 0
    Point = 1
    Circle = 2


class RayShootEvent:
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def BrepFaceIndex(self) -> int: ...
    @property
    def GeometryIndex(self) -> int: ...
    @property
    def Point(self) -> Point3d: ...
    @overload
    def GetHashCode(self) -> int: ...
    @overload
    def GetType(self) -> type: ...
    @BrepFaceIndex.setter
    def BrepFaceIndex(self, value: int) -> None: ...
    @GeometryIndex.setter
    def GeometryIndex(self, value: int) -> None: ...
    @Point.setter
    def Point(self, value: Point3d) -> None: ...
    @overload
    def ToString(self) -> str: ...


class SphereSphereIntersection(Enum):
    # None = 0
    Point = 1
    Circle = 2
    Overlap = 3
